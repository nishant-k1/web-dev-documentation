# Multi-Factor Authentication (MFA)

Understanding Multi-Factor Authentication (MFA/2FA) - TOTP, SMS, Email-based 2FA, and implementing secure two-factor authentication.

---

## Core Concept

**Multi-Factor Authentication (MFA)** requires users to provide two or more verification factors to access their account.

**Authentication Factors:**

1. **Something you know** - Password, PIN
2. **Something you have** - Phone, authenticator app
3. **Something you are** - Fingerprint, face ID

**2FA (Two-Factor Authentication)** is a subset of MFA requiring exactly 2 factors.

---

## Why MFA?

### Security Benefits

**Without MFA:**

- ❌ Password alone can be stolen/guessed
- ❌ Single point of failure
- ❌ Vulnerable to phishing

**With MFA:**

- ✅ Even if password is stolen, attacker needs second factor
- ✅ Multiple layers of security
- ✅ Significantly reduces account compromise

**Statistics:**

- MFA blocks 99.9% of automated attacks
- Required by many enterprise security policies
- Industry best practice

---

## Types of MFA

### 1. TOTP (Time-based One-Time Password)

**How it works:**

- User installs authenticator app (Google Authenticator, Authy)
- App generates 6-digit code that changes every 30 seconds
- User enters code during login

**Pros:**

- ✅ Works offline
- ✅ No SMS costs
- ✅ More secure than SMS
- ✅ Industry standard

**Cons:**

- ⚠️ Requires app installation
- ⚠️ Can lose access if phone lost

---

### 2. SMS-Based 2FA

**How it works:**

- User enters password
- Server sends SMS with 6-digit code
- User enters code to complete login

**Pros:**

- ✅ Easy to use
- ✅ No app installation needed
- ✅ Familiar to users

**Cons:**

- ❌ Vulnerable to SIM swapping
- ❌ SMS can be intercepted
- ❌ Requires phone number
- ❌ SMS delivery delays

---

### 3. Email-Based 2FA

**How it works:**

- User enters password
- Server sends email with verification code
- User enters code from email

**Pros:**

- ✅ Easy to implement
- ✅ No phone required
- ✅ Familiar to users

**Cons:**

- ❌ Less secure (email can be compromised)
- ❌ Email delivery delays
- ❌ Requires email access

---

### 4. Backup Codes

**How it works:**

- Generated when MFA is enabled
- One-time use codes
- Used if authenticator app/phone is lost

**Example:**

```
Backup Codes:
1. A7B9-C2D4-E6F8
2. G3H5-J7K9-L1M3
3. N5P7-Q9R1-S3T5
...
```

---

## TOTP Implementation (Recommended)

### Step 1: Backend - Generate Secret

```javascript
const speakeasy = require("speakeasy");
const QRCode = require("qrcode");

// Generate secret for user
app.post("/api/mfa/setup", authenticateToken, async (req, res) => {
  const userId = req.user.userId;

  // Generate secret
  const secret = speakeasy.generateSecret({
    name: `YourApp (${req.user.email})`,
    issuer: "YourApp",
  });

  // Store secret in database (encrypted)
  await User.findByIdAndUpdate(userId, {
    mfaSecret: secret.base32, // Store base32 secret
    mfaEnabled: false, // Not enabled until verified
  });

  // Generate QR code URL
  const qrCodeUrl = await QRCode.toDataURL(secret.otpauth_url);

  res.json({
    secret: secret.base32,
    qrCode: qrCodeUrl,
  });
});
```

---

### Step 2: Frontend - Display QR Code

```javascript
import QRCode from "qrcode.react";

function MFASetup() {
  const [qrCode, setQrCode] = useState(null);
  const [secret, setSecret] = useState(null);
  const [verificationCode, setVerificationCode] = useState("");

  useEffect(() => {
    // Get QR code from backend
    fetch("/api/mfa/setup", {
      headers: {
        Authorization: `Bearer ${localStorage.getItem("token")}`,
      },
    })
      .then((res) => res.json())
      .then((data) => {
        setQrCode(data.qrCode);
        setSecret(data.secret);
      });
  }, []);

  const handleVerify = async () => {
    const res = await fetch("/api/mfa/verify-setup", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${localStorage.getItem("token")}`,
      },
      body: JSON.stringify({ code: verificationCode }),
    });

    if (res.ok) {
      alert("MFA enabled successfully!");
    } else {
      alert("Invalid code. Please try again.");
    }
  };

  return (
    <div>
      <h2>Enable Two-Factor Authentication</h2>
      <p>Scan this QR code with your authenticator app:</p>
      {qrCode && <img src={qrCode} alt="QR Code" />}
      <p>Or enter this secret manually: {secret}</p>

      <input
        type="text"
        placeholder="Enter 6-digit code"
        value={verificationCode}
        onChange={(e) => setVerificationCode(e.target.value)}
        maxLength={6}
      />
      <button onClick={handleVerify}>Verify & Enable</button>
    </div>
  );
}
```

---

### Step 3: Backend - Verify Setup Code

```javascript
app.post('/api/mfa/verify-setup', authenticateToken, async (req, res) => {
  const { code } = req.body;
  const userId = req.user.userId;

  const user = await User.findById(userId);

  // Verify TOTP code
  const verified = speakeasy.totp.verify({
    secret: user.mfaSecret,
    encoding: 'base32',
    token: code,
    window: 2, // Allow 2 time steps (60 seconds) tolerance
  });

  if (verified) {
    // Enable MFA
    await User.findByIdAndUpdate(userId, {
      mfaEnabled: true,
    });

    // Generate backup codes
    const backupCodes = Array.from({ length: 10 }, () =>
      Math.random().toString(36).substring(2, 10).toUpperCase()
    );

    await User.findByIdAndUpdate(userId, {
      backupCodes: backupCodes.map((code) => ({
        code: await bcrypt.hash(code, 10), // Hash backup codes
        used: false,
      })),
    });

    res.json({
      message: 'MFA enabled successfully',
      backupCodes: backupCodes, // Show only once
    });
  } else {
    res.status(400).json({ error: 'Invalid verification code' });
  }
});
```

---

### Step 4: Backend - Verify During Login

```javascript
app.post("/api/login", async (req, res) => {
  const { email, password, mfaCode } = req.body;

  // 1. Verify password
  const user = await User.findOne({ email });
  if (!user || !(await bcrypt.compare(password, user.password))) {
    return res.status(401).json({ error: "Invalid credentials" });
  }

  // 2. Check if MFA is enabled
  if (user.mfaEnabled) {
    if (!mfaCode) {
      // MFA required but not provided
      return res.status(200).json({
        requiresMFA: true,
        message: "MFA code required",
      });
    }

    // Verify MFA code
    const totpValid = speakeasy.totp.verify({
      secret: user.mfaSecret,
      encoding: "base32",
      token: mfaCode,
      window: 2,
    });

    // Check backup codes if TOTP fails
    let backupCodeValid = false;
    if (!totpValid) {
      for (const backupCode of user.backupCodes) {
        if (!backupCode.used) {
          const isValid = await bcrypt.compare(mfaCode, backupCode.code);
          if (isValid) {
            backupCodeValid = true;
            backupCode.used = true;
            await user.save();
            break;
          }
        }
      }
    }

    if (!totpValid && !backupCodeValid) {
      return res.status(401).json({ error: "Invalid MFA code" });
    }
  }

  // 3. Create JWT token
  const token = jwt.sign(
    { userId: user.id, email: user.email },
    process.env.JWT_SECRET,
    { expiresIn: "24h" }
  );

  res.json({ token, user: { id: user.id, email: user.email } });
});
```

---

### Step 5: Frontend - Handle MFA During Login

```javascript
function Login() {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [mfaCode, setMfaCode] = useState("");
  const [requiresMFA, setRequiresMFA] = useState(false);

  const handleLogin = async (e) => {
    e.preventDefault();

    const res = await fetch("/api/login", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        email,
        password,
        mfaCode: requiresMFA ? mfaCode : undefined,
      }),
    });

    const data = await res.json();

    if (data.requiresMFA) {
      // Password correct, but MFA required
      setRequiresMFA(true);
    } else if (res.ok) {
      // Login successful
      localStorage.setItem("token", data.token);
      window.location.href = "/dashboard";
    } else {
      alert(data.error || "Login failed");
    }
  };

  return (
    <form onSubmit={handleLogin}>
      <input
        type="email"
        placeholder="Email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
        required
      />
      <input
        type="password"
        placeholder="Password"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
        required
      />

      {requiresMFA && (
        <div>
          <label>Enter 6-digit code from authenticator app:</label>
          <input
            type="text"
            placeholder="000000"
            value={mfaCode}
            onChange={(e) => setMfaCode(e.target.value)}
            maxLength={6}
            required
          />
        </div>
      )}

      <button type="submit">Login</button>
    </form>
  );
}
```

---

## SMS-Based 2FA Implementation

### Backend - Send SMS Code

```javascript
const twilio = require("twilio");

const client = twilio(
  process.env.TWILIO_ACCOUNT_SID,
  process.env.TWILIO_AUTH_TOKEN
);

app.post("/api/login", async (req, res) => {
  const { email, password, smsCode } = req.body;

  // Verify password
  const user = await User.findOne({ email });
  if (!user || !(await bcrypt.compare(password, user.password))) {
    return res.status(401).json({ error: "Invalid credentials" });
  }

  if (user.mfaEnabled && user.mfaType === "sms") {
    if (!smsCode) {
      // Generate 6-digit code
      const code = Math.floor(100000 + Math.random() * 900000).toString();
      const expiresAt = new Date(Date.now() + 10 * 60 * 1000); // 10 minutes

      // Store code in database
      await User.findByIdAndUpdate(user.id, {
        mfaCode: await bcrypt.hash(code, 10),
        mfaCodeExpiresAt: expiresAt,
      });

      // Send SMS
      await client.messages.create({
        body: `Your verification code is: ${code}`,
        from: process.env.TWILIO_PHONE_NUMBER,
        to: user.phoneNumber,
      });

      return res.json({
        requiresMFA: true,
        message: "SMS code sent",
      });
    }

    // Verify SMS code
    if (user.mfaCodeExpiresAt < new Date()) {
      return res.status(401).json({ error: "Code expired" });
    }

    const isValid = await bcrypt.compare(smsCode, user.mfaCode);
    if (!isValid) {
      return res.status(401).json({ error: "Invalid code" });
    }

    // Clear code
    await User.findByIdAndUpdate(user.id, {
      mfaCode: null,
      mfaCodeExpiresAt: null,
    });
  }

  // Create token
  const token = jwt.sign({ userId: user.id }, process.env.JWT_SECRET, {
    expiresIn: "24h",
  });

  res.json({ token });
});
```

---

## Email-Based 2FA Implementation

### Backend - Send Email Code

```javascript
const nodemailer = require("nodemailer");

const transporter = nodemailer.createTransport({
  service: "gmail",
  auth: {
    user: process.env.EMAIL_USER,
    pass: process.env.EMAIL_PASSWORD,
  },
});

app.post("/api/login", async (req, res) => {
  const { email, password, emailCode } = req.body;

  // Verify password
  const user = await User.findOne({ email });
  if (!user || !(await bcrypt.compare(password, user.password))) {
    return res.status(401).json({ error: "Invalid credentials" });
  }

  if (user.mfaEnabled && user.mfaType === "email") {
    if (!emailCode) {
      // Generate code
      const code = Math.floor(100000 + Math.random() * 900000).toString();
      const expiresAt = new Date(Date.now() + 10 * 60 * 1000);

      await User.findByIdAndUpdate(user.id, {
        mfaCode: await bcrypt.hash(code, 10),
        mfaCodeExpiresAt: expiresAt,
      });

      // Send email
      await transporter.sendMail({
        from: process.env.EMAIL_USER,
        to: user.email,
        subject: "Your Verification Code",
        html: `
          <h2>Your verification code is: ${code}</h2>
          <p>This code will expire in 10 minutes.</p>
        `,
      });

      return res.json({
        requiresMFA: true,
        message: "Verification code sent to email",
      });
    }

    // Verify code
    if (user.mfaCodeExpiresAt < new Date()) {
      return res.status(401).json({ error: "Code expired" });
    }

    const isValid = await bcrypt.compare(emailCode, user.mfaCode);
    if (!isValid) {
      return res.status(401).json({ error: "Invalid code" });
    }

    // Clear code
    await User.findByIdAndUpdate(user.id, {
      mfaCode: null,
      mfaCodeExpiresAt: null,
    });
  }

  // Create token
  const token = jwt.sign({ userId: user.id }, process.env.JWT_SECRET, {
    expiresIn: "24h",
  });

  res.json({ token });
});
```

---

## MFA Recovery

### Disable MFA with Backup Codes

```javascript
app.post("/api/mfa/disable", authenticateToken, async (req, res) => {
  const { backupCode } = req.body;
  const userId = req.user.userId;

  const user = await User.findById(userId);

  // Verify backup code
  let backupCodeValid = false;
  for (const code of user.backupCodes) {
    if (!code.used) {
      const isValid = await bcrypt.compare(backupCode, code.code);
      if (isValid) {
        backupCodeValid = true;
        code.used = true;
        break;
      }
    }
  }

  if (!backupCodeValid) {
    return res.status(401).json({ error: "Invalid backup code" });
  }

  // Disable MFA
  await User.findByIdAndUpdate(userId, {
    mfaEnabled: false,
    mfaSecret: null,
    backupCodes: [],
  });

  res.json({ message: "MFA disabled successfully" });
});
```

---

## Security Best Practices

### 1. Rate Limit MFA Attempts

```javascript
const mfaLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5, // 5 attempts
  message: "Too many MFA attempts, please try again later",
});

app.post("/api/login", mfaLimiter, async (req, res) => {
  // Login with MFA
});
```

---

### 2. Expire Codes Quickly

```javascript
// TOTP: 30 seconds (automatic)
// SMS/Email: 10 minutes
const expiresAt = new Date(Date.now() + 10 * 60 * 1000);
```

---

### 3. Hash Backup Codes

```javascript
// ✅ Good - Hash backup codes
backupCodes: backupCodes.map((code) => ({
  code: await bcrypt.hash(code, 10),
  used: false,
})),
```

---

### 4. One-Time Use Codes

```javascript
// Mark backup code as used
backupCode.used = true;
await user.save();
```

---

## Comparison: TOTP vs SMS vs Email

| Aspect              | TOTP             | SMS                | Email              |
| ------------------- | ---------------- | ------------------ | ------------------ |
| **Security**        | ✅ Highest       | ⚠️ Medium          | ⚠️ Lower           |
| **Cost**            | ✅ Free          | ❌ Per SMS         | ✅ Free            |
| **Reliability**     | ✅ Works offline | ⚠️ Delivery delays | ⚠️ Delivery delays |
| **User Experience** | ⚠️ Requires app  | ✅ Easy            | ✅ Easy            |
| **SIM Swap Risk**   | ✅ No risk       | ❌ Vulnerable      | ✅ No risk         |

**Recommendation:** Use TOTP for best security, SMS/Email as fallback.

---

## Common Questions

### Q: What if user loses authenticator app?

**A:** Use backup codes. If backup codes lost, require account recovery (email verification).

### Q: Can I use multiple MFA methods?

**A:** Yes, allow users to enable multiple methods (TOTP + SMS as backup).

### Q: How do I handle MFA in stateless JWT?

**A:** Require MFA verification before issuing JWT. JWT itself doesn't store MFA status.

### Q: Should MFA be required for all users?

**A:** Optional for regular users, required for admin/privileged accounts.

### Q: How often should users re-verify MFA?

**A:** Once per session. After login, MFA verified for entire session.

---

## Related Topics

- [JWT Authentication Workflow](./01.%20JWT%20Authentication%20Workflow.md) - Login flow with MFA
- [Password Security](./06.%20Password%20Security.md) - First factor (password)
- [Security Best Practices](./08.%20Security%20Best%20Practices.md) - MFA security

---

## Summary

**MFA Types:**

- **TOTP** - Time-based codes (Google Authenticator) - Most secure
- **SMS** - Text message codes - Easy but less secure
- **Email** - Email codes - Easy but less secure
- **Backup Codes** - One-time recovery codes

**MFA Flow:**

1. User enters password
2. If MFA enabled → Request second factor
3. User provides MFA code
4. Server verifies code
5. If valid → Issue token
6. If invalid → Reject login

**Best Practices:**

- Use TOTP for best security
- Generate backup codes
- Rate limit MFA attempts
- Expire codes quickly
- Hash backup codes

**Key Takeaway:** MFA adds a second layer of security. TOTP (authenticator apps) is most secure. Always provide backup codes for recovery. Verify MFA before issuing authentication tokens.
