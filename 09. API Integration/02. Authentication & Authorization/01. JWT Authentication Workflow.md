# JWT Authentication Workflow

Understanding JWT (JSON Web Token) authentication - how it works, why it's stateless, and the complete workflow.

---

## Core Concept

**JWT (JSON Web Token)** is a token-based authentication method where the token itself contains all user information, making it stateless.

**Key Characteristics:**

- ✅ **Stateless** - Server doesn't store session data
- ✅ **Self-contained** - Token contains user information
- ✅ **Signed** - Uses secret key for verification
- ✅ **Portable** - Can be used across different servers

---

## JWT Structure

### Three Parts of JWT (HPS- Header, Payload and Signature)

A JWT consists of three parts separated by dots (`.`):

```sql
header.payload.signature
```

**Example:**

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOjEyMywicm9sZSI6ImFkbWluIn0.signature
```

---

### 1. Header

**Contains:**

- Token type (JWT)
- Signing algorithm (HS256, RS256, etc.)

**Example:**

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

**Encoded:** Base64URL encoded

---

### 2. Payload

**Contains:**

- User claims (user ID, role, permissions)
- Standard claims (exp, iat, iss)
- Custom claims (any data you want)

**Example:**

```json
{
  "userId": 123,
  "role": "admin",
  "email": "user@example.com",
  "exp": 1735689600,
  "iat": 1735603200
}
```

**Encoded:** Base64URL encoded

**Important:** Payload is **not encrypted** - it's just encoded. Anyone can decode it. Don't put sensitive data in payload.

---

### 3. Signature

**How it's created:**

```
signature = HMACSHA256(
  base64UrlEncode(header) + "." + base64UrlEncode(payload),
  secret-key
)
```

**Purpose:**

- Verifies token hasn't been tampered with
- Confirms token was issued by your server

---

## Complete JWT Workflow

### Step 1: User Login

**Frontend sends credentials:**

```javascript
fetch("/api/login", {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
  },
  body: JSON.stringify({
    email: "user@example.com",
    password: "password123",
  }),
});
```

**Backend verifies credentials:**

```javascript
// Backend (Express.js example)
app.post("/api/login", async (req, res) => {
  const { email, password } = req.body;

  // 1. Find user in database
  const user = await User.findOne({ email });

  // 2. Verify password (compare hashed password)
  const isValid = await bcrypt.compare(password, user.password);

  if (!isValid) {
    return res.status(401).json({ error: "Invalid credentials" });
  }

  // 3. Create JWT token
  const token = jwt.sign(
    { userId: user.id, role: user.role },
    process.env.JWT_SECRET, // Secret key from environment variable
    { expiresIn: "24h" }
  );

  // 4. Send token to frontend
  res.json({ token, user: { id: user.id, email: user.email } });
});
```

---

### Step 2: Store Token on Frontend

**Frontend receives and stores token:**

```javascript
fetch("/api/login", {
  method: "POST",
  body: JSON.stringify({ email, password }),
})
  .then((res) => res.json())
  .then((data) => {
    // Store token
    localStorage.setItem("token", data.token);
    // Or use httpOnly cookie (more secure)
  });
```

---

### Step 3: Send Token with Requests

**Include token in Authorization header:**

```javascript
const token = localStorage.getItem("token");

fetch("/api/users", {
  headers: {
    Authorization: `Bearer ${token}`,
  },
});
```

---

### Step 4: Server Verifies Token

**Backend verifies token on each request:**

```javascript
// Middleware to verify token
function authenticateToken(req, res, next) {
  const authHeader = req.headers["authorization"];
  const token = authHeader && authHeader.split(" ")[1]; // Bearer TOKEN

  if (!token) {
    return res.status(401).json({ error: "No token provided" });
  }

  // Verify token using secret key
  jwt.verify(token, process.env.JWT_SECRET, (err, decoded) => {
    if (err) {
      return res.status(403).json({ error: "Invalid or expired token" });
    }

    // Token is valid - attach user info to request
    req.user = decoded; // { userId: 123, role: 'admin' }
    next();
  });
}

// Use middleware
app.get("/api/users", authenticateToken, (req, res) => {
  // req.user contains decoded token data
  res.json({ message: "Protected data", user: req.user });
});
```

---

## Why JWT is Stateless

### Key Point: Server Doesn't Store Tokens

**What server stores:**

- ✅ **Secret key** - One key for all tokens (in environment variable)
- ❌ **Individual tokens** - NOT stored

**What client stores:**

- ✅ **JWT token** - Contains all user information

---

### Stateless Explanation

**Session-Based (Stateful):**

```sql
User Login → Server creates session → Stores session in database/memory
Next Request → Server looks up session → Finds user data
```

**JWT-Based (Stateless):**

```sql
User Login → Server creates token → Token contains user data
Next Request → Server verifies token signature → Extracts user data from token
```

**Difference:**

- **Session:** Server stores user data, cookie is just an ID
- **JWT:** Token contains user data, server just verifies signature

---

## Secret Key

### What is Secret Key?

**Secret key** is a random string stored securely on the server (usually in environment variable).

**Example:**

```javascript
// .env file
JWT_SECRET=your-super-secret-key-here-12345
```

**Characteristics:**

- ✅ One secret key for all tokens
- ✅ Stored in environment variable (not in code)
- ✅ Never sent to client
- ✅ Used to sign and verify all tokens

---

### How Secret Key Works

**Signing (Creating Token):**

```javascript
// Server uses secret key to create signature
const token = jwt.sign(payload, secretKey);
```

**Verification (Validating Token):**

```javascript
// Server uses same secret key to verify signature
jwt.verify(token, secretKey, (err, decoded) => {
  if (err) {
    // Token invalid or tampered with
  } else {
    // Token valid - decoded contains payload
  }
});
```

**If token is tampered with:**

- Signature won't match
- Verification fails
- Token rejected

---

## JWT vs Session-Based

### Comparison

| Aspect                   | JWT                        | Session-Based           |
| ------------------------ | -------------------------- | ----------------------- |
| **State**                | Stateless                  | Stateful                |
| **User Data Storage**    | In token (client)          | On server               |
| **Server Storage**       | Secret key only            | Session data            |
| **Token/Cookie Content** | User data + signature      | Just session ID         |
| **Verification**         | Verify signature           | Lookup session ID       |
| **Scalability**          | Better (no server storage) | Requires shared storage |

---

### Why JWT is Called Stateless

**JWT is stateless because:**

- Server doesn't store user session data
- Server doesn't need to look up user data
- User data is in the token itself
- Server only needs secret key (constant, not per-user)

**Session is stateful because:**

- Server stores user session data
- Server must look up session for each request
- Cookie only contains session ID (pointer)
- Server maintains state for each user

---

## Complete Example

### Frontend (React)

```javascript
// Login
async function login(email, password) {
  const res = await fetch("/api/login", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ email, password }),
  });

  const { token } = await res.json();
  localStorage.setItem("token", token);
}

// Protected Request
async function fetchUsers() {
  const token = localStorage.getItem("token");

  const res = await fetch("/api/users", {
    headers: {
      Authorization: `Bearer ${token}`,
    },
  });

  if (res.status === 401) {
    // Token invalid - redirect to login
    window.location.href = "/login";
    return;
  }

  return await res.json();
}
```

### Backend (Express.js)

```javascript
const jwt = require('jsonwebtoken');

// Login endpoint
app.post('/api/login', async (req, res) => {
  const { email, password } = req.body;

  // Verify credentials
  const user = await User.findOne({ email });
  if (!user || !await bcrypt.compare(password, user.password)) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }

  // Create token
  const token = jwt.sign(
    { userId: user.id, role: user.role },
    process.env.JWT_SECRET,
    { expiresIn: '24h' }
  );

  res.json({ token });
});

// Protected endpoint
app.get('/api/users', authenticateToken, (req, res) => {
  // req.user contains decoded token
  res.json({ users: [...] });
});
```

---

## Common Questions

### Q: Where is the secret key stored?

**A:** In environment variable on the server (`.env` file). Never in code or database.

### Q: Does server store each JWT token?

**A:** No. Server only stores the secret key. Tokens are stored on the client side.

### Q: What if token is stolen?

**A:** Token can be used until it expires. That's why tokens should have short expiration times. Use refresh tokens for better security.

### Q: Can I decode JWT without secret key?

**A:** Yes, you can decode the payload (it's just Base64). But you cannot create a valid signature without the secret key.

### Q: Why is JWT stateless if server stores secret key?

**A:** Secret key is constant (one key for all tokens). Session data is per-user (different for each user). That's the difference.

---

## Related Topics

- [Session-Based Authentication](./02.%20Session-Based%20Authentication.md) - Alternative to JWT
- [Authentication vs Authorization](./index.md) - Concepts
- [HTTP Authentication](../01.%20HTTP/08.%20Authentication.md) - HTTP-level auth
- [Protected Routes](./04.%20Protected%20Routes.md) - Route protection

---

## Summary

**JWT Workflow:**

1. User logs in with credentials
2. Server verifies credentials
3. Server creates JWT (signed with secret key)
4. Token sent to frontend
5. Frontend stores token
6. Frontend sends token with each request
7. Server verifies token signature
8. Server extracts user data from token

**Key Points:**

- JWT is stateless (server doesn't store user data)
- Secret key is stored in environment variable
- Token contains user information
- Server verifies signature, not looks up data
- Token is self-contained

**Why Stateless:**

- Server doesn't store per-user session data
- Only stores one secret key (constant)
- User data is in token itself
- No database lookup needed
