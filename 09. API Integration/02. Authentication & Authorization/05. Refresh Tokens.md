# Refresh Tokens

Understanding refresh tokens - why they exist, how they work, and implementing secure token refresh flow.

---

## Core Concept

**Refresh Tokens** are long-lived tokens used to obtain new access tokens without requiring user to log in again.

**Two-Token System:**

- **Access Token** - Short-lived (15 minutes - 1 hour) - Used for API requests
- **Refresh Token** - Long-lived (7-30 days) - Used to get new access tokens

---

## Why Refresh Tokens?

### Problem with Single Token

**Single JWT Token Issues:**

- ❌ If token expires → User must log in again
- ❌ If token stolen → Valid until expiry (security risk)
- ❌ Long expiry → Security risk
- ❌ Short expiry → Poor UX (frequent logins)

---

### Solution: Two-Token System

**Access Token (Short-lived):**

- ✅ Expires quickly (15 min - 1 hour)
- ✅ Limited damage if stolen
- ✅ Used for API requests

**Refresh Token (Long-lived):**

- ✅ Expires slowly (7-30 days)
- ✅ Stored securely (HttpOnly cookie)
- ✅ Used only to refresh access token

---

## Complete Refresh Token Flow

### Step 1: Login - Get Both Tokens

**Backend:**

```javascript
app.post("/api/login", async (req, res) => {
  const { email, password } = req.body;

  // Verify credentials
  const user = await User.findOne({ email });
  if (!user || !(await bcrypt.compare(password, user.password))) {
    return res.status(401).json({ error: "Invalid credentials" });
  }

  // Create access token (short-lived)
  const accessToken = jwt.sign(
    { userId: user.id, role: user.role },
    process.env.JWT_SECRET,
    { expiresIn: "15m" } // 15 minutes
  );

  // Create refresh token (long-lived)
  const refreshToken = jwt.sign(
    { userId: user.id },
    process.env.REFRESH_TOKEN_SECRET,
    { expiresIn: "7d" } // 7 days
  );

  // Store refresh token in database (for revocation)
  await RefreshToken.create({
    userId: user.id,
    token: refreshToken,
    expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
  });

  // Send tokens
  res.cookie("refreshToken", refreshToken, {
    httpOnly: true,
    secure: process.env.NODE_ENV === "production",
    sameSite: "strict",
    maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days
  });

  res.json({
    accessToken,
    user: { id: user.id, email: user.email },
  });
});
```

---

### Step 2: Use Access Token for Requests

**Frontend:**

```javascript
// Store access token
localStorage.setItem("accessToken", data.accessToken);

// Use for API requests
fetch("/api/users", {
  headers: {
    Authorization: `Bearer ${accessToken}`,
  },
});
```

---

### Step 3: Access Token Expires

**Backend returns 401:**

```javascript
// Middleware detects expired token
if (err.name === "TokenExpiredError") {
  return res.status(401).json({ error: "Token expired" });
}
```

---

### Step 4: Refresh Access Token

**Frontend automatically refreshes:**

```javascript
// Intercept 401 responses
axios.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config;

    // If 401 and not already retrying
    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;

      try {
        // Refresh access token
        const response = await axios.post(
          "/api/refresh",
          {},
          {
            withCredentials: true, // Send refresh token cookie
          }
        );

        const { accessToken } = response.data;
        localStorage.setItem("accessToken", accessToken);

        // Retry original request with new token
        originalRequest.headers.Authorization = `Bearer ${accessToken}`;
        return axios(originalRequest);
      } catch (refreshError) {
        // Refresh failed - redirect to login
        localStorage.removeItem("accessToken");
        window.location.href = "/login";
        return Promise.reject(refreshError);
      }
    }

    return Promise.reject(error);
  }
);
```

---

### Step 5: Backend Validates Refresh Token

**Backend refresh endpoint:**

```javascript
app.post("/api/refresh", async (req, res) => {
  const refreshToken = req.cookies.refreshToken;

  if (!refreshToken) {
    return res.status(401).json({ error: "No refresh token" });
  }

  try {
    // Verify refresh token
    const decoded = jwt.verify(refreshToken, process.env.REFRESH_TOKEN_SECRET);

    // Check if refresh token exists in database
    const storedToken = await RefreshToken.findOne({
      userId: decoded.userId,
      token: refreshToken,
    });

    if (!storedToken || storedToken.expiresAt < new Date()) {
      return res.status(401).json({ error: "Invalid refresh token" });
    }

    // Get user
    const user = await User.findById(decoded.userId);

    // Generate new access token
    const accessToken = jwt.sign(
      { userId: user.id, role: user.role },
      process.env.JWT_SECRET,
      { expiresIn: "15m" }
    );

    res.json({ accessToken });
  } catch (error) {
    return res.status(401).json({ error: "Invalid refresh token" });
  }
});
```

---

## Storage Best Practices

### Access Token Storage

**Options:**

1. **Memory (Best for SPA)**

   ```javascript
   // Store in memory variable
   let accessToken = null;
   ```

2. **localStorage (Common but less secure)**

   ```javascript
   localStorage.setItem("accessToken", token);
   ```

3. **Session Storage**
   ```javascript
   sessionStorage.setItem("accessToken", token);
   ```

---

### Refresh Token Storage

**HttpOnly Cookie (Best Practice):**

```javascript
// Backend sets HttpOnly cookie
res.cookie("refreshToken", refreshToken, {
  httpOnly: true, // Not accessible via JavaScript (XSS protection)
  secure: true, // HTTPS only
  sameSite: "strict", // CSRF protection
  maxAge: 7 * 24 * 60 * 60 * 1000,
});
```

**Why HttpOnly Cookie:**

- ✅ Protected from XSS attacks
- ✅ Automatically sent with requests
- ✅ Cannot be accessed via JavaScript

---

## Token Rotation (Advanced)

### Rotating Refresh Tokens

**More secure pattern - rotate refresh token on each use:**

```javascript
app.post("/api/refresh", async (req, res) => {
  const oldRefreshToken = req.cookies.refreshToken;

  // Verify old refresh token
  const decoded = jwt.verify(oldRefreshToken, process.env.REFRESH_TOKEN_SECRET);

  // Delete old refresh token
  await RefreshToken.deleteOne({ token: oldRefreshToken });

  // Create new refresh token
  const newRefreshToken = jwt.sign(
    { userId: decoded.userId },
    process.env.REFRESH_TOKEN_SECRET,
    { expiresIn: "7d" }
  );

  // Store new refresh token
  await RefreshToken.create({
    userId: decoded.userId,
    token: newRefreshToken,
    expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
  });

  // Create new access token
  const accessToken = jwt.sign(
    { userId: decoded.userId, role: user.role },
    process.env.JWT_SECRET,
    { expiresIn: "15m" }
  );

  // Send new tokens
  res.cookie("refreshToken", newRefreshToken, {
    httpOnly: true,
    secure: true,
    sameSite: "strict",
    maxAge: 7 * 24 * 60 * 60 * 1000,
  });

  res.json({ accessToken });
});
```

---

## Complete React Example

### Custom Hook for Token Management

```javascript
import { useState, useEffect } from "react";
import axios from "axios";

function useAuth() {
  const [accessToken, setAccessToken] = useState(null);
  const [loading, setLoading] = useState(true);

  // Setup axios interceptor
  useEffect(() => {
    // Request interceptor - add access token
    const requestInterceptor = axios.interceptors.request.use(
      (config) => {
        const token = localStorage.getItem("accessToken");
        if (token) {
          config.headers.Authorization = `Bearer ${token}`;
        }
        return config;
      },
      (error) => Promise.reject(error)
    );

    // Response interceptor - handle token refresh
    const responseInterceptor = axios.interceptors.response.use(
      (response) => response,
      async (error) => {
        const originalRequest = error.config;

        if (error.response?.status === 401 && !originalRequest._retry) {
          originalRequest._retry = true;

          try {
            // Refresh access token
            const response = await axios.post(
              "/api/refresh",
              {},
              {
                withCredentials: true,
              }
            );

            const { accessToken: newToken } = response.data;
            setAccessToken(newToken);
            localStorage.setItem("accessToken", newToken);

            // Retry original request
            originalRequest.headers.Authorization = `Bearer ${newToken}`;
            return axios(originalRequest);
          } catch (refreshError) {
            // Refresh failed - logout
            setAccessToken(null);
            localStorage.removeItem("accessToken");
            window.location.href = "/login";
            return Promise.reject(refreshError);
          }
        }

        return Promise.reject(error);
      }
    );

    return () => {
      axios.interceptors.request.eject(requestInterceptor);
      axios.interceptors.response.eject(responseInterceptor);
    };
  }, []);

  // Load token on mount
  useEffect(() => {
    const token = localStorage.getItem("accessToken");
    setAccessToken(token);
    setLoading(false);
  }, []);

  return { accessToken, loading };
}
```

---

## Logout with Refresh Tokens

### Revoke Refresh Token

```javascript
app.post("/api/logout", async (req, res) => {
  const refreshToken = req.cookies.refreshToken;

  if (refreshToken) {
    // Delete refresh token from database
    await RefreshToken.deleteOne({ token: refreshToken });
  }

  // Clear cookie
  res.clearCookie("refreshToken", {
    httpOnly: true,
    secure: true,
    sameSite: "strict",
  });

  res.json({ message: "Logged out" });
});
```

---

## Common Questions

### Q: Why not just use one long-lived token?

**A:** Security. If stolen, long-lived token is valid for days/weeks. Short access token limits damage.

### Q: Where should I store refresh token?

**A:** HttpOnly cookie (most secure). Protects from XSS attacks.

### Q: Should I store refresh token in database?

**A:** Yes, for revocation. Allows you to invalidate tokens on logout or security breach.

### Q: How often should access token expire?

**A:** 15 minutes to 1 hour. Balance between security and UX.

### Q: What if refresh token is stolen?

**A:** Store in database and check on each refresh. Can revoke if compromised.

---

## Related Topics

- [JWT Authentication Workflow](./01.%20JWT%20Authentication%20Workflow.md) - Access token details
- [Password Security](./06.%20Password%20Security.md) - Secure login
- [Security Best Practices](./08.%20Security%20Best%20Practices.md) - Token security

---

## Summary

**Refresh Token Pattern:**

- Access token (short-lived) - For API requests
- Refresh token (long-lived) - For getting new access tokens
- Stored in HttpOnly cookie (secure)
- Stored in database (for revocation)

**Benefits:**

- ✅ Better security (short access token)
- ✅ Better UX (automatic refresh)
- ✅ Can revoke refresh tokens
- ✅ Limits damage if token stolen

**Key Takeaway:** Use two-token system (access + refresh) for production applications. Access token expires quickly, refresh token gets new access token automatically.
