# Password Security

Understanding password security - hashing, salting, bcrypt, and best practices for storing passwords securely.

---

## Core Concept

**Never store passwords in plain text.** Always hash passwords before storing them in the database.

**Password Security Principles:**

- ✅ **Hash** passwords (one-way encryption)
- ✅ **Salt** passwords (add random data)
- ✅ **Use strong algorithms** (bcrypt, argon2)
- ❌ **Never** store plain text passwords
- ❌ **Never** use weak hashing (MD5, SHA1)

---

## Why Hash Passwords?

### Problem: Plain Text Storage

**If database is compromised:**

```
Database contains:
email: user@example.com
password: mypassword123  ❌ Plain text!

Attacker can:
- See all passwords
- Use passwords on other sites
- Impersonate users
```

---

### Solution: Hash Passwords

**Hashed passwords:**

```
Database contains:
email: user@example.com
password: $2b$10$N9qo8uLOickgx2ZMRZoMyeIjZAgcfl7p92ldGxad68LJZdL17lhWy  ✅ Hashed

Attacker sees:
- Unreadable hash
- Cannot reverse to get password
- Must brute force (very slow)
```

---

## Password Hashing

### What is Hashing?

**Hashing** is one-way encryption. You can convert password → hash, but cannot convert hash → password.

**Example:**

```
Password: "mypassword123"
Hash: "$2b$10$N9qo8uLOickgx2ZMRZoMyeIjZAgcfl7p92ldGxAgcfl7p92ldGx"
```

**Properties:**

- ✅ One-way (cannot reverse)
- ✅ Deterministic (same password = same hash)
- ✅ Fast to compute
- ✅ Fixed length output

---

### Hashing Algorithms

**Good Algorithms:**

- ✅ **bcrypt** - Most common, designed for passwords
- ✅ **argon2** - Modern, more secure
- ✅ **scrypt** - Good alternative

**Bad Algorithms (Never Use):**

- ❌ **MD5** - Too fast, easily cracked
- ❌ **SHA1** - Too fast, vulnerable
- ❌ **SHA256** - Too fast for passwords

**Why bcrypt?**

- ✅ Slow by design (prevents brute force)
- ✅ Built-in salting
- ✅ Adjustable cost factor
- ✅ Battle-tested

---

## Password Salting

### What is Salting?

**Salt** is random data added to password before hashing. Each password gets unique salt.

**Without Salt:**

```
Password: "password123"
Hash: "abc123..." (same for all users with same password)
```

**With Salt:**

```
User 1:
Password: "password123"
Salt: "random1"
Hash: "xyz789..." (unique)

User 2:
Password: "password123"
Salt: "random2"
Hash: "def456..." (different!)
```

**Benefits:**

- ✅ Same password → Different hashes
- ✅ Prevents rainbow table attacks
- ✅ Makes brute force harder

---

## bcrypt Explained

### How bcrypt Works

**bcrypt automatically:**

1. Generates random salt
2. Adds salt to password
3. Hashes password + salt
4. Stores salt + hash together

**bcrypt Hash Format:**

```
$2b$10$N9qo8uLOickgx2ZMRZoMyeIjZAgcfl7p92ldGxad68LJZdL17lhWy
│  │  │  │                                    │
│  │  │  │                                    └─ Hash
│  │  │  └─ Salt (22 characters)
│  │  └─ Cost factor (10 = 2^10 iterations)
│  └─ Algorithm version (2b)
└─ Algorithm identifier ($2b$)
```

---

### Cost Factor

**Cost factor** determines how slow hashing is (security vs performance).

```
Cost 10 = 2^10 = 1,024 iterations
Cost 12 = 2^12 = 4,096 iterations (more secure, slower)
Cost 14 = 2^14 = 16,384 iterations (very secure, very slow)
```

**Recommendation:** Cost 10-12 (balance security and performance)

---

## Implementation

### Backend: Hashing Password on Signup

```javascript
const bcrypt = require("bcrypt");

app.post("/api/signup", async (req, res) => {
  const { email, password } = req.body;

  // Hash password with bcrypt
  const saltRounds = 10;
  const hashedPassword = await bcrypt.hash(password, saltRounds);

  // Store hashed password
  const user = await User.create({
    email,
    password: hashedPassword, // Store hash, not plain text!
  });

  res.json({ message: "User created", userId: user.id });
});
```

---

### Backend: Verifying Password on Login

```javascript
app.post("/api/login", async (req, res) => {
  const { email, password } = req.body;

  // Find user
  const user = await User.findOne({ email });
  if (!user) {
    return res.status(401).json({ error: "Invalid credentials" });
  }

  // Compare password with hash
  const isValid = await bcrypt.compare(password, user.password);

  if (!isValid) {
    return res.status(401).json({ error: "Invalid credentials" });
  }

  // Password correct - create token
  const token = jwt.sign({ userId: user.id }, process.env.JWT_SECRET);
  res.json({ token });
});
```

---

## Password Strength Validation

### Client-Side Validation

```javascript
function validatePassword(password) {
  const minLength = 8;
  const hasUpperCase = /[A-Z]/.test(password);
  const hasLowerCase = /[a-z]/.test(password);
  const hasNumber = /[0-9]/.test(password);
  const hasSpecialChar = /[!@#$%^&*]/.test(password);

  if (password.length < minLength) {
    return { valid: false, error: "Password must be at least 8 characters" };
  }

  if (!hasUpperCase) {
    return { valid: false, error: "Password must contain uppercase letter" };
  }

  if (!hasLowerCase) {
    return { valid: false, error: "Password must contain lowercase letter" };
  }

  if (!hasNumber) {
    return { valid: false, error: "Password must contain number" };
  }

  if (!hasSpecialChar) {
    return { valid: false, error: "Password must contain special character" };
  }

  return { valid: true };
}
```

---

### Server-Side Validation

```javascript
app.post("/api/signup", async (req, res) => {
  const { email, password } = req.body;

  // Validate password strength
  if (password.length < 8) {
    return res.status(400).json({ error: "Password too short" });
  }

  if (!/[A-Z]/.test(password)) {
    return res.status(400).json({ error: "Password must contain uppercase" });
  }

  // ... more validation

  // Hash and store
  const hashedPassword = await bcrypt.hash(password, 10);
  // ...
});
```

---

## Complete Example

### Signup Flow

```javascript
// Frontend
async function signup(email, password) {
  // Validate password strength
  const validation = validatePassword(password);
  if (!validation.valid) {
    alert(validation.error);
    return;
  }

  const res = await fetch("/api/signup", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ email, password }),
  });

  if (res.ok) {
    console.log("Account created");
  }
}

// Backend
app.post("/api/signup", async (req, res) => {
  const { email, password } = req.body;

  // Validate
  if (password.length < 8) {
    return res.status(400).json({ error: "Password too short" });
  }

  // Check if user exists
  const existingUser = await User.findOne({ email });
  if (existingUser) {
    return res.status(400).json({ error: "User already exists" });
  }

  // Hash password
  const hashedPassword = await bcrypt.hash(password, 10);

  // Create user
  const user = await User.create({
    email,
    password: hashedPassword,
  });

  res.json({ message: "User created", userId: user.id });
});
```

---

## Security Best Practices

### 1. Never Log Passwords

```javascript
// ❌ Bad
console.log("Password:", password);

// ✅ Good
console.log("User signed up:", email);
```

---

### 2. Use Strong Cost Factor

```javascript
// ✅ Good - Cost 10-12
const hashedPassword = await bcrypt.hash(password, 10);

// ❌ Bad - Too low
const hashedPassword = await bcrypt.hash(password, 4);
```

---

### 3. Validate on Both Sides

```javascript
// ✅ Frontend validation (UX)
if (password.length < 8) {
  showError("Password too short");
}

// ✅ Backend validation (Security)
if (password.length < 8) {
  return res.status(400).json({ error: "Password too short" });
}
```

---

### 4. Use HTTPS

```javascript
// ✅ Always use HTTPS in production
// Passwords sent over HTTP can be intercepted
```

---

### 5. Rate Limit Login Attempts

```javascript
// Prevent brute force attacks
const rateLimit = require("express-rate-limit");

const loginLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5, // 5 attempts per window
});

app.post("/api/login", loginLimiter, async (req, res) => {
  // ...
});
```

---

## Common Questions

### Q: Can I decrypt a hashed password?

**A:** No. Hashing is one-way. You cannot reverse a hash to get the password. You can only compare passwords.

### Q: What if two users have the same password?

**A:** bcrypt uses unique salt for each password, so hashes will be different.

### Q: How do I verify a password?

**A:** Use `bcrypt.compare(password, hash)`. It extracts salt from hash, hashes password with salt, and compares.

### Q: What cost factor should I use?

**A:** Cost 10-12. Higher is more secure but slower. Test on your server to find balance.

### Q: Should I hash passwords on frontend?

**A:** No. Hash on backend. Frontend hashing doesn't add security (attacker can see hash anyway).

---

## Related Topics

- [JWT Authentication Workflow](./01.%20JWT%20Authentication%20Workflow.md) - Using hashed passwords in login
- [Refresh Tokens](./05.%20Refresh%20Tokens.md) - Secure token system
- [Security Best Practices](./08.%20Security%20Best%20Practices.md) - Overall security

---

## Summary

**Password Security:**

- ✅ Always hash passwords (never plain text)
- ✅ Use bcrypt (or argon2)
- ✅ bcrypt automatically salts passwords
- ✅ Use cost factor 10-12
- ✅ Validate password strength
- ✅ Rate limit login attempts

**Key Points:**

- Hashing is one-way (cannot reverse)
- Salt makes each hash unique
- bcrypt is slow by design (prevents brute force)
- Always validate on backend (frontend is just UX)

**Key Takeaway:** Never store plain text passwords. Always hash with bcrypt. bcrypt handles salting automatically. Use cost factor 10-12 for balance between security and performance.
