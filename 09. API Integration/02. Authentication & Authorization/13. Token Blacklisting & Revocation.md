# Token Blacklisting & Revocation

Understanding token blacklisting and revocation - how to invalidate JWT tokens, implement logout, and handle token revocation for security.

---

## Core Concept

**Token Blacklisting** is a mechanism to invalidate JWT tokens before they expire, allowing you to "logout" users or revoke access.

**Problem with Stateless JWT:**

- JWT tokens are valid until expiration
- Server doesn't store tokens (stateless)
- Cannot "delete" token from server
- Token works even after "logout"

**Solution:**

- Maintain a blacklist of revoked tokens
- Check blacklist on each request
- Reject blacklisted tokens

---

## Why Token Revocation?

### Use Cases

1. **User Logout**

   - User clicks logout
   - Token should be invalidated immediately
   - Prevents token reuse

2. **Password Change**

   - User changes password
   - All existing tokens should be revoked
   - Force re-login

3. **Security Breach**

   - Token suspected to be stolen
   - Revoke all user tokens
   - Force re-authentication

4. **Account Suspension**

   - Admin suspends user account
   - Revoke all tokens immediately
   - Prevent access

5. **Token Rotation**
   - Refresh token rotation
   - Revoke old refresh tokens
   - Security best practice

---

## Token Blacklisting Approaches

### Approach 1: Redis Blacklist (Recommended)

**How it works:**

- Store revoked token IDs in Redis
- Check Redis on each request
- Fast lookups (in-memory)

**Pros:**

- ✅ Fast (in-memory)
- ✅ Scalable
- ✅ Automatic expiration (TTL)
- ✅ Distributed (multiple servers)

**Cons:**

- ⚠️ Requires Redis
- ⚠️ Additional infrastructure

---

### Approach 2: Database Blacklist

**How it works:**

- Store revoked tokens in database
- Check database on each request

**Pros:**

- ✅ No additional infrastructure
- ✅ Persistent storage
- ✅ Works with existing database

**Cons:**

- ❌ Slower than Redis
- ❌ Database load increases
- ❌ Need cleanup for expired tokens

---

### Approach 3: Token Versioning

**How it works:**

- Store token version in user record
- Include version in JWT payload
- Check version on each request

**Pros:**

- ✅ No blacklist storage needed
- ✅ Efficient (one check per user)
- ✅ Works with stateless JWT

**Cons:**

- ⚠️ Requires database lookup
- ⚠️ Revokes all user tokens (not selective)

---

## Redis Blacklist Implementation

### Step 1: Include Token ID in JWT

```javascript
const uuid = require("uuid");

// Login - include token ID (jti) in JWT
app.post("/api/login", async (req, res) => {
  const { email, password } = req.body;

  // Verify credentials
  const user = await User.findOne({ email });
  if (!user || !(await bcrypt.compare(password, user.password))) {
    return res.status(401).json({ error: "Invalid credentials" });
  }

  // Generate unique token ID
  const tokenId = uuid.v4();

  // Create JWT with token ID
  const token = jwt.sign(
    {
      userId: user.id,
      email: user.email,
      jti: tokenId, // JWT ID (unique identifier)
    },
    process.env.JWT_SECRET,
    { expiresIn: "24h" }
  );

  res.json({ token, tokenId });
});
```

---

### Step 2: Store Token ID in Redis on Logout

```javascript
const redis = require("redis");
const client = redis.createClient();

// Logout - blacklist token
app.post("/api/logout", authenticateToken, async (req, res) => {
  const tokenId = req.user.jti; // Token ID from JWT
  const tokenExpiration = req.user.exp; // Expiration time from JWT

  // Calculate TTL (time until token expires)
  const now = Math.floor(Date.now() / 1000);
  const ttl = tokenExpiration - now;

  if (ttl > 0) {
    // Store token ID in Redis with TTL
    await client.setEx(`blacklist:${tokenId}`, ttl, "revoked");
  }

  res.json({ message: "Logged out successfully" });
});
```

---

### Step 3: Check Blacklist on Each Request

```javascript
// Middleware to check blacklist
async function authenticateToken(req, res, next) {
  const authHeader = req.headers["authorization"];
  const token = authHeader && authHeader.split(" ")[1];

  if (!token) {
    return res.status(401).json({ error: "No token provided" });
  }

  try {
    // Verify token
    const decoded = jwt.verify(token, process.env.JWT_SECRET);

    // Check if token is blacklisted
    const tokenId = decoded.jti;
    const isBlacklisted = await client.get(`blacklist:${tokenId}`);

    if (isBlacklisted) {
      return res.status(401).json({ error: "Token has been revoked" });
    }

    req.user = decoded;
    next();
  } catch (error) {
    if (error.name === "TokenExpiredError") {
      return res.status(401).json({ error: "Token expired" });
    }
    return res.status(403).json({ error: "Invalid token" });
  }
}
```

---

## Database Blacklist Implementation

### Step 1: Create Blacklist Table

```sql
CREATE TABLE revoked_tokens (
  id SERIAL PRIMARY KEY,
  token_id VARCHAR(255) UNIQUE NOT NULL,
  user_id INTEGER NOT NULL,
  expires_at TIMESTAMP NOT NULL,
  revoked_at TIMESTAMP DEFAULT NOW(),
  reason VARCHAR(255)
);

CREATE INDEX idx_revoked_tokens_token_id ON revoked_tokens(token_id);
CREATE INDEX idx_revoked_tokens_expires_at ON revoked_tokens(expires_at);
```

---

### Step 2: Store Revoked Token

```javascript
// Logout - store in database
app.post("/api/logout", authenticateToken, async (req, res) => {
  const tokenId = req.user.jti;
  const userId = req.user.userId;
  const expiresAt = new Date(req.user.exp * 1000);

  // Store in database
  await RevokedToken.create({
    tokenId,
    userId,
    expiresAt,
    reason: "user_logout",
  });

  res.json({ message: "Logged out successfully" });
});
```

---

### Step 3: Check Blacklist

```javascript
async function authenticateToken(req, res, next) {
  const token = req.headers["authorization"]?.split(" ")[1];

  if (!token) {
    return res.status(401).json({ error: "No token provided" });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);

    // Check if token is blacklisted
    const revokedToken = await RevokedToken.findOne({
      tokenId: decoded.jti,
    });

    if (revokedToken) {
      return res.status(401).json({ error: "Token has been revoked" });
    }

    req.user = decoded;
    next();
  } catch (error) {
    return res.status(403).json({ error: "Invalid token" });
  }
}
```

---

### Step 4: Cleanup Expired Tokens

```javascript
// Scheduled job to clean up expired tokens
const cron = require("node-cron");

// Run daily at 2 AM
cron.schedule("0 2 * * *", async () => {
  await RevokedToken.deleteMany({
    expiresAt: { $lt: new Date() },
  });
  console.log("Cleaned up expired revoked tokens");
});
```

---

## Token Versioning Implementation

### Step 1: Add Token Version to User

```javascript
// User schema
const userSchema = new Schema({
  email: String,
  password: String,
  tokenVersion: { type: Number, default: 0 }, // Token version
});

// Increment version on password change or logout
app.post("/api/logout", authenticateToken, async (req, res) => {
  const userId = req.user.userId;

  // Increment token version (invalidates all tokens)
  await User.findByIdAndUpdate(userId, {
    $inc: { tokenVersion: 1 },
  });

  res.json({ message: "Logged out successfully" });
});
```

---

### Step 2: Include Version in JWT

```javascript
// Login - include token version
app.post("/api/login", async (req, res) => {
  // ... verify credentials ...

  const token = jwt.sign(
    {
      userId: user.id,
      email: user.email,
      tokenVersion: user.tokenVersion, // Include version
    },
    process.env.JWT_SECRET,
    { expiresIn: "24h" }
  );

  res.json({ token });
});
```

---

### Step 3: Verify Version on Each Request

```javascript
async function authenticateToken(req, res, next) {
  const token = req.headers["authorization"]?.split(" ")[1];

  if (!token) {
    return res.status(401).json({ error: "No token provided" });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);

    // Get current token version from database
    const user = await User.findById(decoded.userId);
    if (!user) {
      return res.status(401).json({ error: "User not found" });
    }

    // Check if token version matches
    if (decoded.tokenVersion !== user.tokenVersion) {
      return res.status(401).json({ error: "Token has been revoked" });
    }

    req.user = decoded;
    next();
  } catch (error) {
    return res.status(403).json({ error: "Invalid token" });
  }
}
```

---

## Revoke All User Tokens

### Password Change - Revoke All Tokens

```javascript
app.post("/api/change-password", authenticateToken, async (req, res) => {
  const { currentPassword, newPassword } = req.body;
  const userId = req.user.userId;

  const user = await User.findById(userId);

  // Verify current password
  const isValid = await bcrypt.compare(currentPassword, user.password);
  if (!isValid) {
    return res.status(401).json({ error: "Current password incorrect" });
  }

  // Hash new password
  const hashedPassword = await bcrypt.hash(newPassword, 10);

  // Update password and increment token version
  await User.findByIdAndUpdate(userId, {
    password: hashedPassword,
    $inc: { tokenVersion: 1 }, // Revoke all tokens
  });

  res.json({ message: "Password changed. Please login again." });
});
```

---

### Security Breach - Revoke All Tokens

```javascript
app.post("/api/revoke-all-tokens", authenticateToken, async (req, res) => {
  const userId = req.user.userId;

  // Increment token version (revokes all tokens)
  await User.findByIdAndUpdate(userId, {
    $inc: { tokenVersion: 1 },
  });

  res.json({
    message: "All tokens revoked. Please login again.",
  });
});
```

---

## Frontend Logout Implementation

### React Logout

```javascript
async function logout() {
  try {
    // Call logout endpoint (blacklists token)
    await fetch("/api/logout", {
      method: "POST",
      headers: {
        Authorization: `Bearer ${localStorage.getItem("token")}`,
      },
    });

    // Remove token from storage
    localStorage.removeItem("token");
    localStorage.removeItem("refreshToken");

    // Redirect to login
    window.location.href = "/login";
  } catch (error) {
    console.error("Logout error:", error);
    // Still remove token and redirect
    localStorage.removeItem("token");
    window.location.href = "/login";
  }
}
```

---

## Complete Logout Flow

### With Refresh Tokens

```javascript
app.post("/api/logout", authenticateToken, async (req, res) => {
  const tokenId = req.user.jti;
  const refreshToken = req.cookies.refreshToken;

  // Blacklist access token
  if (tokenId) {
    const ttl = req.user.exp - Math.floor(Date.now() / 1000);
    if (ttl > 0) {
      await client.setEx(`blacklist:${tokenId}`, ttl, "revoked");
    }
  }

  // Revoke refresh token (if stored in database)
  if (refreshToken) {
    await RefreshToken.deleteOne({ token: refreshToken });
  }

  // Clear refresh token cookie
  res.clearCookie("refreshToken", {
    httpOnly: true,
    secure: true,
    sameSite: "strict",
  });

  res.json({ message: "Logged out successfully" });
});
```

---

## Performance Considerations

### Redis Blacklist (Best Performance)

```javascript
// ✅ Fast - O(1) lookup
const isBlacklisted = await client.get(`blacklist:${tokenId}`);
```

### Database Blacklist (Slower)

```javascript
// ⚠️ Slower - Database query
const revokedToken = await RevokedToken.findOne({ tokenId });
```

### Token Versioning (Balanced)

```javascript
// ✅ Balanced - One user lookup per request
const user = await User.findById(decoded.userId);
if (decoded.tokenVersion !== user.tokenVersion) {
  // Revoked
}
```

---

## Comparison of Approaches

| Approach               | Performance | Scalability  | Complexity | Selective Revocation |
| ---------------------- | ----------- | ------------ | ---------- | -------------------- |
| **Redis Blacklist**    | ✅ Fastest  | ✅ Excellent | ⚠️ Medium  | ✅ Yes (per token)   |
| **Database Blacklist** | ⚠️ Slower   | ⚠️ Good      | ✅ Simple  | ✅ Yes (per token)   |
| **Token Versioning**   | ✅ Fast     | ✅ Excellent | ✅ Simple  | ❌ No (all tokens)   |

**Recommendation:**

- **Production:** Redis blacklist (best performance)
- **Small apps:** Database blacklist (simpler)
- **Simple needs:** Token versioning (no blacklist storage)

---

## Security Best Practices

### 1. Always Blacklist on Logout

```javascript
// ✅ Good - Blacklist token
app.post("/api/logout", authenticateToken, async (req, res) => {
  await blacklistToken(req.user.jti, req.user.exp);
  res.json({ message: "Logged out" });
});
```

---

### 2. Revoke on Password Change

```javascript
// ✅ Good - Revoke all tokens on password change
await User.findByIdAndUpdate(userId, {
  password: hashedPassword,
  $inc: { tokenVersion: 1 },
});
```

---

### 3. Set Appropriate TTL

```javascript
// ✅ Good - Set TTL to token expiration
const ttl = tokenExpiration - currentTime;
await client.setEx(`blacklist:${tokenId}`, ttl, "revoked");
```

---

### 4. Clean Up Expired Tokens

```javascript
// ✅ Good - Clean up expired blacklist entries
cron.schedule("0 2 * * *", async () => {
  // Redis: Automatic (TTL)
  // Database: Manual cleanup
  await RevokedToken.deleteMany({
    expiresAt: { $lt: new Date() },
  });
});
```

---

## Common Questions

### Q: Does blacklisting make JWT stateful?

**A:** Partially. You store blacklist, but not user session data. It's a compromise for security.

### Q: What if Redis is down?

**A:** Have fallback to database blacklist, or allow tokens (less secure but app works).

### Q: How do I handle token revocation in microservices?

**A:** Use shared Redis or database for blacklist accessible by all services.

### Q: Should I blacklist refresh tokens too?

**A:** Yes, store refresh tokens in database and delete on logout.

### Q: What's the performance impact?

**A:** Redis: Negligible (<1ms). Database: Small (5-10ms per request). Token versioning: One user lookup.

---

## Related Topics

- [JWT Authentication Workflow](./01.%20JWT%20Authentication%20Workflow.md) - JWT token creation
- [Refresh Tokens](./05.%20Refresh%20Tokens.md) - Revoking refresh tokens
- [Security Best Practices](./08.%20Security%20Best%20Practices.md) - Token security

---

## Summary

**Token Blacklisting Approaches:**

- **Redis Blacklist** - Fast, scalable, per-token revocation
- **Database Blacklist** - Simple, persistent, per-token revocation
- **Token Versioning** - Efficient, no blacklist storage, revokes all tokens

**Revocation Use Cases:**

- User logout
- Password change
- Security breach
- Account suspension
- Token rotation

**Best Practices:**

- Always blacklist on logout
- Revoke all tokens on password change
- Set TTL to token expiration
- Clean up expired blacklist entries
- Use Redis for best performance

**Key Takeaway:** JWT tokens are stateless, but you can make them revocable by maintaining a blacklist. Redis blacklist is fastest, database blacklist is simpler, token versioning revokes all tokens at once.
