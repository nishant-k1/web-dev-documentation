# Email Verification

Understanding email verification - verifying user email addresses, sending verification links, and implementing complete email verification flow.

---

## Core Concept

**Email Verification** confirms that users own the email address they registered with, preventing fake accounts and ensuring valid communication.

**Key Requirements:**

- ✅ Verification token generation
- ✅ Email sending with verification link
- ✅ Token validation
- ✅ Resend verification email
- ✅ Account status tracking

---

## Why Email Verification?

### Benefits

**Security:**

- ✅ Prevents fake accounts
- ✅ Ensures valid email addresses
- ✅ Reduces spam registrations
- ✅ Enables password reset (verified email)

**User Experience:**

- ✅ Confirms email delivery
- ✅ Builds trust
- ✅ Enables email notifications

**Business:**

- ✅ Valid user database
- ✅ Better email deliverability
- ✅ Compliance requirements

---

## Complete Email Verification Flow

### Flow Diagram

```
1. User signs up
   ↓
2. Backend creates user account (unverified)
   ↓
3. Backend generates verification token
   ↓
4. Backend sends verification email
   ↓
5. User clicks link in email
   ↓
6. Frontend extracts token from URL
   ↓
7. Frontend sends token to backend
   ↓
8. Backend validates token
   ↓
9. Backend marks email as verified
   ↓
10. User can now use full account features
```

---

## Step-by-Step Implementation

### Step 1: Signup with Email Verification

**Backend:**

```javascript
const crypto = require("crypto");
const nodemailer = require("nodemailer");

const transporter = nodemailer.createTransport({
  service: "gmail",
  auth: {
    user: process.env.EMAIL_USER,
    pass: process.env.EMAIL_PASSWORD,
  },
});

app.post("/api/signup", async (req, res) => {
  const { email, password, name } = req.body;

  // Validate input
  if (!email || !password) {
    return res.status(400).json({ error: "Email and password required" });
  }

  // Check if user exists
  const existingUser = await User.findOne({ email });
  if (existingUser) {
    return res.status(400).json({ error: "User already exists" });
  }

  // Hash password
  const hashedPassword = await bcrypt.hash(password, 10);

  // Generate verification token
  const verificationToken = crypto.randomBytes(32).toString("hex");
  const hashedToken = crypto
    .createHash("sha256")
    .update(verificationToken)
    .digest("hex");

  // Set expiration (24 hours)
  const verificationTokenExpires = new Date(Date.now() + 24 * 60 * 60 * 1000);

  // Create user (unverified)
  const user = await User.create({
    email,
    password: hashedPassword,
    name,
    emailVerified: false,
    verificationToken: hashedToken,
    verificationTokenExpires: verificationTokenExpires,
  });

  // Create verification URL
  const verificationUrl = `${process.env.FRONTEND_URL}/verify-email?token=${verificationToken}&id=${user.id}`;

  // Send verification email
  try {
    await transporter.sendMail({
      from: process.env.EMAIL_USER,
      to: user.email,
      subject: "Verify Your Email Address",
      html: `
        <h2>Welcome to Our App!</h2>
        <p>Please verify your email address by clicking the link below:</p>
        <a href="${verificationUrl}">Verify Email</a>
        <p>This link will expire in 24 hours.</p>
        <p>If you didn't create an account, please ignore this email.</p>
      `,
    });

    res.json({
      message:
        "Account created. Please check your email to verify your account.",
      userId: user.id,
    });
  } catch (error) {
    console.error("Email error:", error);
    // Still create user, but mark as email send failed
    res.status(201).json({
      message:
        "Account created, but verification email failed to send. Please contact support.",
      userId: user.id,
    });
  }
});
```

---

### Step 2: Verify Email Endpoint

**Backend:**

```javascript
app.post("/api/verify-email", async (req, res) => {
  const { token, userId } = req.body;

  if (!token || !userId) {
    return res.status(400).json({ error: "Token and user ID required" });
  }

  // Hash provided token
  const hashedToken = crypto.createHash("sha256").update(token).digest("hex");

  // Find user with matching token
  const user = await User.findOne({
    _id: userId,
    verificationToken: hashedToken,
    verificationTokenExpires: { $gt: new Date() },
    emailVerified: false,
  });

  if (!user) {
    return res.status(400).json({
      error: "Invalid, expired, or already used verification token",
    });
  }

  // Mark email as verified
  await User.findByIdAndUpdate(user.id, {
    emailVerified: true,
    verificationToken: null,
    verificationTokenExpires: null,
    emailVerifiedAt: new Date(),
  });

  res.json({ message: "Email verified successfully" });
});
```

---

### Step 3: Frontend Verification Page

**React:**

```javascript
import { useEffect, useState } from "react";
import { useSearchParams, useNavigate } from "react-router-dom";

function VerifyEmail() {
  const [searchParams] = useSearchParams();
  const navigate = useNavigate();
  const [status, setStatus] = useState("verifying");

  const token = searchParams.get("token");
  const userId = searchParams.get("id");

  useEffect(() => {
    if (token && userId) {
      verifyEmail();
    } else {
      setStatus("error");
    }
  }, [token, userId]);

  const verifyEmail = async () => {
    try {
      const res = await fetch("/api/verify-email", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ token, userId }),
      });

      const data = await res.json();

      if (res.ok) {
        setStatus("success");
        setTimeout(() => {
          navigate("/login");
        }, 3000);
      } else {
        setStatus("error");
      }
    } catch (error) {
      setStatus("error");
    }
  };

  if (status === "verifying") {
    return <div>Verifying your email...</div>;
  }

  if (status === "success") {
    return (
      <div>
        <h2>Email Verified Successfully!</h2>
        <p>Your email has been verified. Redirecting to login...</p>
      </div>
    );
  }

  return (
    <div>
      <h2>Verification Failed</h2>
      <p>The verification link is invalid or has expired.</p>
      <button onClick={() => navigate("/resend-verification")}>
        Resend Verification Email
      </button>
    </div>
  );
}
```

---

## Resend Verification Email

### Backend Endpoint

```javascript
const resendLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 3, // 3 requests per window
  message: "Too many resend requests",
});

app.post("/api/resend-verification", resendLimiter, async (req, res) => {
  const { email } = req.body;

  const user = await User.findOne({ email });

  // Don't reveal if email exists
  if (!user) {
    return res.json({
      message:
        "If email exists and is unverified, verification email has been sent",
    });
  }

  // Check if already verified
  if (user.emailVerified) {
    return res.json({
      message: "Email is already verified",
    });
  }

  // Generate new verification token
  const verificationToken = crypto.randomBytes(32).toString("hex");
  const hashedToken = crypto
    .createHash("sha256")
    .update(verificationToken)
    .digest("hex");

  const verificationTokenExpires = new Date(Date.now() + 24 * 60 * 60 * 1000);

  // Update user with new token
  await User.findByIdAndUpdate(user.id, {
    verificationToken: hashedToken,
    verificationTokenExpires: verificationTokenExpires,
  });

  // Send verification email
  const verificationUrl = `${process.env.FRONTEND_URL}/verify-email?token=${verificationToken}&id=${user.id}`;

  try {
    await transporter.sendMail({
      from: process.env.EMAIL_USER,
      to: user.email,
      subject: "Verify Your Email Address",
      html: `
        <h2>Verify Your Email</h2>
        <p>Click the link below to verify your email:</p>
        <a href="${verificationUrl}">Verify Email</a>
        <p>This link will expire in 24 hours.</p>
      `,
    });

    res.json({
      message:
        "If email exists and is unverified, verification email has been sent",
    });
  } catch (error) {
    res.status(500).json({ error: "Failed to send email" });
  }
});
```

---

### Frontend Resend Form

```javascript
function ResendVerification() {
  const [email, setEmail] = useState("");
  const [message, setMessage] = useState("");

  const handleSubmit = async (e) => {
    e.preventDefault();

    const res = await fetch("/api/resend-verification", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ email }),
    });

    const data = await res.json();
    setMessage(data.message || data.error);
  };

  return (
    <form onSubmit={handleSubmit}>
      <h2>Resend Verification Email</h2>
      <input
        type="email"
        placeholder="Enter your email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
        required
      />
      <button type="submit">Resend Verification Email</button>
      {message && <p>{message}</p>}
    </form>
  );
}
```

---

## Protect Routes Based on Email Verification

### Backend Middleware

```javascript
function requireVerifiedEmail(req, res, next) {
  if (!req.user) {
    return res.status(401).json({ error: "Not authenticated" });
  }

  // Check if email is verified
  User.findById(req.user.userId)
    .then((user) => {
      if (!user || !user.emailVerified) {
        return res.status(403).json({
          error: "Email not verified",
          code: "EMAIL_NOT_VERIFIED",
        });
      }
      next();
    })
    .catch((error) => {
      res.status(500).json({ error: "Server error" });
    });
}

// Use middleware
app.get(
  "/api/protected-route",
  authenticateToken,
  requireVerifiedEmail,
  (req, res) => {
    res.json({ data: "Protected data" });
  }
);
```

---

### Frontend Check

```javascript
function useEmailVerification() {
  const [isVerified, setIsVerified] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const token = localStorage.getItem("token");
    if (!token) {
      setLoading(false);
      return;
    }

    fetch("/api/user/profile", {
      headers: {
        Authorization: `Bearer ${token}`,
      },
    })
      .then((res) => res.json())
      .then((data) => {
        setIsVerified(data.emailVerified);
        setLoading(false);
      })
      .catch(() => {
        setLoading(false);
      });
  }, []);

  return { isVerified, loading };
}

function ProtectedFeature() {
  const { isVerified, loading } = useEmailVerification();

  if (loading) return <div>Loading...</div>;

  if (!isVerified) {
    return (
      <div>
        <h2>Please Verify Your Email</h2>
        <p>You need to verify your email to access this feature.</p>
        <a href="/resend-verification">Resend Verification Email</a>
      </div>
    );
  }

  return <div>Protected content</div>;
}
```

---

## Database Schema

```javascript
const userSchema = new Schema({
  email: { type: String, required: true, unique: true },
  password: { type: String, required: true },
  emailVerified: { type: Boolean, default: false },
  verificationToken: String,
  verificationTokenExpires: Date,
  emailVerifiedAt: Date,
});
```

---

## Security Best Practices

### 1. Hash Verification Tokens

```javascript
// ✅ Good - Hash token before storing
const hashedToken = crypto
  .createHash("sha256")
  .update(verificationToken)
  .digest("hex");
```

---

### 2. Set Expiration Times

```javascript
// ✅ Good - 24 hours expiration
const verificationTokenExpires = new Date(Date.now() + 24 * 60 * 60 * 1000);
```

---

### 3. Single-Use Tokens

```javascript
// ✅ Good - Clear token after verification
await User.findByIdAndUpdate(user.id, {
  emailVerified: true,
  verificationToken: null,
  verificationTokenExpires: null,
});
```

---

### 4. Rate Limit Resend Requests

```javascript
const resendLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 3,
});

app.post("/api/resend-verification", resendLimiter, handler);
```

---

### 5. Don't Reveal Email Existence

```javascript
// ✅ Good - Generic message
if (!user) {
  return res.json({
    message: "If email exists and is unverified, email has been sent",
  });
}
```

---

## Common Questions

### Q: How long should verification tokens be valid?

**A:** 24-48 hours. Balance between security and user convenience.

### Q: Should I require email verification for login?

**A:** Optional for basic features, required for sensitive actions (password reset, payments).

### Q: What if user never verifies email?

**A:** Send reminder emails, or delete unverified accounts after 7-30 days.

### Q: Can I use same token for password reset and email verification?

**A:** No. Use separate tokens for different purposes.

### Q: Should I verify email on every login?

**A:** No. Verify once, then check `emailVerified` flag on each request.

---

## Related Topics

- [Password Reset Flow](./14.%20Password%20Reset%20Flow.md) - Similar token flow
- [Token Blacklisting & Revocation](./13.%20Token%20Blacklisting%20%26%20Revocation.md) - Token management
- [Password Security](./06.%20Password%20Security.md) - Secure signup

---

## Summary

**Email Verification Flow:**

1. User signs up
2. Backend generates verification token
3. Backend sends email with verification link
4. User clicks link
5. Backend validates token
6. Backend marks email as verified
7. User can access full features

**Security Best Practices:**

- ✅ Hash verification tokens
- ✅ Set expiration (24-48 hours)
- ✅ Make tokens single-use
- ✅ Rate limit resend requests
- ✅ Don't reveal email existence
- ✅ Clear tokens after verification

**Key Takeaway:** Email verification confirms user ownership of email address. Generate secure tokens, send verification emails, validate tokens, and mark emails as verified. Use separate tokens for different purposes (verification vs password reset).
