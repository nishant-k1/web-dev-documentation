# OAuth 2.0 & Social Login

Understanding OAuth 2.0, social login implementation, and how to integrate "Login with Google/GitHub/Microsoft" in frontend applications.

---

## Core Concept

**OAuth 2.0** is an authorization framework that allows third-party applications to access user resources without sharing passwords.

**Social Login** uses OAuth 2.0 to let users log in with their existing accounts (Google, GitHub, Microsoft, etc.).

**Key Characteristics:**

- ✅ **Delegated Authorization** - User grants permission to app
- ✅ **No Password Sharing** - User never shares password with app
- ✅ **Token-Based** - Uses access tokens
- ✅ **Industry Standard** - Used by Google, GitHub, Microsoft, Facebook

---

## OAuth 2.0 vs JWT vs Session

### Comparison

| Aspect          | OAuth 2.0                           | JWT            | Session        |
| --------------- | ----------------------------------- | -------------- | -------------- |
| **Purpose**     | Authorization (third-party access)  | Authentication | Authentication |
| **Use Case**    | "Login with Google"                 | Custom login   | Custom login   |
| **Token Type**  | Access token + Refresh token        | JWT token      | Session ID     |
| **Who Issues**  | Authorization server (Google, etc.) | Your server    | Your server    |
| **When to Use** | Social login, API access            | Custom auth    | Custom auth    |

### Key Difference

**OAuth 2.0:**

- Used for **third-party authorization** (accessing user's Google/GitHub data)
- User grants permission to your app
- Authorization server (Google) issues tokens

**JWT/Session:**

- Used for **your own authentication** (your app's login)
- Your server verifies credentials
- Your server issues tokens/sessions

---

## OAuth 2.0 Flow (Authorization Code Flow)

### Complete Flow

```
1. User clicks "Login with Google"
   ↓
2. Frontend redirects to Google's authorization server
   ↓
3. User logs in with Google credentials
   ↓
4. User grants permission to your app
   ↓
5. Google redirects back with authorization code
   ↓
6. Frontend sends authorization code to your backend
   ↓
7. Backend exchanges code for access token (with Google)
   ↓
8. Backend gets user info from Google
   ↓
9. Backend creates user account (if new) or logs in existing user
   ↓
10. Backend issues your own JWT token
   ↓
11. Frontend receives JWT and stores it
```

---

## Step-by-Step Implementation

### Step 1: Register Your App with OAuth Provider

**Google OAuth Setup:**

1. Go to [Google Cloud Console](https://console.cloud.google.com/)
2. Create a new project
3. Enable Google+ API
4. Create OAuth 2.0 credentials
5. Add authorized redirect URIs:
   ```
   http://localhost:3000/auth/google/callback (development)
   https://yourdomain.com/auth/google/callback (production)
   ```
6. Get Client ID and Client Secret

**GitHub OAuth Setup:**

1. Go to GitHub Settings → Developer settings → OAuth Apps
2. Create new OAuth App
3. Set Authorization callback URL:
   ```
   http://localhost:3000/auth/github/callback
   ```
4. Get Client ID and Client Secret

---

### Step 2: Frontend - Initiate OAuth Flow

**React Example:**

```javascript
// Login button component
function GoogleLoginButton() {
  const handleGoogleLogin = () => {
    // Redirect to Google's authorization server
    const clientId = process.env.REACT_APP_GOOGLE_CLIENT_ID;
    const redirectUri = encodeURIComponent(
      `${window.location.origin}/auth/google/callback`
    );
    const scope = encodeURIComponent("openid email profile");
    const responseType = "code";
    const state = generateRandomState(); // CSRF protection

    const googleAuthUrl =
      `https://accounts.google.com/o/oauth2/v2/auth?` +
      `client_id=${clientId}&` +
      `redirect_uri=${redirectUri}&` +
      `response_type=${responseType}&` +
      `scope=${scope}&` +
      `state=${state}`;

    // Store state in sessionStorage for verification
    sessionStorage.setItem("oauth_state", state);

    // Redirect to Google
    window.location.href = googleAuthUrl;
  };

  return <button onClick={handleGoogleLogin}>Login with Google</button>;
}

function generateRandomState() {
  return (
    Math.random().toString(36).substring(2, 15) +
    Math.random().toString(36).substring(2, 15)
  );
}
```

---

### Step 3: Backend - Handle OAuth Callback

**Express.js Example:**

```javascript
const express = require("express");
const axios = require("axios");
const jwt = require("jsonwebtoken");

app.get("/auth/google/callback", async (req, res) => {
  const { code, state } = req.query;

  // Verify state (CSRF protection)
  const storedState = req.session.oauth_state;
  if (state !== storedState) {
    return res.status(403).json({ error: "Invalid state" });
  }

  try {
    // Exchange authorization code for access token
    const tokenResponse = await axios.post(
      "https://oauth2.googleapis.com/token",
      {
        code,
        client_id: process.env.GOOGLE_CLIENT_ID,
        client_secret: process.env.GOOGLE_CLIENT_SECRET,
        redirect_uri: process.env.GOOGLE_REDIRECT_URI,
        grant_type: "authorization_code",
      }
    );

    const { access_token } = tokenResponse.data;

    // Get user info from Google
    const userResponse = await axios.get(
      "https://www.googleapis.com/oauth2/v2/userinfo",
      {
        headers: {
          Authorization: `Bearer ${access_token}`,
        },
      }
    );

    const { email, name, picture, id: googleId } = userResponse.data;

    // Find or create user in your database
    let user = await User.findOne({ email });

    if (!user) {
      // Create new user
      user = await User.create({
        email,
        name,
        picture,
        googleId,
        provider: "google",
      });
    } else {
      // Update existing user
      user.googleId = googleId;
      user.picture = picture;
      await user.save();
    }

    // Create your own JWT token
    const token = jwt.sign(
      { userId: user.id, email: user.email },
      process.env.JWT_SECRET,
      { expiresIn: "24h" }
    );

    // Redirect to frontend with token
    res.redirect(`${process.env.FRONTEND_URL}/auth/callback?token=${token}`);
  } catch (error) {
    console.error("OAuth error:", error);
    res.redirect(`${process.env.FRONTEND_URL}/login?error=oauth_failed`);
  }
});
```

---

### Step 4: Frontend - Handle OAuth Callback

**React Router Example:**

```javascript
import { useEffect } from "react";
import { useNavigate, useSearchParams } from "react-router-dom";

function OAuthCallback() {
  const [searchParams] = useSearchParams();
  const navigate = useNavigate();

  useEffect(() => {
    const token = searchParams.get("token");
    const error = searchParams.get("error");

    if (error) {
      // OAuth failed
      navigate("/login?error=oauth_failed");
      return;
    }

    if (token) {
      // Store token
      localStorage.setItem("token", token);

      // Redirect to dashboard
      navigate("/dashboard");
    }
  }, [searchParams, navigate]);

  return <div>Processing login...</div>;
}

// Route
<Route path="/auth/callback" element={<OAuthCallback />} />;
```

---

## Complete React + Next.js Example

### Using NextAuth.js (Recommended)

**Install:**

```bash
npm install next-auth
```

**Setup:**

```javascript
// pages/api/auth/[...nextauth].js
import NextAuth from "next-auth";
import GoogleProvider from "next-auth/providers/google";

export default NextAuth({
  providers: [
    GoogleProvider({
      clientId: process.env.GOOGLE_CLIENT_ID,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET,
    }),
  ],
  callbacks: {
    async jwt({ token, account, profile }) {
      if (account) {
        token.accessToken = account.access_token;
        token.idToken = account.id_token;
      }
      return token;
    },
    async session({ session, token }) {
      session.accessToken = token.accessToken;
      return session;
    },
  },
});
```

**Usage:**

```javascript
import { signIn, signOut, useSession } from "next-auth/react";

function LoginButton() {
  const { data: session } = useSession();

  if (session) {
    return (
      <>
        <p>Signed in as {session.user.email}</p>
        <button onClick={() => signOut()}>Sign out</button>
      </>
    );
  }

  return <button onClick={() => signIn("google")}>Sign in with Google</button>;
}
```

---

## GitHub OAuth Example

### Frontend

```javascript
function GitHubLoginButton() {
  const handleGitHubLogin = () => {
    const clientId = process.env.REACT_APP_GITHUB_CLIENT_ID;
    const redirectUri = encodeURIComponent(
      `${window.location.origin}/auth/github/callback`
    );
    const scope = "user:email";
    const state = generateRandomState();

    sessionStorage.setItem("oauth_state", state);

    const githubAuthUrl =
      `https://github.com/login/oauth/authorize?` +
      `client_id=${clientId}&` +
      `redirect_uri=${redirectUri}&` +
      `scope=${scope}&` +
      `state=${state}`;

    window.location.href = githubAuthUrl;
  };

  return <button onClick={handleGitHubLogin}>Login with GitHub</button>;
}
```

### Backend

```javascript
app.get("/auth/github/callback", async (req, res) => {
  const { code, state } = req.query;

  // Verify state
  if (state !== req.session.oauth_state) {
    return res.status(403).json({ error: "Invalid state" });
  }

  try {
    // Exchange code for access token
    const tokenResponse = await axios.post(
      "https://github.com/login/oauth/access_token",
      {
        code,
        client_id: process.env.GITHUB_CLIENT_ID,
        client_secret: process.env.GITHUB_CLIENT_SECRET,
      },
      {
        headers: {
          Accept: "application/json",
        },
      }
    );

    const { access_token } = tokenResponse.data;

    // Get user info from GitHub
    const userResponse = await axios.get("https://api.github.com/user", {
      headers: {
        Authorization: `Bearer ${access_token}`,
      },
    });

    const { email, name, avatar_url, id: githubId } = userResponse.data;

    // Find or create user
    let user = await User.findOne({ email });
    if (!user) {
      user = await User.create({
        email,
        name,
        picture: avatar_url,
        githubId,
        provider: "github",
      });
    }

    // Create JWT
    const token = jwt.sign({ userId: user.id }, process.env.JWT_SECRET, {
      expiresIn: "24h",
    });

    res.redirect(`${process.env.FRONTEND_URL}/auth/callback?token=${token}`);
  } catch (error) {
    res.redirect(`${process.env.FRONTEND_URL}/login?error=oauth_failed`);
  }
});
```

---

## OAuth 2.0 Grant Types

### 1. Authorization Code Flow (Most Common)

**Used for:** Web applications, mobile apps

**Flow:**

1. User authorizes → Gets authorization code
2. App exchanges code → Gets access token
3. App uses access token → Accesses user resources

**Security:** Most secure, code is short-lived

---

### 2. Implicit Flow (Deprecated)

**Used for:** Single-page apps (legacy)

**Note:** Deprecated, use Authorization Code Flow with PKCE instead

---

### 3. Client Credentials Flow

**Used for:** Machine-to-machine communication

**Example:**

```javascript
// Server-to-server, no user involved
const tokenResponse = await axios.post("https://oauth2.googleapis.com/token", {
  grant_type: "client_credentials",
  client_id: process.env.CLIENT_ID,
  client_secret: process.env.CLIENT_SECRET,
  scope: "https://www.googleapis.com/auth/cloud-platform",
});
```

---

### 4. Resource Owner Password Credentials (Not Recommended)

**Used for:** Trusted applications only

**Note:** Not recommended, security risk

---

## OAuth Scopes

### What are Scopes?

**Scopes** define what permissions your app requests from the user.

**Google Scopes:**

- `openid` - Basic profile
- `email` - User's email
- `profile` - User's profile info
- `https://www.googleapis.com/auth/calendar` - Calendar access

**GitHub Scopes:**

- `user:email` - User's email
- `read:user` - Read user profile
- `repo` - Repository access

**Example:**

```javascript
const scope = "openid email profile";
```

---

## Security Best Practices

### 1. Use State Parameter (CSRF Protection)

```javascript
// Generate random state
const state = generateRandomState();
sessionStorage.setItem("oauth_state", state);

// Include in OAuth URL
const authUrl = `...&state=${state}`;

// Verify on callback
if (req.query.state !== req.session.oauth_state) {
  return res.status(403).json({ error: "Invalid state" });
}
```

---

### 2. Store Client Secret on Backend Only

```javascript
// ❌ Bad - Never expose client secret
const clientSecret = "your-secret"; // In frontend code

// ✅ Good - Store in backend environment variable
const clientSecret = process.env.GOOGLE_CLIENT_SECRET; // Backend only
```

---

### 3. Use HTTPS in Production

```javascript
// ✅ Always use HTTPS for OAuth callbacks
const redirectUri = "https://yourdomain.com/auth/callback";
```

---

### 4. Validate Tokens

```javascript
// ✅ Always verify access token with provider
const userInfo = await axios.get(
  "https://www.googleapis.com/oauth2/v2/userinfo",
  {
    headers: {
      Authorization: `Bearer ${access_token}`,
    },
  }
);
```

---

## OAuth vs JWT

### When to Use OAuth 2.0

✅ **Use OAuth when:**

- Implementing social login (Google, GitHub, etc.)
- Accessing third-party APIs (Google Calendar, GitHub repos)
- Building apps that need user's external data
- Delegating authorization to third party

### When to Use JWT

✅ **Use JWT when:**

- Building your own authentication system
- No need for third-party authorization
- Simple stateless authentication
- Custom user management

### Can You Use Both?

**Yes!** Common pattern:

1. User logs in with OAuth (Google)
2. Your backend creates/updates user account
3. Your backend issues your own JWT token
4. Frontend uses your JWT for subsequent requests

---

## Common Questions

### Q: What's the difference between OAuth and JWT?

**A:**

- **OAuth 2.0** - Authorization framework (how to get permission)
- **JWT** - Token format (how to represent authentication)

OAuth can use JWT tokens, but they serve different purposes.

### Q: Do I need OAuth for social login?

**A:** Yes. OAuth 2.0 is the standard way to implement "Login with Google/GitHub."

### Q: Can I use OAuth without a backend?

**A:** Not securely. Client secret must be on backend. Use Authorization Code Flow with backend.

### Q: What happens if user revokes access?

**A:** Access token becomes invalid. User must re-authorize.

### Q: How do I handle multiple OAuth providers?

**A:** Implement each provider separately, then unify user accounts by email.

---

## Related Topics

- [JWT Authentication Workflow](./01.%20JWT%20Authentication%20Workflow.md) - Your own JWT after OAuth
- [Session-Based Authentication](./02.%20Session-Based%20Authentication.md) - Alternative to JWT
- [Security Best Practices](./08.%20Security%20Best%20Practices.md) - OAuth security

---

## Summary

**OAuth 2.0:**

- ✅ Authorization framework for third-party access
- ✅ Used for social login (Google, GitHub, Microsoft)
- ✅ User grants permission, no password sharing
- ✅ Authorization server issues tokens

**Social Login Flow:**

1. User clicks "Login with Google"
2. Redirects to Google authorization
3. User grants permission
4. Google redirects with code
5. Backend exchanges code for token
6. Backend gets user info
7. Backend creates/updates user
8. Backend issues your JWT
9. Frontend stores JWT

**Key Points:**

- OAuth is for third-party authorization
- JWT is for your own authentication
- Can use both together (OAuth for login, JWT for your app)
- Always use state parameter for CSRF protection
- Store client secret on backend only

**Key Takeaway:** OAuth 2.0 enables social login. User grants permission to your app, authorization server issues tokens, your backend creates user account and issues your own JWT token for your app.
