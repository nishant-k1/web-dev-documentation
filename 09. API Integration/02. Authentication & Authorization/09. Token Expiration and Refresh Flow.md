# Token Expiration and Refresh Flow

Understanding token expiration, handling expired tokens, automatic refresh, and complete token lifecycle management.

---

## Core Concept

**Token Expiration** is a security feature. Tokens expire after a set time, requiring refresh or re-authentication.

**Token Lifecycle:**

1. Token issued (login)
2. Token used (API requests)
3. Token expires
4. Token refreshed (get new token)
5. Token revoked (logout)

---

## Token Expiration

### Why Tokens Expire?

**Security Benefits:**

- ✅ Limits damage if token stolen
- ✅ Forces periodic re-authentication
- ✅ Reduces attack window
- ✅ Allows revocation

**Expiration Times:**

- **Access Token:** 15 minutes - 1 hour (short)
- **Refresh Token:** 7-30 days (long)

---

### Setting Expiration

**JWT Expiration:**

```javascript
// Access token - 15 minutes
const accessToken = jwt.sign({ userId: user.id }, process.env.JWT_SECRET, {
  expiresIn: "15m",
});

// Refresh token - 7 days
const refreshToken = jwt.sign(
  { userId: user.id },
  process.env.REFRESH_TOKEN_SECRET,
  { expiresIn: "7d" }
);
```

---

## Detecting Expired Tokens

### Backend: Token Expiration Check

```javascript
function authenticateToken(req, res, next) {
  const token = req.headers["authorization"]?.split(" ")[1];

  if (!token) {
    return res.status(401).json({ error: "No token provided" });
  }

  jwt.verify(token, process.env.JWT_SECRET, (err, decoded) => {
    if (err) {
      if (err.name === "TokenExpiredError") {
        return res.status(401).json({
          error: "Token expired",
          code: "TOKEN_EXPIRED",
        });
      }
      return res.status(403).json({ error: "Invalid token" });
    }

    req.user = decoded;
    next();
  });
}
```

---

### Frontend: Handling Expired Tokens

**Detect 401 Response:**

```javascript
axios.interceptors.response.use(
  (response) => response,
  async (error) => {
    if (error.response?.status === 401) {
      const errorCode = error.response.data?.code;

      if (errorCode === "TOKEN_EXPIRED") {
        // Token expired - refresh it
        return await refreshAccessToken(error);
      }

      // Other 401 - redirect to login
      window.location.href = "/login";
    }

    return Promise.reject(error);
  }
);
```

---

## Automatic Token Refresh

### Frontend: Auto-Refresh Pattern

**Complete Implementation:**

```javascript
let isRefreshing = false;
let failedQueue = [];

const processQueue = (error, token = null) => {
  failedQueue.forEach((prom) => {
    if (error) {
      prom.reject(error);
    } else {
      prom.resolve(token);
    }
  });

  failedQueue = [];
};

axios.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config;

    // If 401 and not already retrying
    if (error.response?.status === 401 && !originalRequest._retry) {
      if (isRefreshing) {
        // Already refreshing - queue request
        return new Promise((resolve, reject) => {
          failedQueue.push({ resolve, reject });
        })
          .then((token) => {
            originalRequest.headers.Authorization = `Bearer ${token}`;
            return axios(originalRequest);
          })
          .catch((err) => Promise.reject(err));
      }

      originalRequest._retry = true;
      isRefreshing = true;

      try {
        // Refresh access token
        const response = await axios.post(
          "/api/refresh",
          {},
          {
            withCredentials: true,
          }
        );

        const { accessToken } = response.data;
        localStorage.setItem("accessToken", accessToken);

        // Process queued requests
        processQueue(null, accessToken);

        // Retry original request
        originalRequest.headers.Authorization = `Bearer ${accessToken}`;
        return axios(originalRequest);
      } catch (refreshError) {
        // Refresh failed - process queue with error
        processQueue(refreshError, null);

        // Clear tokens and redirect
        localStorage.removeItem("accessToken");
        window.location.href = "/login";
        return Promise.reject(refreshError);
      } finally {
        isRefreshing = false;
      }
    }

    return Promise.reject(error);
  }
);
```

---

## Token Refresh Endpoint

### Backend: Refresh Token Handler

```javascript
app.post("/api/refresh", async (req, res) => {
  const refreshToken = req.cookies.refreshToken;

  if (!refreshToken) {
    return res.status(401).json({ error: "No refresh token" });
  }

  try {
    // Verify refresh token
    const decoded = jwt.verify(refreshToken, process.env.REFRESH_TOKEN_SECRET);

    // Check if refresh token exists in database
    const storedToken = await RefreshToken.findOne({
      userId: decoded.userId,
      token: refreshToken,
    });

    if (!storedToken) {
      return res.status(401).json({ error: "Invalid refresh token" });
    }

    // Check if expired
    if (storedToken.expiresAt < new Date()) {
      await RefreshToken.deleteOne({ token: refreshToken });
      return res.status(401).json({ error: "Refresh token expired" });
    }

    // Get user
    const user = await User.findById(decoded.userId);
    if (!user) {
      return res.status(401).json({ error: "User not found" });
    }

    // Generate new access token
    const accessToken = jwt.sign(
      { userId: user.id, role: user.role },
      process.env.JWT_SECRET,
      { expiresIn: "15m" }
    );

    res.json({ accessToken });
  } catch (error) {
    if (error.name === "TokenExpiredError") {
      return res.status(401).json({ error: "Refresh token expired" });
    }
    return res.status(401).json({ error: "Invalid refresh token" });
  }
});
```

---

## Proactive Token Refresh

### Refresh Before Expiration

**Check token expiration before requests:**

```javascript
function isTokenExpired(token) {
  try {
    const decoded = jwt.decode(token);
    if (!decoded || !decoded.exp) {
      return true;
    }

    const expirationTime = decoded.exp * 1000; // Convert to milliseconds
    const currentTime = Date.now();
    const bufferTime = 5 * 60 * 1000; // 5 minutes buffer

    return expirationTime - currentTime < bufferTime;
  } catch (error) {
    return true;
  }
}

// Check before request
async function makeRequest(url) {
  let token = localStorage.getItem("accessToken");

  // Refresh if expired or expiring soon
  if (!token || isTokenExpired(token)) {
    token = await refreshAccessToken();
  }

  return fetch(url, {
    headers: {
      Authorization: `Bearer ${token}`,
    },
  });
}
```

---

## React Hook: Token Management

### Custom Hook

```javascript
import { useState, useEffect, useCallback } from "react";

function useToken() {
  const [accessToken, setAccessToken] = useState(null);
  const [loading, setLoading] = useState(true);

  const refreshToken = useCallback(async () => {
    try {
      const response = await fetch("/api/refresh", {
        method: "POST",
        credentials: "include",
      });

      if (!response.ok) {
        throw new Error("Refresh failed");
      }

      const { accessToken: newToken } = await response.json();
      setAccessToken(newToken);
      localStorage.setItem("accessToken", newToken);
      return newToken;
    } catch (error) {
      setAccessToken(null);
      localStorage.removeItem("accessToken");
      window.location.href = "/login";
      throw error;
    }
  }, []);

  useEffect(() => {
    // Load token on mount
    const token = localStorage.getItem("accessToken");

    if (token && !isTokenExpired(token)) {
      setAccessToken(token);
    } else if (token) {
      // Token expired - refresh
      refreshToken();
    }

    setLoading(false);
  }, [refreshToken]);

  const getToken = useCallback(async () => {
    if (!accessToken || isTokenExpired(accessToken)) {
      return await refreshToken();
    }
    return accessToken;
  }, [accessToken, refreshToken]);

  return { accessToken, refreshToken, getToken, loading };
}
```

---

## Error Handling

### Handle Refresh Failures

**Scenario 1: Refresh Token Expired**

```javascript
if (
  error.response?.status === 401 &&
  error.response.data?.error === "Refresh token expired"
) {
  // Refresh token expired - must login again
  localStorage.removeItem("accessToken");
  window.location.href = "/login?expired=true";
}
```

**Scenario 2: Refresh Token Invalid**

```javascript
if (
  error.response?.status === 401 &&
  error.response.data?.error === "Invalid refresh token"
) {
  // Refresh token invalid - logout
  localStorage.removeItem("accessToken");
  await fetch("/api/logout", { credentials: "include" });
  window.location.href = "/login";
}
```

---

## Token Lifecycle Management

### Complete Flow

```
1. User Logs In
   ↓
2. Server Issues:
   - Access Token (15m expiry)
   - Refresh Token (7d expiry)
   ↓
3. Client Stores:
   - Access Token (memory/localStorage)
   - Refresh Token (HttpOnly cookie)
   ↓
4. Client Makes API Request
   ↓
5. Token Valid?
   ├─ Yes → Request succeeds
   └─ No → 401 Error
   ↓
6. Client Detects 401
   ↓
7. Client Calls /api/refresh
   ↓
8. Server Validates Refresh Token
   ├─ Valid → New Access Token
   └─ Invalid → 401 Error
   ↓
9. Client Updates Access Token
   ↓
10. Client Retries Original Request
```

---

## Best Practices

### 1. Short Access Token Expiration

```javascript
// ✅ Good - 15 minutes
{
  expiresIn: "15m";
}

// ❌ Bad - 30 days
{
  expiresIn: "30d";
}
```

### 2. Automatic Refresh

```javascript
// ✅ Good - Auto-refresh on 401
axios.interceptors.response.use(handleRefresh);

// ❌ Bad - Manual refresh
if (error.status === 401) {
  // User must manually refresh
}
```

### 3. Queue Concurrent Requests

```javascript
// ✅ Good - Queue requests during refresh
if (isRefreshing) {
  queueRequest(originalRequest);
}

// ❌ Bad - Multiple refresh calls
// All requests try to refresh simultaneously
```

### 4. Handle Refresh Failures

```javascript
// ✅ Good - Redirect on refresh failure
catch (error) {
  redirectToLogin();
}

// ❌ Bad - Silent failure
catch (error) {
  // User stuck, no feedback
}
```

---

## Common Questions

### Q: What happens if refresh token expires?

**A:** User must log in again. Refresh token expiration is longer (7-30 days) to avoid frequent logins.

### Q: Should I refresh token proactively?

**A:** Yes, refresh before expiration (e.g., 5 minutes before) to avoid failed requests.

### Q: What if multiple requests fail simultaneously?

**A:** Queue requests during refresh. Only one refresh call, then retry all queued requests.

### Q: How do I handle token refresh in React?

**A:** Use axios interceptors or a custom hook that manages token lifecycle.

---

## Related Topics

- [Refresh Tokens](./05.%20Refresh%20Tokens.md) - Refresh token pattern
- [JWT Authentication Workflow](./01.%20JWT%20Authentication%20Workflow.md) - Token creation
- [Security Best Practices](./08.%20Security%20Best%20Practices.md) - Token security
- [Error Handling](../01.%20HTTP/07.%20Error%20Handling.md) - Error handling patterns

---

## Summary

**Token Expiration:**

- Access tokens expire quickly (15m-1h)
- Refresh tokens expire slowly (7-30d)
- Expiration limits damage if token stolen

**Refresh Flow:**

- Detect 401 errors
- Call refresh endpoint
- Update access token
- Retry original request
- Queue concurrent requests

**Best Practices:**

- Short access token expiration
- Automatic refresh on 401
- Queue requests during refresh
- Handle refresh failures
- Proactive refresh before expiration

**Key Takeaway:** Tokens expire for security. Implement automatic refresh flow that detects expired tokens, refreshes them, and retries requests. Queue concurrent requests to avoid multiple refresh calls.
