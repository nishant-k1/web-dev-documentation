# Response Handling

Understanding how to handle different HTTP response types - JSON, text, blobs, and streaming.

---

## Core Concept

HTTP responses can contain different data types. Understanding how to parse and handle each type is essential for frontend development.

**Response Types:**

- JSON - Structured data
- Text - Plain text
- Blob - Binary data (images, files)
- ArrayBuffer - Raw binary data
- FormData - Form data
- Stream - Streaming data

---

## Response Object Methods

### Available Methods

| Method              | Returns                | Use For                                  |
| ------------------- | ---------------------- | ---------------------------------------- |
| **`json()`**        | Promise\<Object\>      | JSON data                                |
| **`text()`**        | Promise\<String\>      | Plain text, HTML, XML                    |
| **`blob()`**        | Promise\<Blob\>        | Images, files, binary data               |
| **`arrayBuffer()`** | Promise\<ArrayBuffer\> | Raw binary data                          |
| **`formData()`**    | Promise\<FormData\>    | Form data                                |
| **`clone()`**       | Response               | Clone response (can only read body once) |

**Important:** You can only read the response body **once**. After calling one method, you cannot call another.

---

## JSON Responses

### Parsing JSON

**Most common response type for APIs.**

```javascript
fetch("/api/users")
  .then((res) => res.json()) // Parse JSON
  .then((data) => {
    console.log(data); // JavaScript object
  });
```

**With Error Handling:**

```javascript
fetch("/api/users")
  .then((res) => {
    if (!res.ok) {
      throw new Error(`HTTP error! status: ${res.status}`);
    }
    return res.json();
  })
  .then((data) => {
    console.log(data);
  })
  .catch((error) => {
    console.error("Error:", error);
  });
```

**Async/Await:**

```javascript
async function getUsers() {
  try {
    const res = await fetch("/api/users");
    if (!res.ok) {
      throw new Error(`HTTP error! status: ${res.status}`);
    }
    const data = await res.json();
    return data;
  } catch (error) {
    console.error("Error:", error);
  }
}
```

---

## Text Responses

### Parsing Text

**Use for HTML, XML, plain text, CSV.**

```javascript
fetch("/api/data.txt")
  .then((res) => res.text())
  .then((text) => {
    console.log(text); // String
  });
```

**Example Use Cases:**

```javascript
// HTML content
fetch("/api/page.html")
  .then((res) => res.text())
  .then((html) => {
    document.getElementById("content").innerHTML = html;
  });

// CSV data
fetch("/api/data.csv")
  .then((res) => res.text())
  .then((csv) => {
    const rows = csv.split("\n");
    // Process CSV
  });

// XML data
fetch("/api/data.xml")
  .then((res) => res.text())
  .then((xml) => {
    const parser = new DOMParser();
    const doc = parser.parseFromString(xml, "text/xml");
    // Process XML
  });
```

---

## Blob Responses

### Parsing Blobs

**Use for images, PDFs, videos, any binary file.**

```javascript
fetch("/api/image.jpg")
  .then((res) => res.blob())
  .then((blob) => {
    // Create object URL
    const url = URL.createObjectURL(blob);
    // Use in img tag
    document.getElementById("image").src = url;
  });
```

**Download File:**

```javascript
async function downloadFile(url, filename) {
  const res = await fetch(url);
  const blob = await res.blob();

  // Create download link
  const downloadUrl = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = downloadUrl;
  a.download = filename;
  a.click();

  // Clean up
  URL.revokeObjectURL(downloadUrl);
}

// Usage
downloadFile("/api/report.pdf", "report.pdf");
```

**Display Image:**

```javascript
fetch("/api/avatar.jpg")
  .then((res) => res.blob())
  .then((blob) => {
    const imageUrl = URL.createObjectURL(blob);
    const img = document.createElement("img");
    img.src = imageUrl;
    document.body.appendChild(img);
  });
```

---

## ArrayBuffer Responses

### Parsing ArrayBuffer

**Use for raw binary data manipulation.**

```javascript
fetch("/api/binary-data")
  .then((res) => res.arrayBuffer())
  .then((buffer) => {
    // Process raw binary data
    const view = new Uint8Array(buffer);
    console.log(view);
  });
```

**Use Cases:**

- Audio processing
- Image manipulation
- Binary protocol parsing
- Crypto operations

---

## FormData Responses

### Parsing FormData

**Rare - usually for multipart responses.**

```javascript
fetch("/api/form-data")
  .then((res) => res.formData())
  .then((formData) => {
    // Iterate form data
    for (const [key, value] of formData.entries()) {
      console.log(key, value);
    }
  });
```

---

## Checking Response Type

### Content-Type Header

**Check Content-Type before parsing:**

```javascript
fetch("/api/data")
  .then((res) => {
    const contentType = res.headers.get("Content-Type");

    if (contentType.includes("application/json")) {
      return res.json();
    } else if (contentType.includes("text/")) {
      return res.text();
    } else if (contentType.includes("image/")) {
      return res.blob();
    } else {
      return res.text(); // Default
    }
  })
  .then((data) => {
    console.log(data);
  });
```

---

## Response Status Checking

### Check Status Before Parsing

```javascript
fetch("/api/users")
  .then((res) => {
    if (!res.ok) {
      throw new Error(`HTTP error! status: ${res.status}`);
    }

    const contentType = res.headers.get("Content-Type");
    if (contentType && contentType.includes("application/json")) {
      return res.json();
    }
    return res.text();
  })
  .then((data) => {
    console.log(data);
  })
  .catch((error) => {
    console.error("Error:", error);
  });
```

---

## Cloning Responses

### Why Clone?

**Problem:** Response body can only be read once.

```javascript
// ❌ Error - Can't read twice
const res = await fetch("/api/users");
const json = await res.json();
const text = await res.text(); // Error!
```

**Solution:** Clone response

```javascript
// ✅ Clone before reading
const res = await fetch("/api/users");
const clone = res.clone();

const json = await res.json();
const text = await clone.text(); // Works!
```

**Use Case:** Logging response while also using it

```javascript
const res = await fetch("/api/users");
const clone = res.clone();

// Log original
clone.text().then((text) => console.log("Response:", text));

// Use parsed
const data = await res.json();
```

---

## Streaming Responses

### Handling Large Responses

**For large files, stream the response:**

```javascript
async function downloadLargeFile(url) {
  const res = await fetch(url);
  const reader = res.body.getReader();
  const chunks = [];

  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    chunks.push(value);
  }

  // Combine chunks
  const blob = new Blob(chunks);
  return blob;
}
```

---

## Error Handling Patterns

### Pattern 1: Try-Catch with Type Checking

```javascript
async function fetchData(url) {
  try {
    const res = await fetch(url);

    if (!res.ok) {
      throw new Error(`HTTP error! status: ${res.status}`);
    }

    const contentType = res.headers.get("Content-Type");
    let data;

    if (contentType?.includes("application/json")) {
      data = await res.json();
    } else if (contentType?.includes("text/")) {
      data = await res.text();
    } else {
      data = await res.blob();
    }

    return data;
  } catch (error) {
    console.error("Fetch error:", error);
    throw error;
  }
}
```

---

### Pattern 2: Response Helper

```javascript
async function handleResponse(response) {
  if (!response.ok) {
    const error = await response.text();
    throw new Error(`HTTP ${response.status}: ${error}`);
  }

  const contentType = response.headers.get("Content-Type");

  if (contentType?.includes("application/json")) {
    return await response.json();
  } else if (contentType?.includes("text/")) {
    return await response.text();
  } else {
    return await response.blob();
  }
}

// Usage
fetch("/api/users")
  .then(handleResponse)
  .then((data) => console.log(data))
  .catch((error) => console.error(error));
```

---

## Common Mistakes

### Mistake 1: Reading Body Twice

```javascript
// ❌ Error
const res = await fetch("/api/users");
const json = await res.json();
const text = await res.text(); // Error!

// ✅ Clone first
const res = await fetch("/api/users");
const json = await res.json();
const text = await res.clone().text();
```

---

### Mistake 2: Not Checking Content-Type

```javascript
// ❌ Assumes JSON
const res = await fetch("/api/data");
const data = await res.json(); // Error if not JSON!

// ✅ Check first
const res = await fetch("/api/data");
const contentType = res.headers.get("Content-Type");
if (contentType?.includes("application/json")) {
  const data = await res.json();
}
```

---

### Mistake 3: Not Handling Errors

```javascript
// ❌ No error handling
fetch("/api/users")
  .then((res) => res.json())
  .then((data) => console.log(data));

// ✅ Handle errors
fetch("/api/users")
  .then((res) => {
    if (!res.ok) {
      throw new Error(`HTTP error! status: ${res.status}`);
    }
    return res.json();
  })
  .then((data) => console.log(data))
  .catch((error) => console.error(error));
```

---

## Best Practices

### 1. Always Check Status

```javascript
const res = await fetch("/api/users");
if (!res.ok) {
  throw new Error(`HTTP error! status: ${res.status}`);
}
const data = await res.json();
```

### 2. Check Content-Type

```javascript
const contentType = res.headers.get("Content-Type");
if (contentType?.includes("application/json")) {
  return res.json();
}
```

### 3. Handle Errors

```javascript
try {
  const data = await fetchData("/api/users");
} catch (error) {
  console.error("Error:", error);
  // Show user-friendly message
}
```

### 4. Clean Up Blob URLs

```javascript
const blob = await res.blob();
const url = URL.createObjectURL(blob);
// Use URL...
URL.revokeObjectURL(url); // Clean up
```

---

## Common Questions

### Q: Can I read response body multiple times?

**A:** No. You can only read once. Use `clone()` if you need to read multiple times.

### Q: What's the difference between blob() and arrayBuffer()?

**A:**

- **blob()** - File-like object (use for files, images)
- **arrayBuffer()** - Raw binary data (use for manipulation)

### Q: When should I use text() vs json()?

**A:**

- **json()** - For JSON APIs (most common)
- **text()** - For HTML, XML, plain text, CSV

---

## Related Topics

- [HTTP Status Codes](./03.%20HTTP%20Status%20Codes.md) - Status code handling
- [Error Handling](./07.%20Error%20Handling.md) - Error handling patterns
- [HTTP Clients](./13.%20HTTP%20Clients.md) - Response handling with different clients
- [File Uploads and Downloads](./13.%20File%20Uploads%20and%20Downloads.md) - File handling
- [Blob URLs and Memory Management](../../19.%20Browser%20Internals/12.%20Blob%20URLs%20and%20Memory%20Management.md) - Blob handling

---

## Summary

**Response Methods:**

- **json()** - Parse JSON (most common)
- **text()** - Parse text, HTML, XML
- **blob()** - Parse binary files
- **arrayBuffer()** - Raw binary data

**Key Rules:**

- Can only read body once (use clone() for multiple reads)
- Always check status before parsing
- Check Content-Type to determine parsing method
- Handle errors appropriately

**Best Practices:**

- Check `res.ok` before parsing
- Check Content-Type header
- Handle errors with try-catch
- Clean up blob URLs
