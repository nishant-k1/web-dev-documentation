# File Uploads and Downloads

Understanding how to upload and download files using HTTP APIs - FormData, progress tracking, and blob handling.

---

## Core Concept

File uploads and downloads are common in web applications. Understanding how to handle files via HTTP APIs is essential for frontend development.

**Key Concepts:**

- **FormData** - For file uploads
- **Blob URLs** - For file downloads/previews
- **Progress tracking** - Monitor upload/download progress
- **File validation** - Check file type and size

---

## File Uploads

### Basic File Upload

**Using FormData:**

```javascript
const fileInput = document.getElementById("fileInput");
const file = fileInput.files[0];

const formData = new FormData();
formData.append("file", file);
formData.append("description", "My file");

fetch("/api/upload", {
  method: "POST",
  body: formData,
})
  .then((res) => res.json())
  .then((data) => {
    console.log("Upload successful:", data);
  })
  .catch((error) => {
    console.error("Upload failed:", error);
  });
```

**Note:** Don't set `Content-Type` header - browser sets it automatically with boundary for multipart/form-data.

---

### Multiple Files Upload

```javascript
const fileInput = document.getElementById("fileInput");
const files = fileInput.files;

const formData = new FormData();
Array.from(files).forEach((file, index) => {
  formData.append(`file${index}`, file);
  // Or use same name for array
  formData.append("files", file);
});

fetch("/api/upload", {
  method: "POST",
  body: formData,
})
  .then((res) => res.json())
  .then((data) => {
    console.log("Upload successful:", data);
  });
```

---

### Upload with Additional Data

```javascript
const formData = new FormData();
formData.append("file", file);
formData.append("userId", "123");
formData.append("category", "avatar");
formData.append(
  "metadata",
  JSON.stringify({
    uploadedAt: new Date().toISOString(),
    source: "web",
  })
);

fetch("/api/upload", {
  method: "POST",
  body: formData,
});
```

---

## Upload Progress Tracking

### Using XMLHttpRequest (Progress Support)

**fetch() doesn't support progress, use XMLHttpRequest:**

```javascript
function uploadWithProgress(file, onProgress) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    const formData = new FormData();
    formData.append("file", file);

    // Track upload progress
    xhr.upload.addEventListener("progress", (event) => {
      if (event.lengthComputable) {
        const percentComplete = (event.loaded / event.total) * 100;
        onProgress(percentComplete);
      }
    });

    // Handle completion
    xhr.addEventListener("load", () => {
      if (xhr.status === 200) {
        resolve(JSON.parse(xhr.responseText));
      } else {
        reject(new Error(`Upload failed: ${xhr.status}`));
      }
    });

    // Handle errors
    xhr.addEventListener("error", () => {
      reject(new Error("Upload failed"));
    });

    xhr.open("POST", "/api/upload");
    xhr.send(formData);
  });
}

// Usage
uploadWithProgress(file, (progress) => {
  console.log(`Upload progress: ${progress}%`);
  // Update progress bar
  document.getElementById("progressBar").style.width = `${progress}%`;
})
  .then((data) => {
    console.log("Upload complete:", data);
  })
  .catch((error) => {
    console.error("Upload failed:", error);
  });
```

---

### React Upload Component with Progress

```javascript
import { useState } from "react";

function FileUpload() {
  const [progress, setProgress] = useState(0);
  const [uploading, setUploading] = useState(false);

  const handleUpload = (file) => {
    setUploading(true);
    setProgress(0);

    const xhr = new XMLHttpRequest();
    const formData = new FormData();
    formData.append("file", file);

    xhr.upload.addEventListener("progress", (event) => {
      if (event.lengthComputable) {
        const percentComplete = (event.loaded / event.total) * 100;
        setProgress(percentComplete);
      }
    });

    xhr.addEventListener("load", () => {
      if (xhr.status === 200) {
        setUploading(false);
        console.log("Upload complete");
      }
    });

    xhr.addEventListener("error", () => {
      setUploading(false);
      console.error("Upload failed");
    });

    xhr.open("POST", "/api/upload");
    xhr.send(formData);
  };

  return (
    <div>
      <input
        type="file"
        onChange={(e) => handleUpload(e.target.files[0])}
        disabled={uploading}
      />
      {uploading && (
        <div>
          <progress value={progress} max="100" />
          <span>{progress}%</span>
        </div>
      )}
    </div>
  );
}
```

---

## File Validation

### Client-Side Validation

```javascript
function validateFile(file) {
  const maxSize = 5 * 1024 * 1024; // 5MB
  const allowedTypes = ["image/jpeg", "image/png", "image/gif"];

  // Check file size
  if (file.size > maxSize) {
    throw new Error("File size exceeds 5MB");
  }

  // Check file type
  if (!allowedTypes.includes(file.type)) {
    throw new Error("Invalid file type. Only JPEG, PNG, GIF allowed");
  }

  return true;
}

// Usage
const fileInput = document.getElementById("fileInput");
fileInput.addEventListener("change", (e) => {
  const file = e.target.files[0];

  try {
    validateFile(file);
    // Proceed with upload
    uploadFile(file);
  } catch (error) {
    alert(error.message);
    fileInput.value = ""; // Clear input
  }
});
```

---

### File Preview Before Upload

```javascript
function previewFile(file) {
  const reader = new FileReader();

  reader.onload = (e) => {
    const preview = document.getElementById("preview");
    if (file.type.startsWith("image/")) {
      preview.src = e.target.result;
      preview.style.display = "block";
    }
  };

  reader.readAsDataURL(file);
}

// Usage
fileInput.addEventListener("change", (e) => {
  const file = e.target.files[0];
  if (file) {
    previewFile(file);
  }
});
```

---

## File Downloads

### Download File from URL

**Method 1: Direct Download**

```javascript
function downloadFile(url, filename) {
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
}

// Usage
downloadFile("/api/files/report.pdf", "report.pdf");
```

---

### Method 2: Fetch and Download Blob

```javascript
async function downloadFile(url, filename) {
  try {
    const res = await fetch(url);
    if (!res.ok) {
      throw new Error(`HTTP error! status: ${res.status}`);
    }

    const blob = await res.blob();
    const downloadUrl = URL.createObjectURL(blob);

    const a = document.createElement("a");
    a.href = downloadUrl;
    a.download = filename;
    document.body.appendChild(a);
    a.click();

    // Clean up
    document.body.removeChild(a);
    URL.revokeObjectURL(downloadUrl);
  } catch (error) {
    console.error("Download failed:", error);
  }
}

// Usage
downloadFile("/api/files/report.pdf", "report.pdf");
```

---

### Download with Progress

```javascript
async function downloadWithProgress(url, filename, onProgress) {
  const res = await fetch(url);
  const contentLength = res.headers.get("Content-Length");
  const total = parseInt(contentLength, 10);

  const reader = res.body.getReader();
  const chunks = [];
  let receivedLength = 0;

  while (true) {
    const { done, value } = await reader.read();
    if (done) break;

    chunks.push(value);
    receivedLength += value.length;

    if (onProgress && total) {
      const percentComplete = (receivedLength / total) * 100;
      onProgress(percentComplete);
    }
  }

  const blob = new Blob(chunks);
  const downloadUrl = URL.createObjectURL(blob);

  const a = document.createElement("a");
  a.href = downloadUrl;
  a.download = filename;
  a.click();

  URL.revokeObjectURL(downloadUrl);
}

// Usage
downloadWithProgress("/api/files/large.pdf", "large.pdf", (progress) => {
  console.log(`Download progress: ${progress}%`);
});
```

---

## Advanced Patterns

### Pattern 1: Drag and Drop Upload

```javascript
const dropZone = document.getElementById("dropZone");

dropZone.addEventListener("dragover", (e) => {
  e.preventDefault();
  dropZone.classList.add("dragover");
});

dropZone.addEventListener("dragleave", () => {
  dropZone.classList.remove("dragover");
});

dropZone.addEventListener("drop", (e) => {
  e.preventDefault();
  dropZone.classList.remove("dragover");

  const files = e.dataTransfer.files;
  Array.from(files).forEach((file) => {
    uploadFile(file);
  });
});
```

---

### Pattern 2: Chunked Upload (Large Files)

```javascript
async function uploadChunked(file, chunkSize = 1024 * 1024) {
  const totalChunks = Math.ceil(file.size / chunkSize);
  const uploadId = await initiateUpload(file.name, file.size);

  for (let chunkIndex = 0; chunkIndex < totalChunks; chunkIndex++) {
    const start = chunkIndex * chunkSize;
    const end = Math.min(start + chunkSize, file.size);
    const chunk = file.slice(start, end);

    const formData = new FormData();
    formData.append("chunk", chunk);
    formData.append("chunkIndex", chunkIndex);
    formData.append("uploadId", uploadId);

    await fetch("/api/upload-chunk", {
      method: "POST",
      body: formData,
    });

    const progress = ((chunkIndex + 1) / totalChunks) * 100;
    console.log(`Upload progress: ${progress}%`);
  }

  await completeUpload(uploadId);
}

async function initiateUpload(filename, fileSize) {
  const res = await fetch("/api/upload-init", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ filename, fileSize }),
  });
  const { uploadId } = await res.json();
  return uploadId;
}

async function completeUpload(uploadId) {
  await fetch("/api/upload-complete", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ uploadId }),
  });
}
```

---

### Pattern 3: Image Upload with Preview

```javascript
function uploadImageWithPreview(file) {
  // Validate
  if (!file.type.startsWith("image/")) {
    throw new Error("File must be an image");
  }

  // Preview
  const reader = new FileReader();
  reader.onload = (e) => {
    const preview = document.getElementById("preview");
    preview.src = e.target.result;
  };
  reader.readAsDataURL(file);

  // Upload
  const formData = new FormData();
  formData.append("image", file);

  fetch("/api/upload-image", {
    method: "POST",
    body: formData,
  })
    .then((res) => res.json())
    .then((data) => {
      console.log("Image uploaded:", data.url);
    });
}
```

---

## Error Handling

### Upload Error Handling

```javascript
async function uploadFile(file) {
  try {
    // Validate
    validateFile(file);

    // Upload
    const formData = new FormData();
    formData.append("file", file);

    const res = await fetch("/api/upload", {
      method: "POST",
      body: formData,
    });

    if (!res.ok) {
      const error = await res.json();
      throw new Error(error.message || "Upload failed");
    }

    const data = await res.json();
    return data;
  } catch (error) {
    if (error.name === "AbortError") {
      console.log("Upload cancelled");
    } else {
      console.error("Upload error:", error);
      // Show user-friendly error message
    }
    throw error;
  }
}
```

---

## Best Practices

### 1. Validate Files Client-Side

```javascript
// ✅ Validate before upload
if (!validateFile(file)) {
  return;
}
uploadFile(file);
```

### 2. Show Progress

```javascript
// ✅ Show upload progress
xhr.upload.addEventListener("progress", (event) => {
  updateProgressBar(event.loaded / event.total);
});
```

### 3. Clean Up Blob URLs

```javascript
// ✅ Clean up after use
const blobUrl = URL.createObjectURL(blob);
// Use blobUrl...
URL.revokeObjectURL(blobUrl);
```

### 4. Handle Large Files

```javascript
// ✅ Use chunked upload for large files
if (file.size > 10 * 1024 * 1024) {
  uploadChunked(file);
} else {
  uploadFile(file);
}
```

---

## Common Questions

### Q: Why don't I set Content-Type for FormData?

**A:** Browser automatically sets `Content-Type: multipart/form-data` with boundary. Setting it manually breaks the upload.

### Q: Can I upload files with fetch()?

**A:** Yes, but fetch() doesn't support progress tracking. Use XMLHttpRequest for progress.

### Q: How do I cancel a file upload?

**A:** Use AbortController:

```javascript
const controller = new AbortController();
fetch("/api/upload", {
  method: "POST",
  body: formData,
  signal: controller.signal,
});
// Cancel
controller.abort();
```

### Q: What's the maximum file size I can upload?

**A:** Depends on server configuration. Common limits: 10MB-100MB. Check server limits and validate client-side.

---

## Related Topics

- [POST Request Content Types](../../19.%20Browser%20Internals/5.%20POST%20Request%20Content%20Types.md) - multipart/form-data details
- [HTTP Methods](./02.%20HTTP%20Methods.md) - POST method for uploads
- [Response Handling](./11.%20Response%20Handling.md) - Handling blob responses
- [Request Cancellation](./12.%20Request%20Cancellation%20and%20Timeouts.md) - Cancel uploads
- [Error Handling](./07.%20Error%20Handling.md) - Handling upload/download errors
- [Basic File Uploads](../../19.%20Browser%20Internals/3.%20Basic%20File%20Uploads.md) - File input basics
- [Blob URLs and Memory Management](../../19.%20Browser%20Internals/12.%20Blob%20URLs%20and%20Memory%20Management.md) - Blob handling
- [Large File Uploads](../../19.%20Browser%20Internals/13.%20Large%20File%20Uploads%20and%20Chunking.md) - Chunked uploads

---

## Summary

**File Uploads:**

- Use FormData for file uploads
- Don't set Content-Type header (browser sets it)
- Use XMLHttpRequest for progress tracking
- Validate files client-side

**File Downloads:**

- Fetch blob and create download URL
- Use URL.createObjectURL() for blob URLs
- Clean up with URL.revokeObjectURL()
- Track progress for large files

**Best Practices:**

- Validate file type and size
- Show upload/download progress
- Handle errors appropriately
- Clean up blob URLs
- Use chunked upload for large files

**Key Takeaway:** File uploads use FormData (multipart/form-data), and file downloads use Blob URLs. Always validate files and show progress for better UX.
