# Closures in React

**In React**

‚úîÔ∏è In useEffect(() => console.log(count))

The callback is created inside the component‚Äôs lexical environment,
so it closes over variables from that environment.

Execution Context of the component is destroyed.
Lexical environment is preserved inside the closure.

‚ùå In <Child count={count} />

Child component function is NOT created inside parent‚Äôs lexical environment.
React only calls it.

So no closure.

## Closures in React Component

1. In React component

   ```js
   function App() {
     const [count] = useState(0);

     function handleClick() {
       console.log(count); // refers to outer variable ‚Üí CLOSURE!
     }
     return <button onClick={handleClick}></button>;
   }
   ```

2. In React component inline function

   ```jsx
   function App() {
     const [count] = useState(0);
     setTimeout(() => console.log(count), 1000); // This ALSO creates closure

     // This ALSO creates closure
     window.addEventListener("scroll", () => {
       console.log(count);
     });

     // This ALSO creates closure
     useEffect(() => {
       console.log(count);
     }, []);

     // Even passing a function to any library creates closure
     socket.on("message", () => console.log(count));

     return <button onClick={() => console.log(count)} />; // This ALSO creates closure
   }
   ```

## Can we say every react hook forms closure?

‚ùå Not every hook creates a closure
‚úîÔ∏è But every hook USES or RELIES on closures
saying ‚Äúevery React hook INVOLVES closures‚Äù IS absolutely correct.

1. useState:
   No ‚Äî useState does not create a closure.
2. useEffect
   Always creates closures
   Because the effect callback is a function defined inside the component.
3. useCallback
   ALWAYS creates a closure
   because you define a function inside a component.
   useCallback stores that closure.
4. useMemo
   ALWAYS creates a closure
   because the memoized function reads outer variables:
5. useRef
   Does NOT create a closure
   But the component function that accesses the ref DOES.

   ```jsx
   const ref = useRef(0);

   function handle() {
     console.log(ref.current); // closure created by handle()
   }
   ```

6. useReducer
   useReducer itself does NOT create closure
   BUT:
   reducer created inside component ‚Üí closure
   dispatch triggers async updates ‚Üí closure stable

7. useTransition, useDeferredValue, etc.
   These hooks don‚Äôt create closures themselves,
   but your callback logic inside them DOES.

### Why Hooks Involve Closures

A React component is just a function:

```js
function Component() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log(count);
  }, []);

  return <button>{count}</button>;
}
```

When React calls this function, it:

- creates new variables (count, setCount)
- creates new closures for any inner functions you define
- stores hook callbacks for later use

So closures are everywhere, automatically.

### But child component is also called inside the parent component or child component is defined inside the parent component or child component definition are always independent and not hierarchial?

Components are NOT nested functions

Even if you write:

```jsx
function Parent() {
  return <Child name="Nishant" />;
}
```

It does NOT mean:

- Child is defined inside Parent, OR
- Child executes inside Parent, OR
- Child forms a closure over Parent

**1. Child component definitions are ALWAYS independent**

- A child component is just a normal JS function.
- It does not live inside or under the parent in the JavaScript sense.
- They are not nested functions; they are separate, top-level functions.

**2. Parent ‚Äúcalling‚Äù <Child /> is NOT a function call**

- React turns this: `<Child name="Nishant" />` into `<Child name="Nishant" />`, But this call is made by React, not by your code.
- And this call does NOT make the child live inside the parent‚Äôs lexical scope.
- Child‚Äôs lexical scope is defined where it is written, not where it is used.

**3. Child component does NOT get access to the parent‚Äôs variables**
Child component is NOT defined inside the parent component, it gets called inside the parent scope

```js
function Parent() {
  const x = 10;

  return <Child />;
}

function Child() {
  console.log(x); // ‚ùå ERROR ‚Äî child cannot access parent's x
}
```

Why?
Because child is NOT a nested function; it does NOT form closure over parent.

**4. Child gets props only because React passes them**

This: `<Child msg="hello" />` Becomes `Child({ msg: "hello" });`
This is not a closure ‚Äî it is just a normal function call with arguments.

## Closure: Child component vs useEffect hook in React

Case 1: If we have a child component in react like below

```js
function Parent() {
  const [count] = useState(0);

  return <Child count={count} />;
}
```

- Parent() executes.
- React sees <Child count={count} />.
- REACT calls Child() separately as: `Child({ count })`

**The important part:**
Child function is NOT created inside Parent‚Äôs execution.
It already exists BEFORE Parent runs.
So NO new closure is created.

Case 2: useEffect

```js
function Parent() {
  const [count] = useState(0);

  useEffect(() => {
    console.log(count);
  }, []);
}
```

Here‚Äôs what actually happens:

- Parent executes.
- Inside this execution, the arrow function: `() => console.log(count)` is created right now.

This inner function is created inside Parent‚Äôs execution, so:

- It captures count
- Parent finishes execution
- But the callback still exists

üëâ Closure is formed.

**The crucial difference**
‚úîÔ∏è useEffect(() => {...})
creates a NEW function inside Parent on every render
‚Üí closure.

‚ùå <Child />
does NOT create a new Child function inside Parent
‚Üí no closure.
