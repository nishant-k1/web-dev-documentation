# Life Cycle of an Execution Context

## 1. Creation Phase/Hoisting

- Sets up the memory for variables and functions `(Hoisting occurs here)`. **Hoisting** occurs for both `GEC` and `FEC`.
- Initializes the `this` value.
- Key Steps:

  1. **Memory Allocation (Hoisting)**:

     - Variables and function declarations are added to the Memory/Variable Environment.
     - Variables are initialized to undefined.
     - Function declarations are stored in their entirety.

  2. **Lexical Environment Setup**:

     - The blueprint of the Lexical Environment is determined at compile time.
       The actual instantiation of the Lexical Environment happens during the creation phase of the Execution Context at runtime.
     - The current Lexical Environment is created with:
       - An Environment Record (to store variables and functions).
       - A reference to the Outer Lexical Environment.

  3. **this Binding Determination**:

     - The value of this is set based on the execution context type:
       - Global Context: this refers to the global object (e.g., window in browsers, global in Node.js).
       - Function Context: this is determined by how the function is invoked.

- **Example During Creation Phase:**

  ```JavaScript
   function foo() {
     console.log(a); // undefined
     var a = 10;
     console.log(bar()); // 'Function Declaration'
     function bar() {
       return 'Function Declaration';
     }
   }
   foo();
  ```

  Explanation:

  a is hoisted and initialized to undefined.
  bar is hoisted with its full function definition.

## 2. Execution Phase

- Executes the code line by line.
- Assigns values to variables and executes functions.
- Key Steps:

1. `Variable Assignment`:

   Variables are assigned their actual values.
   Functions are executed as they are invoked.

2. `Code Execution`:

   The Thread of Execution processes statements one by one in the Code/Execution Phase.
   If a function is called, a new execution context is created for it and pushed onto the call stack.

## Destruction Phase

Once the execution of the context is complete, it is destroyed.

Key Steps:

1. `Context Removal from Call Stack`:
   The execution context is popped off the call stack.

2. `Memory Cleanup`:
   The JavaScript engine cleans up memory for variables and functions declared in the execution context (unless they are referenced by closures).

Example During Destruction Phase:
After the function foo has executed completely, its execution context is removed from the call stack.

---

# Visualization of Lifecycle

```JavaScript
function outer() {
  var x = 10;
  function inner() {
    console.log(x);
  }
  inner();
}
outer();

```

**Call Stack Lifecycle**:

1. Global Execution Context (GEC) is created and pushed to the call stack.
2. When outer is called:
   A new Execution Context (EC for outer) is created and pushed to the stack.
3. Inside outer, when inner is called:
   A new Execution Context (EC for inner) is created and pushed to the stack.
4. After inner completes:
   EC for inner is popped off the stack.
5. After outer completes:
   EC for outer is popped off the stack.
6. The program ends, and GEC is removed.
