# Types of Execution Contexts

## 1. Global Execution Context (GEC)

- The global execution context refers to the environment where the JavaScript code starts executing when the program begins.

- This is the first context created when a JavaScript program runs.
- It is pushed onto the call stack when execution begins (Javascript engine runs).
- It's not a "function" in itself, but rather the environment where all top-level code (outside of functions) is executed.
- It includes `global variables`, `function definitions`, `this`, in the global scope.
- Global context is stored in memory, but when the JavaScript engine runs the code, the global execution context is pushed onto the call stack.
- Once the code finishes executing, the global execution context is popped off the stack.

- It gets Created when the JavaScript engine starts executing code.
- Created when the JavaScript engine starts executing a script.
- It creates a global scope, attaches the global object (like window in browsers or global in Node.js), and initializes variables declared outside any function.
- `this` in GEC:

  - In browsers, `this` refers to the `window` object.
  - In nodejs `this` refers to the `global` object.
  - In `strict mode` ('use strict'),`this` is `undefined`.

- Phases of Global Execution Context
  - **Creation Phase**:
    - The global object is created (`window` or `global`).
    - `this` is assigned to the global object.
    - Global variables and functions are stored in memory.
  - **Execution Phase**:
    - Code is executed line by line.
    - Variables are assigned their values, and functions are invoked.

## 2. Function Execution Context (FEC)

- Each time a function is called, a new FEC is created. The FEC includes the function’s local variables, parameters, and where the function was called from (the call site)
- When a function is invoked, a new execution context is created for that function. This includes the function's arguments, local variables, and the function's scope chain.
- However, the function definition itself is not stored in the FEC. Instead, the FEC contains the execution details for the function's invocation (local variables, scope, etc.).
- The function definition (the code block) is still stored in memory in the scope where the function was defined, which could be:

  1. Global scope if defined globally
  2. Enclosing function scope if defined inside another function.

- If you have multiple nested functions (for example, a function defined inside another function), the function definitions are still stored in the outer (enclosing) scope (the FEC of outer).

- In this case:

  ```JavaScript
  function outer() {
    function inner() {
      console.log("Inside inner function");
    }
    inner();  // Call to inner function
  }

  outer();  // Call to outer function

  ```

  - The inner function definition is stored in the memory of the outer function's scope (the FEC of outer).

  - When outer is called, its FEC is pushed to the call stack, and when inner is called inside outer, the FEC of inner is created and pushed to the call stack.

  - However, the function definition of inner (i.e., function inner() { console.log("Inside inner function"); }) still resides in the scope of the outer function, not in the FEC of inner.

- Created whenever a function is invoked (including arrow functions).

**Note on Arrow Functions:** Arrow functions DO create their own execution context. What they don't create is their own:

- `this` binding (inherited from enclosing lexical scope)
- `arguments` object
- `super` binding
- `new.target`
- Each function call has its own execution context.
- FEC Consists of:
  - A local scope for variables defined within the function.
  - The arguments object for accessing passed arguments.
  - The this keyword (depends on how the function is invoked).
  - Phases of Function Execution Context
    - **Creation Phase**:
      - The function's arguments are stored.
      - Local variables are initialized (they are stored in memory but not yet assigned).
      - The `scope chain` and `this` keyword are set.
    - **Execution Phase**:
      - The function's code is executed.
      - Variables are assigned their values, and the function's logic is executed.

## 3. Eval Execution Context (though rarely used)

- Created when the eval() function is executed.
- Executes code within a string.

## Module Execution Context

Introduced with ES Modules (ES6 and later).

- Created when a module (e.g., a file with import/export) is evaluated, typically when it’s first imported.
- Each module gets its own execution context, which handles the module’s top-level declarations and exports.
- Unlike the GEC, a module execution context is specific to the module and doesn’t pollute the global scope.
- A module is evaluated once per program, and its exports are cached for subsequent imports.
- Example: In utils.js with export { A }, a module execution context is created when utils.js is imported.
