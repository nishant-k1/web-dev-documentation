# JavaScript Closures - Complete Interview Questions

## **Basic Concept Questions**

### 1. What is a closure in JavaScript?

A closure is a mechanism by which a function "remembers" and has access to variables from its outer (enclosing) scope even after the outer function has finished executing. It's the combination of a function and its lexical environment.

```javascript
function outer() {
  let count = 0;
  return function inner() {
    count++;
    return count;
  };
}

const counter = outer();
console.log(counter()); // 1
console.log(counter()); // 2
```

### 2. How do closures work under the hood?

When a function is created, JavaScript creates a reference to the lexical environment where the function was defined. This includes:

- The function's own scope
- A reference to the outer environment (scope chain)

When the outer function returns, its execution context is destroyed, but the lexical environment is preserved in memory (on the heap) because the inner function still has a reference to it.

### 3. Can you give a real-world analogy for closures?

Think of a closure like a backpack: when you graduate from school, the school closes for you (outer function returns), but you still carry your backpack (the closure) containing all the knowledge (variables) you learned there. You can use that knowledge anywhere you go, even though the school session has ended.

### 4. What is the lexical scope, and how is it related to closures?

Lexical scope means that a function's scope is determined by where it is written in the code, not where it is called. Closures depend on lexical scope â€” they capture variables based on where the function was defined, allowing access to those variables even when the function is executed elsewhere.

### 5. Why do closures retain access to variables even after the outer function has executed?

JavaScript's garbage collector only removes objects that have no references. When an inner function references variables from an outer function, those variables remain in memory because they're still reachable through the inner function's scope chain. The lexical environment is stored on the heap, not the call stack.

---

## **Behavior and Use Cases**

### 6. How do closures help in data encapsulation?

Closures allow you to create private variables that can only be accessed and modified through specific functions:

```javascript
function createBankAccount(initialBalance) {
  let balance = initialBalance; // Private variable

  return {
    deposit(amount) {
      balance += amount;
      return balance;
    },
    withdraw(amount) {
      if (amount <= balance) {
        balance -= amount;
        return balance;
      }
      return "Insufficient funds";
    },
    getBalance() {
      return balance;
    },
  };
}

const account = createBankAccount(100);
console.log(account.getBalance()); // 100
console.log(account.deposit(50)); // 150
console.log(account.balance); // undefined - can't access directly!
```

### 7. What is the difference between closures and global variables?

| Aspect         | Closures                                       | Global Variables          |
| -------------- | ---------------------------------------------- | ------------------------- |
| Scope          | Limited to the closure                         | Accessible everywhere     |
| Privacy        | Can be private                                 | Always public             |
| Collision Risk | Low (encapsulated)                             | High (naming conflicts)   |
| Memory         | Collected when closure is no longer referenced | Persist until page unload |
| Control        | Fine-grained access control                    | No access control         |

### 8. Can closures be used to create private variables? Show an example.

Yes! This is one of the most common use cases:

```javascript
function createPerson(name) {
  let _age = 0; // Private variable

  return {
    getName() {
      return name;
    },
    getAge() {
      return _age;
    },
    setAge(newAge) {
      if (newAge >= 0 && newAge <= 150) {
        _age = newAge;
      }
    },
    birthday() {
      _age++;
    },
  };
}

const person = createPerson("John");
person.setAge(25);
console.log(person.getAge()); // 25
person.birthday();
console.log(person.getAge()); // 26
console.log(person._age); // undefined - truly private!
```

### 9. How would you implement a counter using closures?

```javascript
function createCounter(start = 0) {
  let count = start;

  return {
    increment() {
      return ++count;
    },
    decrement() {
      return --count;
    },
    getValue() {
      return count;
    },
    reset() {
      count = start;
      return count;
    },
  };
}

const counter = createCounter(10);
console.log(counter.increment()); // 11
console.log(counter.increment()); // 12
console.log(counter.decrement()); // 11
console.log(counter.reset()); // 10
```

### 10. Explain how closures help in event listeners and callbacks.

Closures are essential for event handlers because they allow the handler to "remember" context:

```javascript
function setupButtons() {
  const buttons = document.querySelectorAll(".btn");

  buttons.forEach((button, index) => {
    const buttonName = `Button ${index + 1}`;

    button.addEventListener("click", function () {
      // This handler closes over 'buttonName' and 'index'
      console.log(`${buttonName} was clicked!`);
      console.log(`Index: ${index}`);
    });
  });
}

// Each button remembers its own name and index via closure
```

---

## **Advanced Scenarios**

### 11. What happens when a closure captures a loop variable inside a `setTimeout`?

This is a classic closure gotcha:

**The Problem:**

```javascript
// Using var - problematic!
for (var i = 0; i < 3; i++) {
  setTimeout(function () {
    console.log(i);
  }, 1000);
}
// Output: 3, 3, 3 (not 0, 1, 2!)
```

**Why?** All three callbacks share the same `i` variable. By the time they execute, the loop has finished and `i` is 3.

**Solutions:**

```javascript
// Solution 1: Use let (block scoping)
for (let i = 0; i < 3; i++) {
  setTimeout(function () {
    console.log(i);
  }, 1000);
}
// Output: 0, 1, 2

// Solution 2: IIFE (Immediately Invoked Function Expression)
for (var i = 0; i < 3; i++) {
  (function (capturedI) {
    setTimeout(function () {
      console.log(capturedI);
    }, 1000);
  })(i);
}
// Output: 0, 1, 2

// Solution 3: Use the third parameter of setTimeout
for (var i = 0; i < 3; i++) {
  setTimeout(
    function (capturedI) {
      console.log(capturedI);
    },
    1000,
    i
  );
}
// Output: 0, 1, 2
```

---

## **Bonus: Common Pitfalls**

### Memory Leaks with Closures

Closures can cause memory leaks if you're not careful:

```javascript
function createHeavyClosure() {
  const hugeArray = new Array(1000000).fill("data");

  return function () {
    // This closure keeps hugeArray in memory!
    console.log(hugeArray.length);
  };
}

// hugeArray stays in memory as long as this reference exists
const closure = createHeavyClosure();
```

**Solution:** Set references to `null` when no longer needed, or restructure to only capture what's necessary.

### Stale Closures in React

```javascript
function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const interval = setInterval(() => {
      // Stale closure! Always sees count = 0
      console.log(count);
    }, 1000);

    return () => clearInterval(interval);
  }, []); // Empty dependency array causes stale closure

  return <button onClick={() => setCount(count + 1)}>{count}</button>;
}
```

**Solution:** Include dependencies in the array, or use a ref.
