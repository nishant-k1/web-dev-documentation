# this Binding

> ðŸ“– **Parent Topic:** [03. Components of Execution Context](./03.%20Components%20of%20Execution%20Context.md)

## `this` and Execution Context

Every time a function is executed, JavaScript creates an execution context for that function. The execution context contains:

- The value of this for that function.
- The local variables and parameters of the function.
- The outer lexical scope (variables and functions that are available to the function).

So, in a sense, this is part of the execution context. It refers to the object (or global scope) that is executing the function, but the exact object this points to depends on how the function is called.

### `this` refers to the Execution Context or the object?

- The keyword this in JavaScript refers to the execution context (not directly to an object), but it can be bound to an object depending on how the function is invoked
- The **value of this** is determined by how the function is called, and it can refer to:

  1. `An object`: When a method is called on an object, this refers to that object. Here in the below code, this refers to the person object because greet is invoked as a method of person.

     ```Javascript
     const person = {
     name: 'Alice',
     greet() {
       console.log(this.name);
     }
     };
     person.greet(); // `this` refers to `person` (the object calling the method)
     ```

  2. The `global context`: In a regular function call, this refers to the global object (window in browsers or global in Node.js) unless in strict mode (where it would be undefined). Here in the below code, this refers to the `global` object (in browsers, it's window) because greet is invoked as a standalone function.

     ```Javascript
     function greet() {
       console.log(this);
     }
     greet(); // In non-strict mode, `this` refers to the global object (`window` in browsers)
     ```

  3. An `explicitly bound object`: When using `.call()`, or `.apply()`, or `.bind()`, this can be set explicitly to any object. Here in the below code, this refers to the person object because greet was explicitly bound using .bind(person).

     ```Javascript
       function greet() {
         console.log(this.name);
       }

       const person = { name: 'Bob' };
       const boundGreet = greet.bind(person);
       boundGreet(); // `this` is explicitly bound to the `person` object
     ```

---

### What Does `this` in the Execution Context Point To?

The value of `this` is set when the function is called and depends on how the function is invoked.

1. **Global Execution Context**: In the global context, this refers to the global object (window in browsers or global in Node.js).

   ```Javascript
   console.log(this); // `this` refers to the global object
   ```

2. **Function Execution Context**

   1. For a regular function, this depends on the call site: 1. In non-strict mode, `this` refers to the `global object`. 2. In strict mode, `this` is `undefined` **if not explicitly set**.

      ```Javascript
      function showThis() {
        console.log(this);
      }
      showThis(); // Non-strict: `this`is the global object; Strict:`this`is`undefined`
      ```

3. **Method Call**: When a function is called as a method of an object, this refers to that object.

   ```Javascript
     const obj = {
     name: 'Nishant',
     greet() {
       console.log(this.name);
       }
     };
     obj.greet(); // `this` refers to `obj`
   ```

4. **Explicit Binding**: Using `.bind()`, `.call()`, or `.apply()`, you can explicitly set this.

   ```Javascript
     function greet() {
       console.log(this.name);
     }
     const obj = { name: 'Alice' };
     greet.call(obj); // `this` refers to `obj`
   ```

5. **Arrow Functions**: Arrow functions do not have their own this. Instead, they inherit this from their enclosing lexical scope.

   ```Javascript
     const obj = {
       name: 'Nishant',
       greet: () => {
         console.log(this.name);
       }
     };
     obj.greet(); // `this` is inherited from the outer scope, not `obj`.
   ```

6. **Constructor Functions (new keyword)**: When a function is called with `new`, `this` refers to the newly created object.

   ```javascript
   function Person(name) {
     this.name = name;
   }
   const person = new Person("Alice");
   console.log(person.name); // 'Alice' - this was the new object
   ```

---

## ðŸ”¥ `call()`, `apply()`, `bind()` - Deep Dive

These methods allow you to explicitly set the value of `this`.

### Syntax Comparison

| Method    | Syntax                                | Invokes Immediately? | Returns         |
| --------- | ------------------------------------- | -------------------- | --------------- |
| `call()`  | `func.call(thisArg, arg1, arg2, ...)` | âœ… Yes               | Function result |
| `apply()` | `func.apply(thisArg, [argsArray])`    | âœ… Yes               | Function result |
| `bind()`  | `func.bind(thisArg, arg1, arg2, ...)` | âŒ No                | New function    |

### Examples

```javascript
function introduce(greeting, punctuation) {
  console.log(`${greeting}, I'm ${this.name}${punctuation}`);
}

const person = { name: "Nishant" };

// call - arguments passed individually
introduce.call(person, "Hello", "!"); // "Hello, I'm Nishant!"

// apply - arguments passed as array
introduce.apply(person, ["Hi", "?"]); // "Hi, I'm Nishant?"

// bind - returns a new function, doesn't invoke immediately
const boundIntro = introduce.bind(person, "Hey");
boundIntro("..."); // "Hey, I'm Nishant..."
```

### ðŸ”¥ Interview Trap: bind() Returns a Function!

```javascript
function greet() {
  console.log(this.name);
}

const obj = { name: "Test" };

// âŒ Common mistake - forgetting to invoke
greet.bind(obj); // Does nothing! Just returns a function
console.log("done");

// âœ… Correct - invoke the bound function
greet.bind(obj)(); // "Test"
// OR
const bound = greet.bind(obj);
bound(); // "Test"
```

### ðŸ”¥ Interview Trap: bind() Cannot Be Overridden

```javascript
function greet() {
  console.log(this.name);
}

const obj1 = { name: "First" };
const obj2 = { name: "Second" };

const boundOnce = greet.bind(obj1);
const boundTwice = boundOnce.bind(obj2); // Trying to rebind

boundTwice(); // "First" - NOT "Second"! bind() only works once
```

### ðŸ”¥ Interview Trap: Arrow Functions Ignore call/apply/bind

```javascript
const obj = { name: "Object" };

const arrow = () => {
  console.log(this.name);
};

arrow.call(obj); // undefined (or global) - NOT "Object"
arrow.apply(obj); // undefined (or global) - NOT "Object"
arrow.bind(obj)(); // undefined (or global) - NOT "Object"

// Arrow functions ALWAYS use lexical this - you cannot override it!
```

---

## ðŸ”¥ Common `this` Interview Traps

### Trap 1: Lost `this` in Callbacks

```javascript
const obj = {
  name: "Nishant",
  greet() {
    console.log(this.name);
  },
};

obj.greet(); // "Nishant" âœ…

setTimeout(obj.greet, 100); // undefined âŒ - `this` is lost!

// Why? When you pass obj.greet to setTimeout, you're passing
// just the function reference, not the object context.

// Solutions:
setTimeout(() => obj.greet(), 100); // Arrow function wrapper
setTimeout(obj.greet.bind(obj), 100); // Explicit bind
```

### Trap 2: `this` in Nested Functions

```javascript
const obj = {
  name: "Outer",
  outer() {
    console.log(this.name); // "Outer" âœ…

    function inner() {
      console.log(this.name); // undefined âŒ (or global in non-strict)
    }
    inner();
  },
};

obj.outer();

// Why? inner() is called as a standalone function, not as a method.

// Solutions:
const obj2 = {
  name: "Outer",
  outer() {
    const self = this; // Solution 1: Save reference
    function inner() {
      console.log(self.name); // "Outer" âœ…
    }

    const innerArrow = () => {
      // Solution 2: Arrow function
      console.log(this.name); // "Outer" âœ…
    };

    inner();
    innerArrow();
  },
};
```

### Trap 3: Method Shorthand vs Arrow in Objects

```javascript
const obj = {
  name: "Test",

  // âœ… Method shorthand - this works correctly
  method() {
    console.log(this.name);
  },

  // âŒ Arrow function - this is lexical (probably global/undefined)
  arrow: () => {
    console.log(this.name);
  },
};

obj.method(); // "Test" âœ…
obj.arrow(); // undefined âŒ
```

### Trap 4: Extracting Methods

```javascript
const obj = {
  name: "Original",
  getName() {
    return this.name;
  },
};

console.log(obj.getName()); // "Original" âœ…

const extracted = obj.getName;
console.log(extracted()); // undefined âŒ - context lost!

// The moment you extract a method, it loses its `this` context
```

### Trap 5: `this` in Event Handlers

```javascript
const button = {
  text: "Click me",
  handleClick() {
    console.log(this.text);
  },
};

// âŒ Wrong - this will be the DOM element, not button object
document.querySelector("btn").addEventListener("click", button.handleClick);

// âœ… Correct solutions:
document
  .querySelector("btn")
  .addEventListener("click", () => button.handleClick());
document
  .querySelector("btn")
  .addEventListener("click", button.handleClick.bind(button));
```

### Trap 6: `this` with `new` Keyword Priority

```javascript
function Foo(name) {
  this.name = name;
}

const obj = { name: "bound" };
const BoundFoo = Foo.bind(obj);

const instance = new BoundFoo("constructed");
console.log(instance.name); // "constructed" - NOT "bound"!

// `new` has HIGHER priority than bind()!
```

---

## `this` Binding Priority (Highest to Lowest)

1. **`new` keyword** - `this` = newly created object
2. **Explicit binding** (`call`, `apply`, `bind`) - `this` = specified object
3. **Implicit binding** (method call) - `this` = object before the dot
4. **Default binding** - `this` = global object (or undefined in strict mode)

**Arrow functions** break this rule - they ALWAYS use lexical `this` from enclosing scope.
