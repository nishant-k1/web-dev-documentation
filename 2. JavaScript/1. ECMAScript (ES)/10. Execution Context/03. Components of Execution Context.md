# Components of Execution Context

An Execution Context has **3 core components**:

1. **Variable Environment** - stores `var` declarations
2. **Lexical Environment** - stores `let`/`const`, scope chain reference
3. **this Binding** - determines value of `this`

---

## 1. Lexical Environment

- A structure that holds the environment record (variables and functions) and a reference to its outer environment.
- Stores variable bindings (e.g., `let`, `const`) and function declarations.
- Points to the Lexical Environment of the parent (outer) scope, forming a scope chain.
- Determines scope and enables closures.

<!-- Image: Lexical Environment visualization -->

---

## 2. Variable Environment

- The Variable Environment is similar to the Lexical Environment but is specifically responsible for:
  - Managing `var` declarations.
  - Tracking the variables' values within the function.

<!-- Image: Variable Environment visualization -->

**Note:** In modern JavaScript, the `Lexical Environment` and `Variable Environment` overlap significantly because let, const, and var are managed together. However, historically, var declarations were treated differently due to their function-scoped behavior.

| Declaration | Stored In |
|-------------|-----------|
| `var` | Variable Environment |
| `let`, `const` | Lexical Environment |
| Function declarations | Both (hoisted fully) |

### ðŸ”¥ Critical: Each Function Call Gets Its OWN Variable Environment

This is the essence of what Variable Environment means:

- Each function **call** creates a **new** variable environment
- Local variables are **not shared** between different calls to the same function
- This is why closures work â€” each closure captures its own variable environment

```javascript
function createLocker() {
  let secret = Math.random(); // New 'secret' for EACH call
  return () => secret;
}

const locker1 = createLocker(); // locker1 captures secret = 0.123...
const locker2 = createLocker(); // locker2 captures secret = 0.789...

console.log(locker1()); // 0.123...
console.log(locker2()); // 0.789... (different!)
```

Think of it like lockers:

- `locker1` â†’ Locker #101 with its own key
- `locker2` â†’ Locker #102 with its own key
- Keys (closures) only unlock their own locker

```javascript
function two() {
  var isValid; //undefined
}

function one() {
  var isValid = true; // local variable environment
  two();
}
var isValid = false; // gets hoisted and gets assigned undefined
one();
```

---

## 3. this Binding

- Determines the value of `this` based on how a function is invoked.
- It refers to the object that is executing the current function.
- The binding of `this` depends on the execution context type:
  - `Global Context`: `this` refers to the global object (window in browsers or global in Node.js).
  - `Function Context`: Depends on the calling object (default is global object in non-strict mode, or undefined in strict mode).
  - `Arrow Functions`: Do not have their own `this`. They inherit `this` from the enclosing Lexical Environment.

<!-- Image: this Binding visualization -->

> ðŸ“– **Deep Dive:** See [03.1. this Binding](./03.1.%20this%20Binding.md) for detailed examples and interview traps.
