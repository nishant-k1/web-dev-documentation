# Components of Execution Context

1. **Lexical Environment:**

   - A structure that holds the environment record (variables and functions) and a reference to its outer environment.
   - Stores variable bindings (e.g., `let`, `const`, `var`) and function declarations.
   - Points to the Lexical Environment of the parent (outer) scope, forming a scope chain.
   - Determines scope and enables closures.

   <!-- Image: Lexical Environment visualization -->

2. **Variable Environment**:

   - The Variable Environment is similar to the Lexical Environment but is specifically responsible for:
     - Managing `var` declarations.
     - Tracking the variables' values within the function.

   <!-- Image: Variable Environment visualization -->

   Note: In modern JavaScript, the `Lexical Environment` and `Variable Environment` overlap significantly because let, const, and var are managed together. However, historically, var declarations were treated differently due to their function-scoped behavior.

   - The variable environment is a component of an execution context where variables and functions live.
   - However, it's important to note that not all variables live there. For example, variables declared with let and const are stored in a different part of memory called the Lexical Environment.

   ```javascript
   function two() {
     var isValid; //undefined
   }

   function one() {
     var isValid = true; // local variable environment
     two();
   }
   var isValid = false; // gets hoisted and gets assigned undefined
   one();
   ```

3. **this Binding:**

   - Determines the value of `this` based on how a function is invoked.
   - It refers to the object that is executing the current function.
   - The binding of this depends on the execution context type
     - `Global Context`: this refers to the global object (window in browsers or global in Node.js).
     - `Function Context`: Depends on the calling object (default is global object in non-strict mode, or undefined in strict mode).
     - `Arrow Functions`: Do not have their own this. They inherit this from the enclosing Lexical Environment.

   <!-- Image: this Binding visualization -->

4. **arguments keyword**

   - When a global execution context is created we get "this" keyword but unlike the global execution context that gave us a global object that equals to this instead, with a function invocation, we get something called arguments, and that's another keyword.

   - arguments is only available to us when we create a new execution context.

   ```javascript
   //example 1
   function marry(person1, person2) {
     console.log("arguments", arguments); // gives {0: 'Tim', 1: 'Tina'}
     return `${person1} is now married to ${person2}`; // gives: Tim is now married to Tina
   }

   marry("Tim", "Tina");

   arguments; // gives error because arguments is available to us only we have a new execution context i.e. arguments is not available in global execution context.

   // example 2
   function marry() {
     console.log("arguments", arguments); // gives {}
   }

   marry();
   ```

   - With modern javascript you most likely want to avoid arguments. If you really want to use then we can use Array.from(arguments) to convert it into an array

5. **Global Variables**

   1. A global variable is one that is declared in the GEC and accessible everywhere.
      Both var, let, and const behave this way.

   2. The difference lies in how the variable interacts with the global object:
      var attaches itself to the global object.

   3. let and const do not attach themselves to the global object, making them safer and avoiding potential naming conflicts.

      Eg: When we declare a variable using var keyword in the `GEC` then the variable becomes property of the `window` object in BRE and `global` object in NRE

## Drawbacks of global variables

- Using too much global variables might cause memory leaks.
- We can get variable collision (overwriting my mistake)
