# Scope

A scope is just a “container of variables,” NOT something that runs.

## JavaScript Lexical/static Scoping Model and Javascript Scope (Global, Module, Function, Block)

JS uses lexical (static) scoping, not dynamic.
In JavaScript, scope refers to the context in which variables, functions, and objects are accessible or visible.
Scope determines the lifetime and visibility of these constructs during the execution of a program.

## Types of Scope in JavaScript

JavaScript has one scoping model: **lexical/static scope**. Within that model, there are `four` main types of scopes:

1. Global Scope
2. Module Scope
3. Function Scope
4. Block Scope

Note: `Local Scope` is a terminology for combined `Function Scope` and `Block Scope`. Both can be called local scope.

---

## Lexical (Static) Scope

- Global Scope, Function Scope, Block Scope, and Module Scope are specific types of scopes that operate within the rules of lexical scope.
- In other words, these scopes are instances or subcategories of lexical scope, not the other way around.
- Lexical scope is the broader mechanism that governs how these specific scopes are structured and accessed.
- `Lexical Scope: variable names are resolved based on where functions and variables are defined in the source code, not where they are executed.`
- JavaScript uses lexical scoping, meaning the scope of a variable is determined by its location in the source code.
- Inner functions have access to variables in their outer functions. This access persists even after the outer function has finished executing — a mechanism known as a **closure**.

  - HE KEY DISTINCTION between Closure and Lexical Scope

  ✔️ Lexical scope → inner function can access outer variables WHILE outer is still running
  ✔️ Closure → inner function can access outer variables EVEN AFTER outer has finished
  Every closure uses lexical scope,
  but not every lexical scope produces a closure.

- The inner block has access to the variables declared in the outer function

```javascript
function outer() {
  let outerVar = "I am from outer";

  function inner() {
    console.log(outerVar); // Accessible due to lexical scoping
  }

  inner();
}

outer();
```

For more on Lexical and Closures refer to [Closures](<../../10.%20Execution%20Context/3.%20Components%20of%20Execution%20Context/2.%20Lexical%20Environment%20(Resolving%20Variables)/2.%20Closures/index.md>)

### 1. Global Scope

- Variables declared in the Global Execution Context (outside of functions, blocks, or modules).
- var → hoists to function scope (or global)
- These variables can be accessed from anywhere in the program.
- `Globally scoped` means the variable is accessible anywhere in your code, including inside functions or blocks. Both var, let, and const can behave this way when declared in the global scope.
- The term "`global scope`" differs from being `attached to the global object`:

  - `var becomes globally scoped when declared in the top level of the script (not module) and gets attached to the window/global object`.
  - `let and const are also globally scoped when declared in the top level of the script (not module) but does not get attached to the window/global object`, which makes them safer for modern JavaScript development.
  - let and const declared at the top level of a script (not module) do not create true global variables. They are scoped to the script and not global in the same way var is.
  - let and const declared at the top level of a script are not added to the global object (window in browsers), even though they are accessible throughout the script.

```javascript
var globalVar = "I am global";

function example() {
  console.log(globalVar); // Accessible
}

console.log(globalVar); // Accessible
```

---

### 2. Module Scope

- This isolation is enforced by the ES6 module system. Variables inside a module are not added to the global scope unless explicitly exported and imported.
- Variables declared in a module (using import / export) are scoped to that module and not accessible globally.
- If a variable is declared in a module and exported, it is still module-scoped, not global-scoped — even though other modules can import it.
- In ES6 modules, variables declared at the top level of a module are in the module scope.
- They are only accessible within the module, not globally.
- This is achieved using `import` and `export`.
- Modules are always in strict mode, and top-level this is undefined (not window), further proving they're isolated.

```javascript
// module1.js
export const moduleVar = "I am module-scoped";

// module2.js
import { moduleVar } from "./module1.js";
console.log(moduleVar); // Accessible
```

---

### 3. Function Scope

- Function scope: Variables declared inside a function.
- var → hoists to function scope (or global)
- Accessible variables: A function can access its own scope + outer scopes, thanks to lexical scoping. But only the variables declared inside a function are considered to be in that function’s scope.
- **Parameters of a function belong to that function's scope. They are treated just like variables declared inside the function — they are local to that function.**
- Variables declared with var inside a function are accessible only inside that function.
- Variables declared inside a function (using `var`, `let`, or `const`) are in the function scope.
- These variables are only accessible within that function.
- Variables declared outside a function are not part of the function's own scope, but the function can access them through the scope chain. So they are not in the function scope, but are accessible to the function via outer (or parent) scopes.

```javascript
function example() {
  var functionVar = "I am function-scoped";
  console.log(functionVar); // Accessible
}

console.log(functionVar); // Error: functionVar is not defined
```

---

### 4. Block Scope

- Variables declared with `let` or `const` inside a block (`{}`) are block-scoped.
- They are accessible only inside that block.
- let/const → hoists to block scope ({})

```javascript
{
  let blockVar = "I am block-scoped";
  const blockConst = "I am also block-scoped";
  console.log(blockVar); // Accessible
  console.log(blockConst); // Accessible
}

console.log(blockVar); // Error: blockVar is not defined
console.log(blockConst); // Error: blockConst is not defined
```

---

## Scope Chain

- Variables declared outside a function are not part of the function's own scope, but the function can access them through the scope chain. So they are not in the function scope, but are accessible to the function via outer (or parent) scopes.
- When a function executes, JavaScript looks for variables in this order:

  - Local scope (inside the function)
  - Parent (outer) scopes, one level up at a time
  - Global scope

- When a variable is referenced, JavaScript looks for it in the current scope. If not found, it traverses up the scope chain to outer scopes until it reaches the global scope.
- The scope chain is established based on the lexical (code) structure, not the call stack.

## Dynamic Scope (Not in JS)

- JavaScript does **not** use dynamic scoping (like some other languages).
