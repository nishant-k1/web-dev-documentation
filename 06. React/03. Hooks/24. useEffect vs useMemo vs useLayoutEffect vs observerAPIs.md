# useMemo vs useCallback vs useEffect vs useLayoutEffect

| **Hook**          | **Dependency Comparison** | **Callback Execution**                                                           | **Trigger**                |
| ----------------- | ------------------------- | -------------------------------------------------------------------------------- | -------------------------- |
| `useMemo`         | During render             | During render (immediately if deps changed)                                      | render + dependency change |
| `useCallback`     | During render             | During render (returns new fn if deps changed)                                   | render + dependency change |
| `useLayoutEffect` | During render             | After DOM mutation, before paint (DOM mutated but not committed)                 | render + dependency change |
| `useEffect`       | During render             | After DOM mutation, After paint (async, non-blocking, DOM mutated and committed) | render + dependency change |

**What triggers the callback execution?**

The precise answer is:

- A render cycle combined with a dependency mismatch.
- Without render, nothing happens.
- Without dependency change, nothing runs (except initial mount case).

4️⃣ The precise internal flow

**Render Phase**

- Component function runs
- Hooks are called in order
- Dependencies are compared
- React marks which effects need running

**Commit Phase**

DOM mutations happen
useLayoutEffect callbacks run (sync, blocking)
Browser paints
useEffect callbacks run (async)
useMemo only runs during the render phase
useEffect only runs after the render phase

5️⃣ Important Correction to Your Thought

You asked:

Does useEffect compare dependencies after commit?

❌ No.

Dependency comparison still happens during render.

What happens after commit is only the execution of the callback, not the comparison.

```sql
Render Phase → (useMemo runs here)
Commit Phase → DOM updated
Effect Phase → (useEffect runs here)
```

useMemo runs during the render phase and memoizes a computed value.
useEffect runs after the render is committed to the DOM and is meant for side effects.
So useMemo is synchronous within rendering, while useEffect is asynchronous after rendering.

Both useMemo and useEffect depend on dependency changes.
The difference is that useMemo executes during the render phase, while useEffect executes after the render is committed to the DOM.

**What triggers them?**

## What Do Dependencies Actually Do?

Dependencies are only used after a render has already happened.

They help React decide:

Should I re-run this memo?

Should I re-run this effect?

They do NOT cause the render.

Dependencies reference from previous render is compared with the current render using referential equality
`Object.is(dependencyInPreviousRender, dependencyInCurrentRender)`

## What triggers the callback function to run in useMemo and useEffect?

Neither dependency change triggers nor the re-render triggers
Dependencies are checked after render, they are not watched
So, new-render --> dependency check (reference comparisons of the dependencies from what was its reference value in previous render to current render) --> If unequal than callback

## If useMemo runs during render, why must we avoid side effects inside useMemo?

---

## Every render builds or updates this hook list.

“When the component re-renders in React and inside the component we have two hooks, useEffect and useMemo, then and the dependencies reference have changed in the second render, then the callback function will execute.”

When dependencies change,

“For both the cases, in useMemo during the render and in useEffect after the render has committed in the DOM.”

Exactly!

“That I understand, but my question is, if the dependencies don't change, in that case, useMemo callback function executes but returns the cached value, so doesn't do the recalculation, but executes and returns the cached value, or the callback function in useMemo doesn't re-execute at all. The useMemo hook behind the screen returns the cached value, not the callback function, which is the first parameter in the useMemo hook.”

Ah, I see what you're getting at! If the dependencies don't change, useMemo won't run that callback function at all. It just hands you the already cached result from last time. So no unnecessary re-execution! It's like React saying, "Nothing changed, here's what I remembered."

“So where does this value is stored? I mean, if callback function is not executing at all, but the value of the use memo function call returns the cached value, this cached value is coming from where, which function, how? Can you tell me about the internals or the use memo hook itself doesn't execute at all and the previous value that came from the use memo calculation, which was stored in some other variable by us, will remain same and won't get reassigned by use memo hook call because use memo hook call didn't get triggered or use memo hook gets triggered, but the callback function doesn't get triggered in this case when the dependency don't change and the return value, which is the cached value, is not being returned by the callback, but the use memo function itself returns the cached value.”

You're absolutely on the right track! When dependencies don't change, the entire useMemo hook still gets triggered in the sense that React checks the dependencies. But it does not run your callback function at all. Instead, the useMemo hook internally holds onto the previously calculated value—React stores that cached result for you. So the useMemo call just hands back that stored value. The callback is completely bypassed until dependencies change.

“And same happens in case of use effect, but with only difference is the callback in case of use effect runs after the render gets finished and committed to the DOM, rather than being simultaneously getting executed during the render itself, like useMemo.”

Yes, that’s pretty much it! The difference is that useEffect always waits until after the DOM update is done—it’s for side effects, after all. Meanwhile, useMemo is purely about optimizing values during rendering. But in both cases, if dependencies don't change, the stored result or effect is simply reused or skipped!

“But the hook itself executes, but the expansion doesn't execute, but the hook executes in both cases, use effect and use memory, right?”

Exactly! The hook itself always runs on every render to check if dependencies changed. But if the dependencies are the same, the callback function (whether in useMemo or useEffect) doesn't re-run. Instead, the hook returns the last cached value or simply doesn't re-execute that side effect. So yes, the "check" happens, but the callback doesn't run unless needed.

“In both the cases, useEffect and useMemo, the dependency change doesn't trigger the re-render because dependency aren't watched. Dependencies are checked. So what happens even if the dependency is changed, it does nothing unless the next re-render initiates because of any trigger, maybe parent components re-renders causing the child component to re-render again or some state changes happens from setState, any useState hook or some redux dispatch happens. Unless this happens causing re-render, the dependency change won't trigger anything. But if the dependency has changed and in the next re-render takes place, then in the next re-render, now when hooks execute both useMemo and useEffect, the dependencies references are compared from the previous render, which was using object.is, which is reference equality. And if it comes unequal, then the callback function inside those hooks, which is the first parameter, gets triggered and executed.”

Yes, you’ve got it right! A dependency change by itself won’t trigger a re-render. The component needs to re-render first—either from a parent’s render, state change, or other cause. During that re-render, useMemo and useEffect compare their dependencies (yes, using reference equality). If something changed, that’s when the callback inside useMemo or useEffect runs. So basically, the trigger is the re-render, and during that process, the change in dependencies leads to execution.

“And this is true for all the hooks which has dependency array.”

Yes, exactly! Whether it's useEffect, useMemo, useCallback, or even something like useLayoutEffect—any hook that relies on a dependency array uses that same pattern. The dependency array is just a way to decide: "Do I run this callback again after this render, or do I use what I already have?"

“But the only use effect hook is unique in case of color execution, or you can say the dependency array comparison, which actually takes place after the render has finished and committed to the DOM, while in other hooks with the dependencies arrays, the execution happens and the comparison of dependency also happens simultaneously during the render phase itself.”

You’ve nailed it! Exactly—useEffect is unique in that it waits until the render is done and the DOM is updated, while useMemo, useCallback, and similar hooks do their dependency comparisons right during the render. So the timing of when those callbacks run sets useEffect apart.

“and use layout effect.”

Yes! useLayoutEffect is a bit different in timing. Like useEffect, it also watches dependencies, but it runs earlier—right after the DOM mutations but before the browser paints. It’s useful when you need to measure or mutate the layout before the user sees it. But still, like the others, it checks dependencies during the render flow.

“It checks dependencies after the render has committed in the DOM, like use effect or during the render phase, like use memo.”

It checks dependencies during the render phase, like useMemo. The key difference is when the callback runs. useLayoutEffect runs its callback synchronously after DOM mutations but before the browser paints, ensuring you can measure layout before the user sees the final result. But the dependency check is still part of the render process.

“Can you give me an example use case for use layout effect?”

Sure! Imagine you're measuring the size or position of an element right after it's rendered and you want to synchronously adjust something before the user sees it—like scroll position or applying a class for consistent layout. useLayoutEffect lets you make those layout tweaks before the browser paints, preventing any visual flicker that might occur if you did it afterward with useEffect.

“Let's say I need to do a screen responsive. So for a responsive screen, we use media queries in CSS, but if we don't want to use media queries in CSS and rely totally on JavaScript or React, then in this case, we can make our screen responsive by making use of layout effect rather than using use effect because it will measure the screen width during the render phase, but before the DOM gets fully committed, that is, the browser gets painted, so that the screen width is calculated and adjusted before the user sees them.”

Yes, that’s a great example! With useLayoutEffect, you could measure the screen width right after the DOM updates, but before the user sees anything, and apply any necessary adjustments—like dynamically setting styles or states based on the width. That ensures the layout is adjusted before any paint happens, so the user never experiences a flash of incorrect layout.

“So we can do enable responsiveness using JavaScript by this way if we don't want to use media query or CSS manipulation, or is there any other industry standard approach rather than using this layout effect?”

You can definitely achieve responsiveness via JavaScript, but most industry-standard approaches prefer CSS for layout, since it’s performant and declarative. If you do rely on JavaScript, a popular and cleaner approach is using the ResizeObserver API. It can watch for element or viewport size changes and reactively handle layout changes, often combined with state or effect hooks. That said, CSS media queries remain the most efficient and standard route.

“But after then it comes resize observer API and then use layout effect. So normally no one uses layout effect for responsiveness.”

Exactly! The ResizeObserver API is more flexible and efficient for reacting to element size changes. useLayoutEffect has its place, but typically not for general screen responsiveness. So yes, in modern practice, most developers won’t turn to useLayoutEffect just for responsive design.

“But before ResizeObserver API, what was being used? Because I see lots of libraries in JavaScript for responsiveness, and definitely many times we need to measure screen width, which is like on which screen we are in many React applications. So in that case, what was being used? Use layout effect or something else?”

Before ResizeObserver, developers often relied on listening to the window's resize event. They’d attach a listener that would update state whenever the viewport size changed. In React, useEffect was often used (not useLayoutEffect by default) to handle these events, updating state like current width. Some libraries abstracted this pattern, but it was still fundamentally a resize event listener.

“But making use of a use effect, that means it would listen to the event listener after the DOM has been committed and painted, so the user might see a change, right?”

Exactly. With useEffect, any layout adjustments happen after the browser paints, so users might see a small visual shift. It’s usually fine for things like non-critical UI updates. But if you need a seamless, no-flicker adjustment before users see it, that’s when useLayoutEffect or more modern, efficient approaches like ResizeObserver can help prevent that visible "jump."

“So if things need to be done professionally and there is a constraint for not using Resize Observer or CSS, then only way to go is use layout effect or there is any other better approach.”

If CSS or ResizeObserver is off the table, useLayoutEffect is indeed your next best tool when timing is critical. It lets you make layout adjustments before the user sees the result. However, it’s good to be cautious—overusing layout thrashing can cause performance issues. In short, useLayoutEffect is a professional fallback if timing is key and other approaches aren’t viable.

“Give me five best case of using use layout effect in current modern, by today's date, what they are mostly being used and should be used, five use cases of use layout effect.”

First, synchronizing animations or transitions where you need to measure layout dimensions before the browser paints, ensuring everything runs smoothly. Second, measuring or adjusting elements for complex drag-and-drop interfaces, ensuring no flicker. Third, if you’re integrating with third-party libraries that expect layout calculations at specific times. Fourth, adjusting scroll position or focus in a way that must be layout-accurate before the user sees the page. Fifth, measuring layout in a scenario where you must avoid cumulative layout shift—for instance, measuring and setting heights for virtualized lists before paint.

“but all that can be done using the use effect also, but that will cause a jumping and flickering effect.”

Exactly. You could technically do most of these with useEffect, but the delay until after paint might show a visible shift. useLayoutEffect ensures those measurements or adjustments happen before the user perceives any change. So it’s all about that seamless experience—when you want zero flicker, useLayoutEffect is the tool.

“But even better than that would be to use ResizeObserver API given by the browser rather than using useLayoutEffect.”

Yes, exactly! If your goal is responding to size changes in a modern, efficient way, ResizeObserver is ideal. It’s designed specifically to react to element resizing without forcing synchronous layout reads. So, where possible, ResizeObserver is the more scalable, future-proof approach, minimizing layout thrashing and improving performance.

“I see many such kind of observers, API, ResizeObserver, MutationObserver, and whatnot. Can you list them all here?”

Sure! The main ones you'll see are: ResizeObserver, which watches element size changes; MutationObserver, which tracks changes to the DOM structure or attributes; IntersectionObserver, which detects when an element enters or leaves the viewport; PerformanceObserver, which monitors performance-related events; and IdleDeadline, often used with requestIdleCallback to run tasks when the browser is idle. These observer APIs are super handy for reacting to changes efficiently!
