# Shallow Equal

- **Shallow equality checks reference equality at the object level and value/reference equality at the first-level properties.**
  - If first level properly primitive then valueEquality
  - If first level property non-primitive then referenceEquality
- If two objects share the same reference, then both are shallow equal.
- If two objects do not share the same reference, and their first-level properties also do share the same references, then React’s shallow equality will return true.
- If two objects do not share the same reference, and their first-level properties also do not share the same references, then React’s shallow equality will return false, even if the values look identical.
- **For primitives** (number, string, boolean, null, undefined): **compares by VALUE**
- **For objects/arrays** (reference types): **compares by REFERENCE**, not by contents
- Only first-level properties are compared. Not second level, not nested.

## Key Point: Shallow Comparison Uses BOTH Value and Reference Comparison

**Shallow comparison is NOT only "reference-only"** - it depends on the first level property type as well:

```javascript
// ✅ PRIMITIVES: Compared by VALUE
shallowEqual({ name: "John", age: 30 }, { name: "John", age: 30 }); // ✅ true (primitives compared by value)

// ❌ OBJECTS/ARRAYS: Compared by REFERENCE
shallowEqual({ user: { name: "John" } }, { user: { name: "John" } }); // ❌ false (different object references)

// ✅ OBJECTS/ARRAYS with SAME REFERENCE: Compared by REFERENCE
const user = { name: "John" };
shallowEqual({ user: user }, { user: user }); // ✅ true (same reference)
```

```jsx
const a = { x: { y: 1 } }; // nested object
const b = { x: { y: 1 } }; // same shape/values but new reference

shallowEqual(a, b); // ❌ false

---

const inner = { y: 1 };

const a = { x: inner };
const b = { x: inner };

shallowEqual(a, b); // ✅ true

```

## Case 1: If reference is SAME: then doesn't even check first level properties or nested

```js
const nested = { y: 1 };

const a = { x: nested };
const b = { x: nested };

shallowEqual(a, b); // ✅ true
```

## Case 2: If reference is DIFFERENT: then it checks the first level properties but nested

```js
const nested1 = { y: 1 };
const nested2 = { y: 1 }; // even if this has SAME references inside

const a = { x: nested1 };
const b = { x: nested2 };

shallowEqual(a, b); // ❌ false  (nested1 !== nested2)
```

## For Objects: Reference Comparison Only, NOT Value Comparison

**Important:** When comparing object/array properties, shallow comparison **ONLY uses reference comparison, NOT value comparison**.

```javascript
// ❌ Different object references - even with IDENTICAL values
shallowEqual(
  { user: { name: "John", age: 30 } },
  { user: { name: "John", age: 30 } }
);
// false - Doesn't check nested object values, only checks if references are same

// ✅ Same object reference - automatically equal
const user = { name: "John", age: 30 };
shallowEqual({ user: user }, { user: user });
// true - Same reference, doesn't need to check values

// ❌ Different array references - even with IDENTICAL values
shallowEqual({ items: [1, 2, 3] }, { items: [1, 2, 3] });
// false - Doesn't check array contents, only checks references

// ✅ Same array reference
const items = [1, 2, 3];
shallowEqual({ items: items }, { items: items });
// true - Same reference
```

**Key Takeaway for Objects:** Shallow comparison for object/array properties = **Reference check ONLY**, it does NOT look inside to compare values.

> **Note:** The question "If given objects are shallowEqual then both automatically becomes deep equal?" is answered in detail in the "ShallowEqual vs DeepEqual" file.
