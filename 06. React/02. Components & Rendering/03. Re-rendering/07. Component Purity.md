# Component Purity

## React.PureComponent (Purity in Class Components)

Performs shallow comparison on:

- props
- state

## React.memo (Purity in Functional Components)

Performs shallow comparison on:

- props only
- Does NOT compare internal state
- State changes always cause re-render

## ğŸ§  Understanding Pure Functional Components in React

## âš›ï¸ What is a Pure Functional Component?

A **pure functional component** is a **React function component** that:

> **Always renders the same output given the same props** and  
> **doesnâ€™t cause any side effects during rendering**.

---

### ğŸ” In Simple Terms

If you pass the same props to a component multiple times, it should:

- Always return the same JSX output.
- Not depend on any external or mutable state.
- Not perform side effects like API calls, logging, or random value generation during render.

---

## â€œSame UIâ€ in PureComponent

It means:

- React will SKIP the render â€” no re-render at all.
- It does NOT mean: â€œReact re-renders but UI ends up same.â€
- React does NOT even call render()
- No reconciliation
- No virtual DOM diffing
- No DOM updates
- PureComponent entirely skips the re-render phase when props & state are shallowly equal.

## For a regular Component (not Pure)

- It will re-render every time, even if props are same.
- UI might look same, but render() still runs.

## âœ… Example: Pure Functional Component

```jsx
function Greeting({ name }) {
  return <h1>Hello, {name}!</h1>;
}
```

- Input (`props.name`) â†’ `"Nishant"`
- Output â†’ Always `"Hello, Nishant!"`
- No side effects or randomness  
  â†’ âœ… **Pure**

---

## ğŸš« Example: Impure Functional Component

```jsx
function RandomNumber() {
  return <p>{Math.random()}</p>;
}
```

- Even with the same inputs (none), the output changes every render.  
  â†’ âŒ **Impure**

---

## âš™ï¸ Why Purity Matters

React can **optimize** pure components because:

- It can skip re-rendering when props havenâ€™t changed.
- Theyâ€™re predictable â€” easy to test, debug, and maintain.

---

## ğŸ§  React.memo and Purity

If you use:

```jsx
import React, { memo } from "react";

const Greeting = memo(function Greeting({ name }) {
  return <h1>Hello, {name}!</h1>;
});
```

- `React.memo()` makes the component **pure** by doing a **shallow comparison of props**.
- If props donâ€™t change â†’ React skips rendering â†’ ğŸš€ Performance boost.

---

## ğŸ§© Comparison: Class vs Functional

| Type                     | Pure version    |
| ------------------------ | --------------- |
| **Class Component**      | `PureComponent` |
| **Functional Component** | `React.memo()`  |

Both achieve the same optimization goal â€” **preventing unnecessary re-renders**.

---

## ğŸ§­ Summary

| Concept               | Explanation                                                |
| --------------------- | ---------------------------------------------------------- |
| **Definition**        | Component that returns the same output for the same props. |
| **Side Effects**      | None (no API calls, random values, or mutable data).       |
| **Optimization Tool** | `React.memo()`                                             |
| **Benefit**           | Prevents unnecessary re-renders, increases performance.    |

---

# ğŸ’¬ Follow-up: Arenâ€™t All React Components Pure?

---

## âš›ï¸ Reactâ€™s Ideal: â€œComponents _Should Be_ Pureâ€

Reactâ€™s philosophy **encourages** components to be pure functions of their props.

> ğŸ’¬ **In theory:**  
> Given the same props and state, a component should render the same output every time.

But...

> ğŸ’¡ **In practice:**  
> Not _all_ components are pure â€” and React doesnâ€™t enforce purity.

---

## âš™ï¸ Reactâ€™s Definition of Purity

React documentation says:

> â€œReact components should behave like pure functions with respect to their props.â€

That means:

- They **should not modify props or external state**.
- They **should not rely on mutable data**.
- They **should not trigger side effects** during rendering.

---

## ğŸš« When Components Become Impure

### 1. **Using Non-Deterministic Values**

```jsx
function RandomGreeting() {
  return <h1>Hello {Math.random() > 0.5 ? "Nishant" : "World"}!</h1>;
}
```

â¡ï¸ Output changes every render â†’ **Impure**

---

### 2. **Mutating Props or External Variables**

```jsx
let count = 0;

function Counter() {
  count++; // modifies external state
  return <p>{count}</p>;
}
```

â¡ï¸ Not pure â€” output depends on external mutable data.

---

### 3. **Side Effects During Render**

```jsx
function Logger({ name }) {
  console.log("Rendered for", name); // side effect
  return <p>Hello {name}</p>;
}
```

â¡ï¸ React allows this, but technically itâ€™s **impure** (should use `useEffect()`).

---

## âœ… Truly Pure Functional Component

```jsx
function Greeting({ name }) {
  return <h1>Hello {name}</h1>;
}
```

- No mutation
- No side effects
- Output depends **only** on props

âœ… **Pure**

---

## âš–ï¸ Summary

| Concept                     | Explanation                              |
| --------------------------- | ---------------------------------------- |
| **React encourages purity** | âœ… Yes                                   |
| **React enforces purity**   | âŒ No                                    |
| **Why purity matters**      | Predictability, performance, testability |
| **How to ensure purity**    | Avoid side effects, use `React.memo()`   |

---

## ğŸ§© Final Thought

> React components are **intended** to be pure,  
> but React wonâ€™t stop you from writing **impure ones**.

---

Would you like me to show a **real-world example** â€” e.g. converting a component with `useEffect` or random behavior into a **pure + optimized version** from your `flushjohn` project?

Thatâ€™ll show exactly how purity improves performance and readability.
