# FAQs

## In case props will always be shallow unequal because reference of the props object will always be different because of the newer scope of the newly rendered parent component and the first level properties can have the value same but the reference always different again

But here's the key: React doesn't compare the props object reference - it compares the values inside the props object using shallowEqual.

What React Does vs What You're Thinking

❌ What React Does NOT Do:

```js
// Parent renders twice:

// Render 1:
const propsObject1 = { user: userA };

// Render 2:
const propsObject2 = { user: userB };

// React does NOT do this:
if (propsObject1 === propsObject2) {
  // ❌ WRONG!
  // Don't re-render
}
```

✅ What React Actually Does:

```js
// React does this (shallowEqual):
function shallowEqual(propsObject1, propsObject2) {
  // React IGNORES the props object reference!
  // It compares the VALUES inside:

  for (let key in propsObject1) {
    if (!Object.is(propsObject1[key], propsObject2[key])) {
      return false; // Not equal
    }
  }
  return true; // Equal
}
```

**Summary**

Yes, the props object reference is always different, BUT:

- Step 1 fails: Object.is(oldProps, newProps) → false
- Algorithm continues (doesn't return)
- Steps 3-5 check property values
- If property values match → returns true
- If property values differ → returns false

In your original example:

- Props object references differ (Step 1 fails, but continues)
- Property value user differs (different object references)
- Returns false
- Component WILL re-render
  The algorithm is designed so that props object reference doesn't matter - only the first-level property values matter!

## from algorithm it does compre the props object refrence, right or wrong?

✅ RIGHT - The algorithm DOES compare the props object reference!
But - and this is critical - it's only an optimization (early exit), not the final decision.

```js
function shallowEqual(objA, objB) {
  // Step 1: Check if both are the same reference
  if (Object.is(objA, objB)) {
    return true; // ← EARLY EXIT (optimization)
  }

  // If we reach here, references are DIFFERENT
  // But the algorithm CONTINUES to check properties...

  // Steps 2-5: Check property values
  // ...
}
```

What This Means
The algorithm checks props object reference in TWO ways:

1. Step 1 (Optimization):

   - IF props objects are the same reference → return true immediately (fast path)
   - IF props objects are different references → continue checking properties

2. Steps 2-5 (Full check):

   - Compare the property values inside the props objects

![alt text](image-3.png)

So To Answer Your Question Precisely
Question: "Does the algorithm compare the props object reference?"
Answer: YES, it does (in Step 1).
BUT:

- If same reference → returns true ✅
- If different reference → doesn't return false, instead continues to check properties

> "React checks the props object reference as an optimization (Step 1), but if they differ, it doesn't immediately return false - it continues to compare the property values (Steps 2-5) to make the final decision."

**The Flow**

shallowEqual(oldProps, newProps)

Step 1: Are props objects the same reference?
├─ YES → return TRUE ✅ (done, skip property checks)
└─ NO → continue to Step 2

Step 2-4: Basic validation (null checks, key counts)
└─ Continue to Step 5

Step 5: Compare each property value
├─ All match → return TRUE ✅
└─ Any differ → return FALSE ❌

## now why and how props refrence always different and never same?

Great question! Props reference is NOT always different - it depends on how React creates the props object internally.

How React Creates Props Objects
When you write JSX:

```js
<Child name="john" age={30} />
```

The `{ name: "john", age: 30 }` is a new object literal created on each render.

Why Props Reference is Usually Different

```js
function Parent() {
  const [count, setCount] = useState(0);

  return (
    <>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <Child name="john" age={30} />
    </>
  );
}

// Render 1:
// React internally does:
const props1 = { name: "john", age: 30 }; // New object
React.createElement(Child, props1);

// Render 2 (after increment):
// React internally does:
const props2 = { name: "john", age: 30 }; // Another new object
React.createElement(Child, props2);

// props1 !== props2 (different object references)
```

**Why? Because each render creates a new object literal { name: "john", age: 30 }.**

### Can Props Reference Be the Same?

❌ Not in normal usage - React always creates new props objects
Even though the props object is always new, React doesn't optimize by reusing the props object reference itself. This is by design.

Let me clarify what DOES stay the same
The property values can stay the same:

```js
function Parent() {
  const [count, setCount] = useState(0);

  return (
    <>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <Child name="john" age={30} /> {/* Primitives - same values */}
    </>
  );
}

// Render 1:
props1 = { name: "john", age: 30 }; // Reference: 0x001

// Render 2:
props2 = { name: "john", age: 30 }; // Reference: 0x002

// Props object references:
props1 !== props2; // TRUE (different objects)

// But property VALUES:
props1.name === props2.name; // TRUE ("john" === "john")
props1.age === props2.age; // TRUE (30 === 30)

// shallowEqual checks property values, so:
shallowEqual(props1, props2); // TRUE ✅
// Child won't re-render!
```

Why React Doesn't Reuse Props Objects
React could theoretically cache and reuse props objects, but it doesn't because:

- Performance cost: Checking if props can be reused would require comparing them anyway
- Complexity: Managing a cache of props objects adds complexity
- Not needed: shallowEqual already handles it efficiently by comparing property values

The Design Philosophy
React's approach:

- Always create a new props object (simple, predictable)
- Use shallowEqual to compare property values (efficient)
- If property values match, skip re-render (optimization achieved)

This is simpler than trying to cache and reuse props objects.

When Would Props Reference Be the Same?
In theory, you could manually pass the same props object:

```js
function Parent() {
  const [count, setCount] = useState(0);

  // This is NOT normal React usage!
  const propsObject = { name: "john", age: 30 };

  return (
    <>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      {React.createElement(Child, propsObject)}
    </>
  );
}

// But even this creates a NEW propsObject on each render!
// So props reference would still be different.
```

To truly reuse:

```js
// Props object created ONCE (outside component)
const staticProps = { name: "john", age: 30 };

function Parent() {
  const [count, setCount] = useState(0);

  return (
    <>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      {React.createElement(Child, staticProps)} {/* Same reference! */}
    </>
  );
}

// Render 1: staticProps (reference: 0x001)
// Render 2: staticProps (reference: 0x001) - SAME!

// shallowEqual would hit Step 1 early exit:
// Object.is(staticProps, staticProps) → TRUE
// Returns TRUE immediately!
```

**But nobody writes React like this because JSX syntax doesn't support it.
**

Summary
Why props reference is (almost) always different:

```js
// What you write:
<Child name="john" age={30} />;

// What React does (simplified):
// Render 1:
createElement(Child, { name: "john", age: 30 }); // New object

// Render 2:
createElement(Child, { name: "john", age: 30 }); // Another new object
```

Each render creates a new object literal for props.

Why this is OK:
Even though props objects are different, shallowEqual:

1. Checks props reference (Step 1) - fails
2. Continues to check property values (Steps 2-5)
3. If property values match → returns true
4. Component doesn't re-render

The real optimization:
The optimization isn't in reusing props objects - it's in shallowEqual comparing property values instead of just checking props object reference.

The Practical Takeaway
Don't worry about props object references being different. Focus on:

- Primitive props: Values are compared, always works ✅
- Object/Array/Function props: References are compared, use useMemo/useCallback to stabilize ⚠️

```js
// ✅ GOOD - Primitives
<Child name="john" age={30} />

// ❌ BAD - New object every render
<Child user={{ name: "john" }} />

// ✅ GOOD - Memoized object
const user = useMemo(() => ({ name: "john" }), []);
<Child user={user} />
```

## How Props Can Be Shallow Equal (Despite Different Props Object References)

Props are shallow equal when all first-level property values are the same, even if the props object itself is different.

Scenario 1: All Props are Primitives ✅

```js
const Child = React.memo(({ name, age, email }) => {
  console.log("Child rendered");
  return (
    <div>
      {name} - {age} - {email}
    </div>
  );
});

function Parent() {
  const [count, setCount] = useState(0);

  return (
    <>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <Child name="john" age={30} email="j@gmail.com" />
    </>
  );
}

// Render 1:
oldProps = { name: "john", age: 30, email: "j@gmail.com" }; // Object A

// Render 2 (after button click):
newProps = { name: "john", age: 30, email: "j@gmail.com" }; // Object B

// shallowEqual check:
// Step 1: oldProps !== newProps (different objects) → continue
// Step 5:
//   oldProps.name === newProps.name → "john" === "john" ✅
//   oldProps.age === newProps.age → 30 === 30 ✅
//   oldProps.email === newProps.email → "j@gmail.com" === "j@gmail.com" ✅

// Result: TRUE → WON'T RE-RENDER ✅
```

**Why? Primitives are compared by value, not reference.**

Scenario 2: Object Props with Same Reference ✅

```js
const Child = React.memo(({ user }) => {
  console.log("Child rendered");
  return <div>{user.name}</div>;
});

function Parent() {
  const [count, setCount] = useState(0);

  // ✅ useMemo keeps the SAME reference
  const user = useMemo(() => ({ name: "john", age: 30 }), []);

  return (
    <>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <Child user={user} />
    </>
  );
}

// Render 1:
oldProps = { user: userObject }; // user reference: 0x999

// Render 2:
newProps = { user: userObject }; // user reference: 0x999 (SAME!)

// shallowEqual check:
// Step 1: oldProps !== newProps (different props objects) → continue
// Step 5:
//   Object.is(oldProps.user, newProps.user) → 0x999 === 0x999 ✅

// Result: TRUE → WON'T RE-RENDER ✅
```

Scenario 3: Multiple Props, Mixed Types ✅

```js
const Child = React.memo(({ name, age, config, onClick }) => {
  console.log("Child rendered");
  return (
    <div>
      {name} - {config.theme}
    </div>
  );
});

function Parent() {
  const [count, setCount] = useState(0);

  // Memoize object and function
  const config = useMemo(() => ({ theme: "dark" }), []);
  const handleClick = useCallback(() => console.log("clicked"), []);

  return (
    <>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <Child
        name="john" // Primitive (stable)
        age={30} // Primitive (stable)
        config={config} // Memoized object (stable reference)
        onClick={handleClick} // Memoized function (stable reference)
      />
    </>
  );
}

// Render 1:
oldProps = {
  name: "john",
  age: 30,
  config: configRef, // 0x111
  onClick: handlerRef, // 0x222
};

// Render 2:
newProps = {
  name: "john",
  age: 30,
  config: configRef, // 0x111 (SAME!)
  onClick: handlerRef, // 0x222 (SAME!)
};

// shallowEqual check:
// All property values match → TRUE → WON'T RE-RENDER ✅
```

Scenario 4: Static/Constant Props ✅

```js
const Child = React.memo(({ type, mode }) => {
  console.log("Child rendered");
  return (
    <div>
      {type} - {mode}
    </div>
  );
});

function Parent() {
  const [count, setCount] = useState(0);

  return (
    <>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <Child type="user" mode="view" /> {/* String literals */}
    </>
  );
}

// String literals "user" and "view" are the same value across renders
// WON'T RE-RENDER ✅
```

Scenario 5: Props from State (Unchanged State) ✅

```js
const Child = React.memo(({ userId, userName }) => {
  console.log("Child rendered");
  return (
    <div>
      {userId} - {userName}
    </div>
  );
});

function Parent() {
  const [count, setCount] = useState(0);
  const [userId] = useState(123);
  const [userName] = useState("john");

  return (
    <>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <Child userId={userId} userName={userName} />
    </>
  );
}

// userId and userName don't change
// Same primitive values across renders
// WON'T RE-RENDER ✅
```

Summary Table: When Props Are Shallow Equal

![alt text](image-4.png)

Common Patterns That Work and Common Patterns That DON'T Work

![alt text](image-5.png)

The Key Insight
Props are shallow equal when:

- Props object reference is different (always true in React) ❌
- BUT all first-level property values are the same ✅

For this to work:

- Primitives: Automatically stable (compared by value)
- Objects/Arrays/Functions: Must have stable references (use hooks or constants)

That's how React.memo prevents re-renders despite props objects always being new!

## how can we keep props First-Level Property References the Same

There are several techniques to ensure that object/array/function references stay stable across renders:

1. useMemo - For Objects and Arrays: Memoizes a value and returns the same reference until dependencies change.

```js
function Parent() {
  const [count, setCount] = useState(0);

  // ✅ user reference stays the same across renders
  const user = useMemo(
    () => ({
      name: "john",
      email: "j@gmail.com",
    }),
    []
  ); // Empty deps = never changes

  return (
    <>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <Child user={user} /> {/* Same reference every render */}
    </>
  );
}

// Render 1: user = 0x001
// Render 2: user = 0x001 (SAME!)
// Render 3: user = 0x001 (SAME!)
```

2. useCallback - For Functions: Memoizes a function and returns the same reference until dependencies change.

```js
function Parent() {
  const [count, setCount] = useState(0);

  // ✅ handleClick reference stays the same
  const handleClick = useCallback(() => {
    console.log("Clicked!");
  }, []); // Empty deps = never changes

  return (
    <>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <Child onClick={handleClick} /> {/* Same reference every render */}
    </>
  );
}

// Render 1: handleClick = 0x001
// Render 2: handleClick = 0x001 (SAME!)
```

3. Define Outside Component - For Constants: If the value never changes, define it outside the component.

```js
// ✅ Created once, same reference always
const SETTINGS = {
  theme: "dark",
  language: "en",
};

const ITEMS = [1, 2, 3, 4, 5];

const handleStaticClick = () => {
  console.log("Clicked!");
};

function Parent() {
  const [count, setCount] = useState(0);

  return (
    <>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <Child
        settings={SETTINGS} // Same reference always
        items={ITEMS} // Same reference always
        onClick={handleStaticClick} // Same reference always
      />
    </>
  );
}
```

4. useRef - For Mutable Values (Advanced):When you need a stable reference to a mutable object.

```js
function Parent() {
  const [count, setCount] = useState(0);

  // ✅ configRef.current stays the same object reference
  const configRef = useRef({ theme: "dark" });

  return (
    <>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <Child config={configRef.current} /> {/* Same reference every render */}
    </>
  );
}

// Warning: Mutating configRef.current won't trigger re-renders!
```

5. useState - For Stable State References: State values maintain the same reference until explicitly updated.

```js
function Parent() {
  const [count, setCount] = useState(0);

  // ✅ user reference stays the same until setUser is called
  const [user] = useState({ name: "john", email: "j@gmail.com" });

  return (
    <>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <Child user={user} /> {/* Same reference across renders */}
    </>
  );
}

// user reference only changes if you call setUser
```

6. Props from Parent - Already Stable: If props come from parent and parent doesn't change them, they're already stable.

```js
function Parent({ userData }) {
  const [count, setCount] = useState(0);

  // ✅ userData reference is stable (comes from parent)
  return (
    <>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <Child user={userData} />
    </>
  );
}
```

7. Complete Example: Multiple Techniques

```js
// Outside component - truly static
const STATIC_CONFIG = { apiUrl: "https://api.example.com" };

function Parent() {
  const [count, setCount] = useState(0);
  const [userId, setUserId] = useState(1);

  // State - stable until explicitly updated
  const [theme] = useState("dark");

  // useMemo - for objects
  const user = useMemo(
    () => ({
      id: userId,
      name: "john",
    }),
    [userId]
  );

  // useMemo - for arrays
  const items = useMemo(() => [1, 2, 3, 4, 5], []);

  // useCallback - for functions
  const handleClick = useCallback(() => {
    console.log("Clicked user:", userId);
  }, [userId]);

  const handleSave = useCallback(() => {
    console.log("Saved");
  }, []); // No deps = never changes

  return (
    <>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>

      <Child
        theme={theme} // State (stable)
        user={user} // useMemo (stable per userId)
        items={items} // useMemo (stable)
        config={STATIC_CONFIG} // External constant (stable)
        onClick={handleClick} // useCallback (stable per userId)
        onSave={handleSave} // useCallback (stable)
      />
    </>
  );
}

const Child = React.memo(({ theme, user, items, config, onClick, onSave }) => {
  console.log("Child rendered");
  return <div>...</div>;
});

// Click "Count":
// - All prop references stay the same
// - Child WON'T re-render ✅
```

Quick Reference Guide
![alt text](image-6.png)

### Common Mistakes

❌ Wrong: Creating new object every render

```js
function Parent() {
  const user = { name: "john" }; // NEW every render!
  return <Child user={user} />;
}
```

✅ Right: Memoize it

```js
function Parent() {
  const user = useMemo(() => ({ name: "john" }), []);
  return <Child user={user} />;
}
```

❌ Wrong: Inline function

```js
<Child onClick={() => console.log("click")} /> // NEW every render!
```

✅ Right: useCallback

```js
const handleClick = useCallback(() => console.log("click"), []);
<Child onClick={handleClick} />;
```

When to Use Each

- useMemo: Objects, arrays, expensive calculations
- useCallback: Functions passed as props to memoized components
- Outside component: True constants that never change
- useState: Values that need to be updated sometimes
- useRef: Mutable values that shouldn't trigger re-renders

The key is: any object/array/function reference must be stabilized if you want React.memo to work properly!

### so using, useMemo and useCallback in parent componet is useless if the child compnent is not wrapped with usewMemo?

Yes, mostly correct - but with important nuances!

The Basic Truth
If the child component is NOT wrapped in React.memo, then:

```js
const Child = ({ user, onClick }) => {
  console.log("Child rendered");
  return <div>{user.name}</div>;
};

function Parent() {
  const [count, setCount] = useState(0);

  // ❓ Is this useMemo useful?
  const user = useMemo(() => ({ name: "john" }), []);

  // ❓ Is this useCallback useful?
  const handleClick = useCallback(() => console.log("click"), []);

  return (
    <>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <Child user={user} onClick={handleClick} />
    </>
  );
}

// Click "Count":
// Parent re-renders → Child ALWAYS re-renders
// useMemo and useCallback did NOTHING to prevent child re-render ❌
```

Result: useMemo and useCallback are useless for preventing child re-renders if child is not memoized.

However, They're NOT Completely Useless!
There are other valid reasons to use useMemo and useCallback:

Use Case 1: Expensive Calculations
useMemo prevents re-computing expensive operations:

```js
function Parent() {
  const [count, setCount] = useState(0);
  const [items, setItems] = useState([
    /* huge array */
  ]);

  // ✅ Useful! Prevents expensive sort on every render
  const sortedItems = useMemo(() => {
    console.log("Sorting...");
    return items.slice().sort((a, b) => a.value - b.value);
  }, [items]);

  return (
    <>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <Child items={sortedItems} /> {/* Not memoized, but that's ok */}
    </>
  );
}

// Click "Count":
// "Sorting..." NOT logged (expensive operation skipped) ✅
// Child re-renders (but gets the cached sortedItems)
```

Use Case 2: Dependencies in useEffect/useCallback/useMemo
Stable references prevent infinite loops and unnecessary effects:

```js
function Parent() {
  const [count, setCount] = useState(0);

  // ✅ Useful! Prevents useEffect from running on every render
  const config = useMemo(() => ({ theme: "dark" }), []);

  useEffect(() => {
    console.log("Config changed!");
    // Fetch data with config...
  }, [config]); // Would run every render without useMemo!

  return (
    <>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <Child config={config} />
    </>
  );
}

// Click "Count":
// "Config changed!" NOT logged (useEffect didn't run) ✅
```

Use Case 3: Custom Hooks
Custom hooks often need stable references:

```js
function useData(config) {
  const [data, setData] = useState(null);

  useEffect(() => {
    fetchData(config).then(setData);
  }, [config]); // If config changes every render, fetches every render!

  return data;
}

function Parent() {
  const [count, setCount] = useState(0);

  // ✅ Useful! Prevents re-fetching on every render
  const config = useMemo(() => ({ url: "/api/users" }), []);

  const data = useData(config);

  return (
    <>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <Child data={data} />
    </>
  );
}
```

Use Case 4: Nested Children with React.memo
Even if the immediate child isn't memoized, grandchildren might be:

```js
const GrandChild = React.memo(({ onClick }) => {
  console.log("GrandChild rendered");
  return <button onClick={onClick}>Click me</button>;
});

// Child is NOT memoized
const Child = ({ onClick }) => {
  console.log("Child rendered");
  return (
    <div>
      <GrandChild onClick={onClick} /> {/* GrandChild IS memoized */}
    </div>
  );
};

function Parent() {
  const [count, setCount] = useState(0);

  // ✅ Useful! Prevents GrandChild re-render
  const handleClick = useCallback(() => console.log("click"), []);

  return (
    <>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <Child onClick={handleClick} />
    </>
  );
}

// Click "Count":
// "Child rendered" ← Child re-renders
// "GrandChild rendered" NOT logged ← GrandChild doesn't re-render! ✅
```

Use Case 5: Context Values
Preventing unnecessary context re-renders:

```js
const UserContext = createContext();

function Parent() {
  const [count, setCount] = useState(0);

  // ✅ Useful! Prevents all context consumers from re-rendering
  const contextValue = useMemo(
    () => ({
      user: { name: "john" },
      theme: "dark",
    }),
    []
  );

  return (
    <UserContext.Provider value={contextValue}>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <Child />
    </UserContext.Provider>
  );
}

// Without useMemo: all consumers re-render when Parent re-renders
// With useMemo: consumers only re-render when contextValue changes
```

Use Case 6: Comparing Values (e.g., in useEffect)

```js
function Parent() {
  const [count, setCount] = useState(0);
  const [userId, setUserId] = useState(1);

  // ✅ Useful! Makes comparison reliable
  const filters = useMemo(
    () => ({
      userId,
      active: true,
    }),
    [userId]
  );

  useEffect(() => {
    // This only runs when filters actually change
    console.log("Filters changed", filters);
  }, [filters]);

  return (
    <>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <Child filters={filters} />
    </>
  );
}

// Click "Count": useEffect doesn't run ✅
```

**Summary**
![alt text](image-7.png)

Best Practices

```js
// ❌ BAD: useMemo without React.memo (no other reason)
const Child = ({ user }) => <div>{user.name}</div>;

function Parent() {
  const user = useMemo(() => ({ name: "john" }), []); // Useless!
  return <Child user={user} />;
}

// ✅ GOOD: React.memo + useMemo
const Child = React.memo(({ user }) => <div>{user.name}</div>);

function Parent() {
  const user = useMemo(() => ({ name: "john" }), []); // Useful!
  return <Child user={user} />;
}

// ✅ ALSO GOOD: useMemo for expensive calculation (no React.memo needed)
const Child = ({ items }) => <div>{items.length}</div>;

function Parent() {
  const [data, setData] = useState([
    /* huge array */
  ]);

  const sortedItems = useMemo(() => {
    return data.slice().sort(); // Expensive!
  }, [data]);

  return <Child items={sortedItems} />;
}
```

**Final Answer**

Yes, using useMemo/useCallback is mostly useless if the child is not wrapped in React.memo - BUT only for the purpose of preventing child re-renders.
They can still be useful for:

- Expensive calculations
- Hook dependencies
- Nested memoized children
- Context optimization
- Custom hooks

Rule of thumb: Don't use useMemo/useCallback unless:

- Child is memoized (React.memo or PureComponent), OR
- You have another valid reason (expensive calc, hook deps, etc.)

## React.memo vs React.PureComponent

1. React.memo (Functional Components)
   Wraps a functional component to prevent re-renders when props haven't changed.

   ```js
   // Basic usage
   const MyComponent = React.memo(({ name, age }) => {
     console.log("Rendered");
     return (
       <div>
         {name} - {age}
       </div>
     );
   });

   // Usage
   <MyComponent name="john" age={30} />;
   ```

   With Custom Comparison:

   ```js
   const MyComponent = React.memo(
     ({ name, age }) => {
       return (
         <div>
           {name} - {age}
         </div>
       );
     },
     (prevProps, nextProps) => {
       // Return TRUE if props are equal (DON'T re-render)
       // Return FALSE if props are different (DO re-render)
       return prevProps.name === nextProps.name;
       // Only re-renders if name changes (ignores age)
     }
   );
   ```

   What it Compares:
   ✅ Props only
   ❌ Not state (functional components use hooks)

2. React.PureComponent (Class Components)
   A class component that implements shouldComponentUpdate with shallow comparison.

   ```js
   class MyComponent extends React.PureComponent {
     state = {
       count: 0,
     };

     render() {
       console.log("Rendered");
       const { name, age } = this.props;
       return (
         <div>
           {name} - {age} - {this.state.count}
         </div>
       );
     }
   }

   // Usage
   <MyComponent name="john" age={30} />;
   ```

   What it Compares:
   ✅ Props
   ✅ State
   Equivalent Manual Implementation:

   ```js
   class MyComponent extends React.Component {
     shouldComponentUpdate(nextProps, nextState) {
       // PureComponent does this automatically:
       return (
         !shallowEqual(this.props, nextProps) ||
         !shallowEqual(this.state, nextState)
       );
     }

     render() {
       // ...
     }
   }
   ```

Side-by-Side Examples

```js
// React.memo (Functional)
const FuncChild = React.memo(({ name }) => {
  console.log("FuncChild rendered");
  return <div>{name}</div>;
});

// PureComponent (Class)
class ClassChild extends React.PureComponent {
  render() {
    console.log("ClassChild rendered");
    return <div>{this.props.name}</div>;
  }
}

function Parent() {
  const [count, setCount] = useState(0);

  return (
    <>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <FuncChild name="john" />
      <ClassChild name="john" />
    </>
  );
}

// Click button:
// Neither child re-renders ✅
// Both use shallowEqual on props
```

Example 2: State Change (Key Difference!)

```js
// React.memo - No internal state comparison
const FuncChild = React.memo(({ name }) => {
  const [count, setCount] = useState(0);

  console.log("FuncChild rendered");

  return (
    <div>
      {name}
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
    </div>
  );
});

// PureComponent - Compares state too
class ClassChild extends React.PureComponent {
  state = { count: 0 };

  render() {
    console.log("ClassChild rendered");

    return (
      <div>
        {this.props.name}
        <button onClick={() => this.setState({ count: this.state.count + 1 })}>
          Count: {this.state.count}
        </button>
      </div>
    );
  }
}

// Click internal button:
// FuncChild: Re-renders (useState always triggers re-render)
// ClassChild: Re-renders (state changed)

// If you do: this.setState({ count: 0 }) when count is already 0:
// FuncChild with useState: Re-renders (no optimization)
// ClassChild (PureComponent): Doesn't re-render ✅ (shallowEqual on state)
```

When to Use Which?

![alt text](image-8.png)

Summary
React.memo (Modern, Functional):
✅ For functional components
✅ Compares props only
✅ Easy custom comparison
✅ Preferred in modern React
React.PureComponent (Legacy, Class):
✅ For class components
✅ Compares props AND state
⚠️ Custom comparison requires override
⚠️ Still valid but less common
Bottom line: Use React.memo for new code with functional components. Use React.PureComponent only if you're working with class components.
