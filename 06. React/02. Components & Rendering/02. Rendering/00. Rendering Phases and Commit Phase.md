# Render Phase vs Commit Phase

Render Phase â†’ React calculates what should change (virtual tree updated)  
Commit Phase â†’ React applies those changes to the real DOM

Thatâ€™s correct at a high level.

But letâ€™s clean it up precisely.

---

ðŸ”¹ Render Phase

What actually happens:

- React calls your component functions
- Hooks execute
- Dependencies are compared
- A new Fiber tree (work-in-progress tree) is built

React figures out:

- What changed
- What needs updating

Important:

âŒ No real DOM mutation happens here  
âŒ Nothing visible changes on screen  
âœ… Itâ€™s pure calculation

This is often loosely called â€œvirtual DOM updateâ€, but technically React uses Fiber, not the old-style virtual DOM object.

---

ðŸ”¹ Commit Phase

Now React:

- Applies changes to the real DOM
- Runs useLayoutEffect
- Browser paints
- Runs useEffect

This is where real visible change happens.

---

ðŸ”¹ So Your Statement

Render Phase = virtual DOM gets updated  
Commit Phase = real DOM gets updated

âœ… Conceptually correct

ðŸ”Ž Technically more precise:

Render Phase = Fiber tree recalculated  
Commit Phase = DOM mutations + effect execution

---

ðŸ”¹ One Important Nuance

Render phase can be:

- Paused
- Interrupted
- Aborted
- Re-run

Commit phase:

- Cannot be interrupted
- Always runs synchronously

Thatâ€™s why React keeps them separate.

ðŸ”¹ Clean Final Mental Model

Render Phase â†’ "What should the UI look like?"
Commit Phase â†’ "Make the UI actually look like that."

---

ðŸ”¹ React Has Two Phases (Not Two Hook Categories)

Reactâ€™s architecture has:

Render Phase  
Commit Phase

Hooks align with these phases.

---

ðŸ”¹ 1ï¸âƒ£ Render-Phase Hooks

These run completely during render.

They:

- Must be pure
- Cannot cause side effects
- Execute immediately

Examples:

- useState
- useReducer
- useMemo
- useCallback
- useRef
- useContext

All of these:

- Execute during render
- Do not wait for commit
- Do not use the effect queue

Even useState is render-phase.  
Calling setState schedules another render â€” but the hook itself runs during render.

---

ðŸ”¹ 2ï¸âƒ£ Commit-Phase Hooks (Effect Hooks)

These register side effects.

They:

- Are checked during render
- But execute during commit

Examples:

- useEffect â†’ runs after paint
- useLayoutEffect â†’ runs before paint
- useInsertionEffect â†’ runs even earlier (for CSS-in-JS libraries)

These use:

- Effect tags
- Effect linked lists
- Commit-phase scheduling

ðŸ”¹ So Architecturally, Yes

You can mentally classify hooks into:

| Category           | Hooks                                | When Callback Runs |
| ------------------ | ------------------------------------ | ------------------ |
| Render Phase Hooks | useMemo, useCallback, useState, etc. | During render      |
| Commit Phase Hooks | useEffect, useLayoutEffect           | During commit      |

But React documentation doesnâ€™t officially call them that.

Itâ€™s an internal mental model.

ðŸ”¹ Even More Precise Breakdown

If we go deeper, there are actually three practical categories:

---

1ï¸âƒ£ State Hooks

Store data â†’ trigger render

- useState
- useReducer

---

2ï¸âƒ£ Memoization Hooks

Optimize calculations

- useMemo
- useCallback

---

3ï¸âƒ£ Effect Hooks

Handle side effects

- useEffect
- useLayoutEffect
- useInsertionEffect

Only the third category participates in commit timing.

---

ðŸ”¹ Important Subtlety

All hooks are called during render.

Only effect hooks defer execution of their callback.

Thatâ€™s the key architectural difference.

## For every component in React

**Render Phase** ---> **Commit Phase **---> U**I visible to users**

Firs component renders then gets committed then UI appears on the browser page
