# Error Boundaries in React

## TL;DR

- **Error Boundaries** = Special React components that catch JavaScript errors in child component tree
- Use **class components** with `componentDidCatch()` and `getDerivedStateFromError()`
- Catch errors during **rendering**, in **lifecycle methods**, and in **constructors**
- **Cannot catch**: event handlers, async code (setTimeout, promises), SSR errors, errors in Error Boundary itself
- Display **fallback UI** instead of crashing entire app
- Use **multiple boundaries** for granular error handling
- Log errors to services like **Sentry** for monitoring
- **No function component alternative** yet (as of React 19)

---

## 1. What are Error Boundaries?

**Error Boundaries** are React components that catch JavaScript errors anywhere in their **child component tree**, log those errors, and display a fallback UI instead of crashing the entire app.

### The Problem (Without Error Boundaries)

```jsx
function BuggyComponent() {
  throw new Error("I crashed!"); // Uncaught error
}

function App() {
  return (
    <div>
      <h1>My App</h1>
      <BuggyComponent /> {/* ‚ùå Entire app crashes! */}
    </div>
  );
}

// Result: White screen of death üíÄ
```

**What happens:**

- Error thrown in `BuggyComponent`
- **Entire React tree unmounts**
- User sees blank screen
- No graceful degradation

---

### The Solution (With Error Boundaries)

```jsx
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    // Update state so next render shows fallback UI
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    // Log error to error reporting service
    console.error("Error caught:", error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      // Fallback UI
      return <h1>Something went wrong.</h1>;
    }

    return this.props.children;
  }
}

// Usage
function App() {
  return (
    <div>
      <h1>My App</h1>
      <ErrorBoundary>
        <BuggyComponent /> {/* ‚úÖ Error caught! App still works */}
      </ErrorBoundary>
    </div>
  );
}

// Result: Shows "Something went wrong" instead of crashing
```

---

## 2. How Error Boundaries Work

Error Boundaries use two lifecycle methods:

### A. `getDerivedStateFromError()` (Required)

**Purpose:** Update state to display fallback UI

```jsx
static getDerivedStateFromError(error) {
  // Called during "render" phase
  // Must be pure (no side effects)
  // Returns state update
  return { hasError: true, error };
}
```

**When it's called:** During the **render phase** after an error is thrown

**What it does:**

- ‚úÖ Updates component state
- ‚úÖ Triggers re-render with fallback UI
- ‚ùå NO side effects (logging, API calls)

---

### B. `componentDidCatch()` (Optional)

**Purpose:** Log error information, report to services

```jsx
componentDidCatch(error, errorInfo) {
  // Called during "commit" phase
  // Can have side effects
  console.error("Error:", error);
  console.error("Error Info:", errorInfo);

  // Log to error tracking service
  logErrorToService(error, errorInfo);
}
```

**When it's called:** During the **commit phase** (after DOM updates)

**What it does:**

- ‚úÖ Log errors to console
- ‚úÖ Send errors to monitoring service (Sentry, LogRocket)
- ‚úÖ Update analytics
- ‚úÖ Any side effects

**Parameters:**

- `error`: The error that was thrown
- `errorInfo`: Object with `componentStack` property (stack trace of where error occurred)

---

## 3. Basic Error Boundary Implementation

### Minimal Error Boundary

```jsx
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  render() {
    if (this.state.hasError) {
      return <h1>Something went wrong.</h1>;
    }

    return this.props.children;
  }
}
```

---

### Complete Error Boundary with Logging

```jsx
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      hasError: false,
      error: null,
      errorInfo: null,
    };
  }

  static getDerivedStateFromError(error) {
    // Update state to show fallback UI
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    // Log error details
    console.error("Error Boundary caught an error:", error);
    console.error("Component Stack:", errorInfo.componentStack);

    // Store error info in state (for display)
    this.setState({
      error,
      errorInfo,
    });

    // Log to error monitoring service
    // logErrorToSentry(error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return (
        <div style={{ padding: "20px", border: "2px solid red" }}>
          <h1>Oops! Something went wrong.</h1>
          <details style={{ whiteSpace: "pre-wrap" }}>
            <summary>Click for error details</summary>
            <p>
              <strong>Error:</strong> {this.state.error?.toString()}
            </p>
            <p>
              <strong>Stack Trace:</strong>
            </p>
            <code>{this.state.errorInfo?.componentStack}</code>
          </details>
        </div>
      );
    }

    return this.props.children;
  }
}
```

---

### Error Boundary with Reset Capability

```jsx
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    console.error(error, errorInfo);
  }

  resetErrorBoundary = () => {
    this.setState({ hasError: false });
  };

  render() {
    if (this.state.hasError) {
      return (
        <div>
          <h1>Something went wrong.</h1>
          <button onClick={this.resetErrorBoundary}>Try again</button>
        </div>
      );
    }

    return this.props.children;
  }
}
```

---

## 4. What Error Boundaries Catch

### ‚úÖ Error Boundaries CATCH:

1. **Errors during rendering**

   ```jsx
   function BuggyRender() {
     throw new Error("Render error");
     return <div>Hello</div>;
   }
   ```

2. **Errors in lifecycle methods**

   ```jsx
   componentDidMount() {
     throw new Error("Lifecycle error");
   }
   ```

3. **Errors in constructors**

   ```jsx
   constructor(props) {
     super(props);
     throw new Error("Constructor error");
   }
   ```

4. **Errors in child component tree**
   ```jsx
   <ErrorBoundary>
     <Parent>
       <Child /> {/* Error here is caught */}
     </Parent>
   </ErrorBoundary>
   ```

---

### ‚ùå Error Boundaries DO NOT CATCH:

1. **Event handlers** (use try/catch instead)

   ```jsx
   // ‚ùå NOT caught by Error Boundary
   function Button() {
     const handleClick = () => {
       throw new Error("Click error");
     };

     return <button onClick={handleClick}>Click</button>;
   }

   // ‚úÖ Use try/catch
   function Button() {
     const handleClick = () => {
       try {
         throw new Error("Click error");
       } catch (error) {
         console.error("Caught in handler:", error);
       }
     };

     return <button onClick={handleClick}>Click</button>;
   }
   ```

2. **Asynchronous code** (setTimeout, promises, async/await)

   ```jsx
   // ‚ùå NOT caught by Error Boundary
   function AsyncComponent() {
     useEffect(() => {
       setTimeout(() => {
         throw new Error("Async error"); // Not caught!
       }, 1000);
     }, []);

     return <div>Component</div>;
   }

   // ‚úÖ Use try/catch
   function AsyncComponent() {
     useEffect(() => {
       setTimeout(() => {
         try {
           throw new Error("Async error");
         } catch (error) {
           console.error("Caught async error:", error);
         }
       }, 1000);
     }, []);

     return <div>Component</div>;
   }
   ```

3. **Server-side rendering (SSR)**

   - Error Boundaries only work on client
   - SSR errors need server-side error handling

4. **Errors in the Error Boundary itself**

   ```jsx
   class ErrorBoundary extends React.Component {
     render() {
       if (this.state.hasError) {
         throw new Error("Error in boundary itself"); // ‚ùå Not caught!
       }
       return this.props.children;
   }
   ```

5. **Errors thrown in Error Boundary's own methods**
   ```jsx
   componentDidCatch(error, errorInfo) {
     throw new Error("Error while handling error"); // ‚ùå Not caught!
   }
   ```

---

## 5. Error Boundaries vs try/catch

| Feature            | Error Boundaries                   | try/catch           |
| ------------------ | ---------------------------------- | ------------------- |
| **Use case**       | React component errors             | Imperative code     |
| **Catches**        | Rendering, lifecycle, constructors | Any JavaScript code |
| **Event handlers** | ‚ùå No                              | ‚úÖ Yes              |
| **Async code**     | ‚ùå No                              | ‚úÖ Yes              |
| **Component type** | Class components only              | Anywhere            |
| **Fallback UI**    | ‚úÖ Yes                             | ‚ùå No (manual)      |

### Example: When to Use Each

```jsx
// ‚úÖ Use Error Boundary for component errors
<ErrorBoundary>
  <UserProfile userId={123} /> {/* Rendering errors caught */}
</ErrorBoundary>;

// ‚úÖ Use try/catch for event handlers
function SubmitButton() {
  const handleSubmit = async () => {
    try {
      await api.submitForm(data);
    } catch (error) {
      console.error("Submit failed:", error);
    }
  };

  return <button onClick={handleSubmit}>Submit</button>;
}

// ‚úÖ Use try/catch for async code
useEffect(() => {
  const fetchData = async () => {
    try {
      const data = await api.getData();
      setData(data);
    } catch (error) {
      setError(error);
    }
  };

  fetchData();
}, []);
```

---

## 6. Multiple Error Boundaries (Granular Error Handling)

Use multiple Error Boundaries for **different parts** of your app to isolate failures.

### Example: Granular Boundaries

```jsx
function App() {
  return (
    <div>
      {/* Top-level boundary (catch-all) */}
      <ErrorBoundary fallback={<ErrorPage />}>
        {/* Header boundary */}
        <ErrorBoundary fallback={<div>Header error</div>}>
          <Header />
        </ErrorBoundary>

        {/* Sidebar boundary */}
        <ErrorBoundary fallback={<div>Sidebar error</div>}>
          <Sidebar />
        </ErrorBoundary>

        {/* Main content boundary */}
        <ErrorBoundary fallback={<div>Content error</div>}>
          <MainContent />
        </ErrorBoundary>

        {/* Footer boundary */}
        <ErrorBoundary fallback={<div>Footer error</div>}>
          <Footer />
        </ErrorBoundary>
      </ErrorBoundary>
    </div>
  );
}
```

**Benefits:**

- ‚úÖ Isolated failures (sidebar error doesn't break header)
- ‚úÖ Better UX (only affected section shows error)
- ‚úÖ Easier debugging (know exactly where error occurred)

---

### Strategic Boundary Placement

```jsx
function Dashboard() {
  return (
    <div>
      {/* Critical: Protect entire route */}
      <ErrorBoundary fallback={<ErrorPage />}>
        {/* Less critical: Individual widgets can fail */}
        <ErrorBoundary fallback={<WidgetError />}>
          <StockWidget />
        </ErrorBoundary>

        <ErrorBoundary fallback={<WidgetError />}>
          <WeatherWidget />
        </ErrorBoundary>

        <ErrorBoundary fallback={<WidgetError />}>
          <NewsWidget />
        </ErrorBoundary>
      </ErrorBoundary>
    </div>
  );
}
```

---

## 7. Customizable Error Boundary

### Reusable Error Boundary with Props

```jsx
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }

  componentDidCatch(error, errorInfo) {
    // Use custom onError callback if provided
    if (this.props.onError) {
      this.props.onError(error, errorInfo);
    }
  }

  render() {
    if (this.state.hasError) {
      // Use custom fallback if provided
      if (this.props.fallback) {
        return this.props.fallback;
      }

      // Or use custom render function
      if (this.props.fallbackRender) {
        return this.props.fallbackRender(this.state.error);
      }

      // Default fallback
      return <h1>Something went wrong.</h1>;
    }

    return this.props.children;
  }
}

// Usage 1: Custom fallback component
<ErrorBoundary fallback={<CustomError />}>
  <App />
</ErrorBoundary>

// Usage 2: Custom render function
<ErrorBoundary fallbackRender={(error) => <div>Error: {error.message}</div>}>
  <App />
</ErrorBoundary>

// Usage 3: Custom error handler
<ErrorBoundary onError={(error, errorInfo) => logToSentry(error, errorInfo)}>
  <App />
</ErrorBoundary>
```

---

## 8. Logging Errors to Monitoring Services

### Integration with Sentry

```jsx
import * as Sentry from "@sentry/react";

class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    // Log to Sentry
    Sentry.withScope((scope) => {
      scope.setExtra("componentStack", errorInfo.componentStack);
      Sentry.captureException(error);
    });
  }

  render() {
    if (this.state.hasError) {
      return <h1>Something went wrong.</h1>;
    }

    return this.props.children;
  }
}
```

---

### Using Sentry's Built-in Error Boundary

```jsx
import * as Sentry from "@sentry/react";

// Initialize Sentry
Sentry.init({
  dsn: "YOUR_SENTRY_DSN",
  // ... other config
});

// Use Sentry's Error Boundary
function App() {
  return (
    <Sentry.ErrorBoundary fallback={<ErrorFallback />}>
      <YourApp />
    </Sentry.ErrorBoundary>
  );
}
```

---

### Custom Logging Service

```jsx
// logger.js
export function logError(error, errorInfo, context = {}) {
  // Log to console in development
  if (process.env.NODE_ENV === "development") {
    console.error("Error:", error);
    console.error("Error Info:", errorInfo);
    console.error("Context:", context);
  }

  // Send to logging service in production
  if (process.env.NODE_ENV === "production") {
    fetch("https://api.yourservice.com/errors", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        error: error.toString(),
        stack: error.stack,
        componentStack: errorInfo.componentStack,
        context,
        timestamp: new Date().toISOString(),
        userAgent: navigator.userAgent,
        url: window.location.href,
      }),
    });
  }
}

// ErrorBoundary.jsx
import { logError } from "./logger";

class ErrorBoundary extends React.Component {
  // ... constructor and getDerivedStateFromError

  componentDidCatch(error, errorInfo) {
    logError(error, errorInfo, {
      component: this.props.componentName,
      userId: this.props.userId,
    });
  }

  // ... render
}
```

---

## 9. Best Practices

### 1. Place Error Boundaries Strategically

```jsx
// ‚úÖ GOOD: Protect different sections independently
function App() {
  return (
    <>
      <ErrorBoundary fallback={<HeaderError />}>
        <Header />
      </ErrorBoundary>

      <ErrorBoundary fallback={<ContentError />}>
        <MainContent />
      </ErrorBoundary>
    </>
  );
}

// ‚ùå BAD: Single boundary for everything
function App() {
  return (
    <ErrorBoundary>
      <Header />
      <MainContent />
    </ErrorBoundary>
  );
}
```

---

### 2. Provide Helpful Fallback UI

```jsx
// ‚ùå BAD: Generic error
if (this.state.hasError) {
  return <div>Error</div>;
}

// ‚úÖ GOOD: Helpful error with actions
if (this.state.hasError) {
  return (
    <div className="error-container">
      <h1>Oops! Something went wrong.</h1>
      <p>We've been notified and are working on a fix.</p>
      <button onClick={() => window.location.reload()}>Reload Page</button>
      <button onClick={() => window.history.back()}>Go Back</button>
    </div>
  );
}
```

---

### 3. Always Log Errors

```jsx
componentDidCatch(error, errorInfo) {
  // ‚úÖ Always log for debugging
  console.error("Error:", error);
  console.error("Component Stack:", errorInfo.componentStack);

  // ‚úÖ Send to monitoring service
  logToMonitoringService(error, errorInfo);
}
```

---

### 4. Reset Error Boundaries When Appropriate

```jsx
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  // Reset when props change (e.g., navigation)
  componentDidUpdate(prevProps) {
    if (this.state.hasError && prevProps.location !== this.props.location) {
      this.setState({ hasError: false });
    }
  }

  render() {
    // ...
  }
}

// Usage with React Router
<Route path="/page">
  {(props) => (
    <ErrorBoundary location={props.location}>
      <Page />
    </ErrorBoundary>
  )}
</Route>;
```

---

### 5. Don't Catch Errors in Error Boundary Itself

```jsx
// ‚ùå BAD: Error in Error Boundary
class ErrorBoundary extends React.Component {
  componentDidCatch(error, errorInfo) {
    throw new Error("Error while handling error"); // ‚ùå NOT caught!
  }

  render() {
    if (this.state.hasError) {
      throw new Error("Error in fallback UI"); // ‚ùå NOT caught!
    }
    return this.props.children;
  }
}

// ‚úÖ GOOD: Wrap error handling in try/catch
class ErrorBoundary extends React.Component {
  componentDidCatch(error, errorInfo) {
    try {
      logToService(error, errorInfo);
    } catch (loggingError) {
      console.error("Failed to log error:", loggingError);
    }
  }

  render() {
    if (this.state.hasError) {
      // Keep fallback UI simple and safe
      return <h1>Something went wrong.</h1>;
    }
    return this.props.children;
  }
}
```

---

## 10. React Query Error Boundaries

React Query has built-in error boundary support:

```jsx
import { QueryErrorResetBoundary } from "@tanstack/react-query";

function App() {
  return (
    <QueryErrorResetBoundary>
      {({ reset }) => (
        <ErrorBoundary
          onReset={reset}
          fallbackRender={({ error, resetErrorBoundary }) => (
            <div>
              <h1>Error: {error.message}</h1>
              <button onClick={resetErrorBoundary}>Try again</button>
            </div>
          )}
        >
          <UserProfile />
        </ErrorBoundary>
      )}
    </QueryErrorResetBoundary>
  );
}
```

---

## 11. Testing Error Boundaries

### Test with React Testing Library

```jsx
import { render, screen } from "@testing-library/react";
import ErrorBoundary from "./ErrorBoundary";

function ThrowError() {
  throw new Error("Test error");
}

test("displays fallback UI when child throws error", () => {
  // Suppress console.error for cleaner test output
  const spy = jest.spyOn(console, "error");
  spy.mockImplementation(() => {});

  render(
    <ErrorBoundary fallback={<div>Error occurred</div>}>
      <ThrowError />
    </ErrorBoundary>
  );

  expect(screen.getByText("Error occurred")).toBeInTheDocument();

  spy.mockRestore();
});
```

---

## 12. Common Patterns

### Pattern 1: Route-level Error Boundaries

```jsx
import { Route, Routes } from "react-router-dom";

function App() {
  return (
    <Routes>
      <Route
        path="/users"
        element={
          <ErrorBoundary fallback={<UsersError />}>
            <Users />
          </ErrorBoundary>
        }
      />
      <Route
        path="/settings"
        element={
          <ErrorBoundary fallback={<SettingsError />}>
            <Settings />
          </ErrorBoundary>
        }
      />
    </Routes>
  );
}
```

---

### Pattern 2: Feature-level Boundaries

```jsx
function Dashboard() {
  return (
    <div className="dashboard">
      <ErrorBoundary name="charts">
        <Charts />
      </ErrorBoundary>

      <ErrorBoundary name="tables">
        <DataTables />
      </ErrorBoundary>

      <ErrorBoundary name="widgets">
        <Widgets />
      </ErrorBoundary>
    </div>
  );
}
```

---

### Pattern 3: Development vs Production Fallbacks

```jsx
class ErrorBoundary extends React.Component {
  // ... state and lifecycle methods

  render() {
    if (this.state.hasError) {
      if (process.env.NODE_ENV === "development") {
        // Show detailed error in development
        return (
          <div>
            <h1>Error</h1>
            <pre>{this.state.error?.toString()}</pre>
            <pre>{this.state.errorInfo?.componentStack}</pre>
          </div>
        );
      }

      // Show user-friendly error in production
      return (
        <div>
          <h1>Something went wrong.</h1>
          <p>We've been notified. Please try again later.</p>
        </div>
      );
    }

    return this.props.children;
  }
}
```

---

## 13. Interview Questions

### Q1: What are Error Boundaries?

**Answer:** Error Boundaries are special React components (class components) that catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI instead of crashing the entire app.

```jsx
<ErrorBoundary fallback={<ErrorMessage />}>
  <MyComponent />
</ErrorBoundary>
```

---

### Q2: Which lifecycle methods are used for Error Boundaries?

**Answer:**

1. **`getDerivedStateFromError(error)`**:

   - Called during render phase
   - Updates state to show fallback UI
   - Must be pure (no side effects)

2. **`componentDidCatch(error, errorInfo)`**:
   - Called during commit phase
   - Used for logging errors
   - Can have side effects

---

### Q3: What errors can Error Boundaries NOT catch?

**Answer:**

Error Boundaries **cannot** catch:

- ‚ùå Event handler errors (use try/catch)
- ‚ùå Async code (setTimeout, promises, async/await)
- ‚ùå Server-side rendering errors
- ‚ùå Errors thrown in Error Boundary itself

```jsx
// ‚ùå NOT caught by Error Boundary
<button onClick={() => { throw new Error(); }}>Click</button>

// ‚úÖ Use try/catch
<button onClick={() => {
  try {
    throw new Error();
  } catch (e) {
    console.error(e);
  }
}}>Click</button>
```

---

### Q4: Why can't you use Error Boundaries with function components?

**Answer:** Error Boundaries require two lifecycle methods (`getDerivedStateFromError` and `componentDidCatch`) which **only exist in class components**. There's no Hook equivalent yet (as of React 19).

However, you can **use** Error Boundaries in function components (as parents wrapping children).

---

### Q5: How do you handle errors in event handlers?

**Answer:** Use regular JavaScript `try/catch`:

```jsx
function Button() {
  const handleClick = async () => {
    try {
      await riskyOperation();
    } catch (error) {
      console.error("Error in handler:", error);
      // Show error to user
    }
  };

  return <button onClick={handleClick}>Click</button>;
}
```

---

### Q6: Should you have one or multiple Error Boundaries?

**Answer:** Use **multiple Error Boundaries** for granular error handling:

```jsx
<ErrorBoundary>
  {" "}
  {/* Top-level catch-all */}
  <ErrorBoundary>
    {" "}
    {/* Sidebar */}
    <Sidebar />
  </ErrorBoundary>
  <ErrorBoundary>
    {" "}
    {/* Main content */}
    <Content />
  </ErrorBoundary>
</ErrorBoundary>
```

**Benefits:**

- Isolated failures (sidebar error doesn't break content)
- Better UX (only affected section shows error)

---

### Q7: How do you reset an Error Boundary?

**Answer:** Add a reset method that clears error state:

```jsx
class ErrorBoundary extends React.Component {
  resetErrorBoundary = () => {
    this.setState({ hasError: false, error: null });
  };

  render() {
    if (this.state.hasError) {
      return (
        <div>
          <h1>Error occurred</h1>
          <button onClick={this.resetErrorBoundary}>Try again</button>
        </div>
      );
    }
    return this.props.children;
  }
}
```

---

### Q8: How do you log errors to a monitoring service?

**Answer:** Use `componentDidCatch()` to send errors to services like Sentry:

```jsx
componentDidCatch(error, errorInfo) {
  // Log to Sentry
  Sentry.withScope((scope) => {
    scope.setExtra("componentStack", errorInfo.componentStack);
    Sentry.captureException(error);
  });
}
```

---

### Q9: What's the difference between Error Boundaries and try/catch?

**Answer:**

| Error Boundaries                   | try/catch                  |
| ---------------------------------- | -------------------------- |
| React component errors             | Any JavaScript code        |
| Rendering, lifecycle, constructors | Event handlers, async code |
| Class components only              | Anywhere                   |
| Shows fallback UI                  | Manual error handling      |

---

### Q10: Can Error Boundaries catch errors in SSR?

**Answer:** No. Error Boundaries only work on the **client side**. For SSR, you need server-side error handling:

```jsx
// Server-side (Node.js/Next.js)
try {
  const html = ReactDOMServer.renderToString(<App />);
  res.send(html);
} catch (error) {
  console.error("SSR error:", error);
  res.status(500).send("Server error");
}
```

---

## 14. Best Practices Summary

### ‚úÖ Always Do:

1. **Use Error Boundaries** for component tree errors
2. **Log errors** to monitoring services (Sentry, LogRocket)
3. **Provide helpful fallback UI** with actions (reload, go back)
4. **Use multiple boundaries** for granular error handling
5. **Reset boundaries** on navigation or user action
6. **Test Error Boundaries** in your component tests

### ‚ùå Never Do:

1. **Rely on Error Boundaries for event handlers** (use try/catch)
2. **Rely on Error Boundaries for async code** (use try/catch)
3. **Throw errors in Error Boundary itself**
4. **Show technical stack traces to users** in production
5. **Forget to log errors** to monitoring services
6. **Use single top-level boundary** for entire app

### üéØ Advanced:

- Integrate with React Router for route-level error handling
- Use libraries like `react-error-boundary` for more features
- Implement retry logic with exponential backoff
- Track error frequency to identify problematic components
- Combine with Suspense for loading and error states

---

## Summary: Error Boundaries Checklist

When implementing error handling, ensure you:

- ‚úÖ Use Error Boundaries for component rendering errors
- ‚úÖ Implement both `getDerivedStateFromError()` and `componentDidCatch()`
- ‚úÖ Provide helpful fallback UI with recovery options
- ‚úÖ Log errors to monitoring services
- ‚úÖ Use try/catch for event handlers and async code
- ‚úÖ Place multiple boundaries strategically
- ‚úÖ Reset boundaries on navigation or user action
- ‚úÖ Understand what Error Boundaries can and cannot catch

Your error handling knowledge is interview-ready when you can explain:

1. What Error Boundaries are and how they work
2. The two lifecycle methods used (`getDerivedStateFromError`, `componentDidCatch`)
3. What errors they catch vs don't catch
4. Difference between Error Boundaries and try/catch
5. Why only class components can be Error Boundaries
6. Best practices for placement and fallback UI
7. How to integrate with error monitoring services
