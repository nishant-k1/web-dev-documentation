# Async Error Handling

Handling errors in asynchronous code requires different approaches than synchronous code.

---

## Why Try-Catch Doesn't Work with Promises

Try-catch **cannot catch errors** in Promise callbacks because:

- The error occurs **after** the try-catch block has finished executing
- Promises execute asynchronously, outside the synchronous call stack
- By the time the error happens, the try-catch is already gone

```javascript
// ❌ This won't catch the error
try {
  Promise.reject("error");
} catch (e) {
  console.log("caught", e); // Never executes
}
```

---

## Method 1: Promise `.catch()` Method

Use the `.catch()` method to handle errors in Promise chains.

```javascript
Promise.resolve("async fail")
  .then((response) => {
    throw new Error("#1 fail");
    return response;
  })
  .then((response) => {
    console.log(response); // Never executes
  })
  .catch((err) => {
    console.log(err); // Error caught here
  });
```

### Error Propagation in Promise Chains

Errors in a Promise chain **propagate down** until they reach a `.catch()` handler.

```javascript
Promise.resolve()
  .then(() => {
    throw new Error("Error 1");
  })
  .then(() => {
    console.log("This won't run");
  })
  .catch((err) => {
    console.log(err.message); // "Error 1"
  });
```

### Nested Promises

In nested promises, handle errors at each level:

```javascript
Promise.resolve()
  .then(() => {
    return Promise.resolve()
      .then(() => {
        throw new Error("Inner error");
      })
      .catch((err) => {
        // Handle inner error
        console.log("Inner:", err.message);
        throw err; // Re-throw to outer
      });
  })
  .catch((err) => {
    // Handle outer error
    console.log("Outer:", err.message);
  });
```

---

## Method 2: Async/Await with Try-Catch

Async/await makes asynchronous code look synchronous, allowing you to use try-catch.

```javascript
(async function () {
  try {
    await Promise.resolve("oopsie #1");
    await Promise.reject("oopsie #2"); // Error thrown here
  } catch (e) {
    console.log(e); // Error gets caught
  }
  console.log("is this still good"); // Executes after catch
})();
```

### Multiple Async Operations

```javascript
async function fetchData() {
  try {
    const user = await fetchUser();
    const posts = await fetchPosts(user.id);
    return { user, posts };
  } catch (error) {
    console.error("Failed to fetch data:", error);
    throw error; // Re-throw if needed
  }
}
```

### Handling Specific Errors

```javascript
async function processData() {
  try {
    const data = await fetchData();
    return process(data);
  } catch (error) {
    if (error instanceof TypeError) {
      // Handle TypeError
    } else if (error instanceof NetworkError) {
      // Handle NetworkError
    } else {
      // Handle other errors
      throw error;
    }
  }
}
```

---

## Method 3: Promise.all Error Handling

When using `Promise.all`, if any promise rejects, the entire operation fails.

```javascript
// ❌ If any promise fails, all fail
Promise.all([promise1, promise2, promise3])
  .then((results) => {
    // All succeeded
  })
  .catch((error) => {
    // Any one failed
  });
```

### Using Promise.allSettled

To handle errors individually:

```javascript
Promise.allSettled([promise1, promise2, promise3])
  .then((results) => {
    results.forEach((result, index) => {
      if (result.status === "fulfilled") {
        console.log(`Promise ${index} succeeded:`, result.value);
      } else {
        console.log(`Promise ${index} failed:`, result.reason);
      }
    });
  });
```

---

## Best Practices

### ✅ Do

```javascript
// Always handle promise rejections
async function fetchData() {
  try {
    const data = await apiCall();
    return data;
  } catch (error) {
    // Log and handle appropriately
    logError(error);
    return null; // Or throw, depending on use case
  }
}

// Use Promise.allSettled for independent operations
const results = await Promise.allSettled([
  fetchUser(),
  fetchPosts(),
  fetchComments()
]);
```

### ❌ Don't

```javascript
// Don't forget to handle rejections
async function badExample() {
  const data = await apiCall(); // What if this fails?
  return data;
}

// Don't mix error handling styles inconsistently
somePromise()
  .then(() => {})
  .catch(() => {}); // Good

anotherPromise()
  .then(() => {}) // Missing catch - bad!
```

---

## Related Topics

- [3. Try Catch.md](./3.%20Try%20Catch.md) - Synchronous error handling
- [8. Global Error Handlers.md](./8.%20Global%20Error%20Handlers.md) - Unhandled promise rejections
- [9. Best Practices.md](./9.%20Best%20Practices.md) - Error handling patterns
