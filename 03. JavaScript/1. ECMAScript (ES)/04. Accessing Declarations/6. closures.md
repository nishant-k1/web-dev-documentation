# Closures

A **closure** is created when a function **accesses variables from its outer (enclosing) lexical scope**, even after the outer function has finished executing. Closures enable functions to "remember" and access outer scope variables.

> ðŸ“– **Detailed Coverage:** [Closures Deep Dive](<../10. Execution Context, Hoisting, Scope and Closures/05.4. Closures.md>)

## What is a Closure?

A closure allows an inner function to **access declarations from outer scopes** even after the outer function has returned:

```javascript
function outer() {
  let outerVar = "I am from outer";

  function inner() {
    console.log(outerVar); // âœ… Accesses outer variable - closure!
  }

  return inner;
}

const innerFunc = outer(); // outer() has finished executing
innerFunc(); // "I am from outer" - still can access outerVar!
```

## How Closures Enable Accessing Declarations

### Key Concept

- **Lexical Scope**: Inner function can access outer variables **while** outer is running
- **Closure**: Inner function can access outer variables **even after** outer has finished

### Example: Closure vs No Closure

```javascript
// Without closure - cannot access after outer finishes
function outer() {
  let x = 10;
  function inner() {
    console.log(x); // Uses x, but...
  }
  inner(); // Called while outer is still running
}
outer(); // x is accessible here

// With closure - can access after outer finishes
function outer() {
  let x = 10;
  return function inner() {
    console.log(x); // Closure! Accesses x after outer finishes
  };
}
const innerFunc = outer(); // outer() finished, but...
innerFunc(); // âœ… Still can access x!
```

## Closures and Accessing Outer Declarations

### Example 1: Basic Closure

```javascript
function createCounter() {
  let count = 0; // Outer scope variable

  return function () {
    count++; // Accesses outer 'count' - closure
    return count;
  };
}

const counter = createCounter();
console.log(counter()); // 1 (accesses outer count)
console.log(counter()); // 2 (still accesses same outer count)
console.log(counter()); // 3
```

### Example 2: Multiple Closures

```javascript
function outer() {
  let x = 10;
  let y = 20;

  return {
    getX: function () {
      return x;
    }, // Closure over x
    getY: function () {
      return y;
    }, // Closure over y
    setX: function (val) {
      x = val;
    }, // Closure over x
  };
}

const obj = outer();
console.log(obj.getX()); // 10 (accesses outer x)
obj.setX(100);
console.log(obj.getX()); // 100 (still accessing same outer x)
```

### Example 3: Closure in Loops

```javascript
// Problem: All functions access same 'i'
for (var i = 0; i < 3; i++) {
  setTimeout(function () {
    console.log(i); // 3, 3, 3 (all access same i)
  }, 100);
}

// Solution: Closure captures each iteration's value
for (let i = 0; i < 3; i++) {
  setTimeout(function () {
    console.log(i); // 0, 1, 2 (each closure has its own i)
  }, 100);
}
```

## Closures and Scope Chain

Closures use the **scope chain** to access outer declarations:

```javascript
let global = "global";

function outer() {
  let outerVar = "outer";

  function inner() {
    let innerVar = "inner";
    console.log(innerVar); // Own scope
    console.log(outerVar); // Outer scope - closure!
    console.log(global); // Global scope - closure!
  }

  return inner;
}

const innerFunc = outer();
innerFunc(); // Can access outerVar and global via closure
```

## When Closures Are Created

Closures are created **automatically** when:

1. A function is defined inside another function (or block)
2. The inner function accesses variables from the outer scope
3. The inner function outlives the outer function

**Important:** Closures are created on **function definition**, not on return:

```javascript
function outer() {
  let x = 10;

  function inner() {
    console.log(x); // Closure created here (on definition)
  }

  // Return is NOT required for closure to exist
  inner(); // Closure still exists even without return
}

outer();
```

## Closures and Accessing Declarations - Key Points

### 1. Closures Preserve Access

```javascript
function outer() {
  let secret = "I am secret";

  return function () {
    return secret; // Closure preserves access to 'secret'
  };
}

const getSecret = outer();
console.log(getSecret()); // "I am secret" - still accessible!
```

### 2. Closures Create Private Variables

```javascript
function createBankAccount(initialBalance) {
  let balance = initialBalance; // "Private" variable

  return {
    getBalance: function () {
      return balance; // Closure - can access balance
    },
    deposit: function (amount) {
      balance += amount; // Closure - can modify balance
    },
  };
}

const account = createBankAccount(100);
console.log(account.getBalance()); // 100
account.deposit(50);
console.log(account.getBalance()); // 150
// balance is not directly accessible - closure provides controlled access
```

### 3. Closures in Event Handlers

```javascript
function setupButton(buttonId, message) {
  const button = document.getElementById(buttonId);

  button.addEventListener("click", function () {
    alert(message); // Closure - accesses outer 'message'
  });
}

setupButton("btn1", "Hello!");
setupButton("btn2", "World!");
// Each closure remembers its own 'message'
```

## Closures vs Lexical Scope

| Aspect          | Lexical Scope                    | Closure                                |
| --------------- | -------------------------------- | -------------------------------------- |
| **When**        | While outer function is running  | After outer function finishes          |
| **Access**      | Inner can access outer variables | Inner can still access outer variables |
| **Requirement** | Function defined inside another  | Function outlives outer function       |
| **Purpose**     | Normal variable access           | Persistent variable access             |

## Important Notes

1. **Closures are automatic** - Created whenever inner function accesses outer variables
2. **Return is NOT required** - Closure exists even if function isn't returned
3. **Closures preserve variables** - Outer variables remain in memory
4. **Each closure is independent** - Multiple closures = multiple variable instances
5. **Closures use scope chain** - Follows lexical scoping rules

## Summary

- **Closure** = Function that accesses outer scope variables after outer function finishes
- **Enables accessing** outer declarations even after outer scope is gone
- **Created automatically** when inner function accesses outer variables
- **Uses lexical scope** but persists beyond normal scope lifetime
- **Purpose**: Allows functions to "remember" and access outer scope variables
