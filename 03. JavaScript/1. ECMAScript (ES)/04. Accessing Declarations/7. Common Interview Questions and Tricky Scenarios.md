# Common Interview Questions and Tricky Scenarios

This document covers common interview questions and tricky scenarios related to accessing declarations, scope, hoisting, TDZ, and closures from a practical coding perspective.

> ðŸ“– **For deep technical explanations:** See [10. Execution Context, Hoisting, Scope and Closures/06. Tricky Questions](<../10. Execution Context, Hoisting, Scope and Closures/06. Tricky Questions.md>) for comprehensive interview questions with detailed explanations.

---

## Scope-Related Questions

### Q1: What will this code output?

```javascript
var x = 1;

function test() {
  console.log(x);
  var x = 2;
}

test();
```

**Answer:** `undefined`

**Explanation:**

- `var` is function-scoped and hoisted
- The declaration `var x` is hoisted to the top of the function
- During hoisting, `x` is initialized to `undefined`
- When `console.log(x)` executes, `x` is `undefined` (not the global `x = 1`)
- This is shadowing + hoisting behavior

---

### Q2: What's the difference between these two?

```javascript
// Example A
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100);
}

// Example B
for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100);
}
```

**Answer:**

- Example A: Prints `3, 3, 3` (all after loop completes)
- Example B: Prints `0, 1, 2` (each iteration's value)

**Explanation:**

- `var` is function-scoped, so there's only one `i` variable shared across all iterations
- `let` is block-scoped, so each iteration gets its own `i` variable
- The closure in Example A captures the same `i` variable
- The closure in Example B captures different `i` variables for each iteration

---

### Q3: What will this output?

```javascript
let a = 1;

function outer() {
  let a = 2;

  function inner() {
    console.log(a);
    let a = 3;
  }

  inner();
}

outer();
```

**Answer:** `ReferenceError: Cannot access 'a' before initialization`

**Explanation:**

- `let` declarations are hoisted but enter TDZ
- The `let a = 3` inside `inner()` shadows the outer `a = 2`
- When `console.log(a)` tries to access `a`, it's in TDZ
- TDZ prevents access before initialization

---

## Hoisting-Related Questions

### Q4: What's the output?

```javascript
console.log(a);
console.log(b);
console.log(c);

var a = 1;
let b = 2;
const c = 3;
```

**Answer:**

- `undefined` (a is hoisted and initialized to undefined)
- `ReferenceError` (b is in TDZ)
- `ReferenceError` (c is in TDZ)

**Explanation:**

- `var` is hoisted and initialized to `undefined`
- `let` and `const` are hoisted but enter TDZ until their declaration line

---

### Q5: Function hoisting - what's the output?

```javascript
foo();

function foo() {
  console.log("Function declaration");
}

foo();

var foo = function () {
  console.log("Function expression");
};

foo();
```

**Answer:**

- `"Function declaration"` (first call)
- `"Function declaration"` (second call)
- `"Function expression"` (third call)

**Explanation:**

- Function declarations are fully hoisted (can be called before declaration)
- `var foo` declaration is hoisted, but the assignment happens at runtime
- After `var foo = function() {...}`, `foo` is reassigned to the function expression

---

### Q6: Tricky hoisting with function and var

```javascript
var x = "global";

function test() {
  console.log(x);

  if (false) {
    var x = "local";
  }

  console.log(x);
}

test();
```

**Answer:**

- `undefined` (first console.log)
- `undefined` (second console.log)

**Explanation:**

- `var` is function-scoped, not block-scoped
- Even though `if (false)` never executes, `var x` is hoisted to the top of the function
- `x` is initialized to `undefined` during hoisting
- The assignment `x = "local"` never happens, so `x` remains `undefined`

---

## TDZ-Related Questions

### Q7: Why does this throw an error?

```javascript
function test() {
  console.log(typeof x);
  let x = 10;
}

test();
```

**Answer:** `ReferenceError: Cannot access 'x' before initialization`

**Explanation:**

- `typeof` usually returns `"undefined"` for undeclared variables
- But for variables in TDZ, it throws a `ReferenceError`
- This is because TDZ is a runtime error, not a value

---

### Q8: TDZ with class

```javascript
class MyClass {
  method() {
    return new MyClass();
  }
}

const instance = new MyClass();
```

**Answer:** Works fine

**But this doesn't:**

```javascript
const instance = new MyClass();

class MyClass {
  method() {
    return new MyClass();
  }
}
```

**Answer:** `ReferenceError: Cannot access 'MyClass' before initialization`

**Explanation:**

- Class declarations are hoisted but enter TDZ
- Must be declared before use

---

## Closure-Related Questions

### Q9: Classic closure loop problem

```javascript
var funcs = [];

for (var i = 0; i < 3; i++) {
  funcs.push(function () {
    console.log(i);
  });
}

funcs[0]();
funcs[1]();
funcs[2]();
```

**Answer:** `3, 3, 3`

**Explanation:**

- All functions share the same `i` variable (var is function-scoped)
- By the time functions execute, loop has finished, `i = 3`
- Each closure captures the same `i` reference

**Solutions:**

```javascript
// Solution 1: Use let (block scope)
for (let i = 0; i < 3; i++) {
  funcs.push(function () {
    console.log(i);
  });
}

// Solution 2: IIFE
for (var i = 0; i < 3; i++) {
  funcs.push(
    (function (j) {
      return function () {
        console.log(j);
      };
    })(i)
  );
}

// Solution 3: bind
for (var i = 0; i < 3; i++) {
  funcs.push(
    function (j) {
      console.log(j);
    }.bind(null, i)
  );
}
```

---

### Q10: Closure with setTimeout

```javascript
for (var i = 0; i < 3; i++) {
  setTimeout(function () {
    console.log(i);
  }, 100);
}
```

**Answer:** `3, 3, 3` (after 100ms)

**Explanation:**

- Same issue as Q9 - all closures share the same `i`
- By the time setTimeout callbacks execute, `i = 3`

**Solution:**

```javascript
// Use let
for (let i = 0; i < 3; i++) {
  setTimeout(function () {
    console.log(i);
  }, 100);
}

// Or IIFE
for (var i = 0; i < 3; i++) {
  (function (j) {
    setTimeout(function () {
      console.log(j);
    }, 100);
  })(i);
}
```

---

### Q11: Module pattern with closure

```javascript
function createCounter() {
  let count = 0;

  return {
    increment: function () {
      count++;
      return count;
    },
    decrement: function () {
      count--;
      return count;
    },
    getCount: function () {
      return count;
    },
  };
}

const counter1 = createCounter();
const counter2 = createCounter();

console.log(counter1.increment()); // ?
console.log(counter1.increment()); // ?
console.log(counter2.increment()); // ?
console.log(counter1.getCount()); // ?
```

**Answer:** `1, 2, 1, 2`

**Explanation:**

- Each call to `createCounter()` creates a new closure with its own `count` variable
- `counter1` and `counter2` have independent `count` variables
- This demonstrates data encapsulation via closures

---

## Shadowing-Related Questions

### Q12: Shadowing with var and let

```javascript
var x = 1;
let y = 2;

{
  var x = 3;
  let y = 4;
  console.log(x, y);
}

console.log(x, y);
```

**Answer:**

- Inside block: `3, 4`
- Outside block: `3, 2`

**Explanation:**

- `var x` is function-scoped, so `x = 3` reassigns the outer `x`
- `let y` is block-scoped, so `y = 4` shadows the outer `y` only inside the block
- Outside the block, outer `y = 2` is still accessible

---

### Q13: Parameter shadowing

```javascript
let value = "global";

function test(value) {
  console.log(value);
  value = "local";
  console.log(value);
}

test("parameter");
console.log(value);
```

**Answer:**

- `"parameter"` (parameter value)
- `"local"` (reassigned parameter)
- `"global"` (outer value unchanged)

**Explanation:**

- Function parameters are in the function's scope
- The parameter `value` shadows the global `value`
- Reassigning `value` inside the function doesn't affect the global variable

---

## Complex Scenarios

### Q14: Multiple scopes and closures

```javascript
let a = 1;

function outer() {
  let a = 2;

  function middle() {
    let a = 3;

    function inner() {
      console.log(a);
    }

    return inner;
  }

  return middle();
}

const fn = outer();
fn();
```

**Answer:** `3`

**Explanation:**

- Each function creates its own scope
- `inner()` uses lexical scoping to find `a`
- It finds `a = 3` in the nearest enclosing scope (`middle`)
- Closure preserves access to `middle`'s scope even after `middle` returns

---

### Q15: Hoisting + TDZ + Closure

```javascript
function test() {
  console.log(a);
  console.log(b);

  var a = 1;
  let b = 2;

  function inner() {
    console.log(a);
    console.log(b);
  }

  return inner;
}

const fn = test();
fn();
```

**Answer:**

- First `console.log(a)`: `undefined`
- First `console.log(b)`: `ReferenceError`
- Second `console.log(a)`: `1` (closure captures after assignment)
- Second `console.log(b)`: `2` (closure captures after initialization)

**Explanation:**

- `var a` is hoisted and initialized to `undefined`
- `let b` is in TDZ, causing `ReferenceError`
- Closure captures variables at the time the function is created
- When `inner` is called later, it accesses the values from when `test()` executed

---

## Real-World Patterns

### Q16: Event handlers in loops

```javascript
// Problem
const buttons = document.querySelectorAll("button");
for (var i = 0; i < buttons.length; i++) {
  buttons[i].addEventListener("click", function () {
    console.log("Button", i, "clicked");
  });
}
```

**Problem:** All buttons log the same `i` value (the final value after loop)

**Solution:**

```javascript
// Solution 1: Use let
for (let i = 0; i < buttons.length; i++) {
  buttons[i].addEventListener("click", function () {
    console.log("Button", i, "clicked");
  });
}

// Solution 2: IIFE
for (var i = 0; i < buttons.length; i++) {
  (function (index) {
    buttons[index].addEventListener("click", function () {
      console.log("Button", index, "clicked");
    });
  })(i);
}

// Solution 3: Use forEach
buttons.forEach((button, index) => {
  button.addEventListener("click", function () {
    console.log("Button", index, "clicked");
  });
});
```

---

### Q17: React useState with closures

```javascript
// Problem in React
function Component() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const interval = setInterval(() => {
      setCount(count + 1); // Problem: always uses initial count
    }, 1000);

    return () => clearInterval(interval);
  }, []); // Empty deps

  return <div>{count}</div>;
}
```

**Problem:** `count` is always `0` because closure captures initial value

**Solution:**

```javascript
// Solution: Use functional update
useEffect(() => {
  const interval = setInterval(() => {
    setCount((prev) => prev + 1); // Uses latest state
  }, 1000);

  return () => clearInterval(interval);
}, []);
```

---

## Summary

### Key Takeaways

1. **`var` is function-scoped** - hoisted and initialized to `undefined`
2. **`let`/`const` are block-scoped** - hoisted but in TDZ until initialization
3. **Function declarations** are fully hoisted and can be called before declaration
4. **Closures capture variables by reference** - be careful in loops
5. **TDZ prevents access** before initialization, even with `typeof`
6. **Shadowing** can create confusion - understand which variable you're accessing
7. **Scope chain** determines variable resolution, not call stack

### Common Patterns to Remember

- Use `let` in loops to avoid closure issues
- Use IIFE when you need `var` in loops with closures
- Understand TDZ to avoid `ReferenceError`
- Be aware of shadowing when debugging
- Closures capture variables at function creation time, not execution time

---

> ðŸ“– **For more advanced questions:** See [10. Execution Context, Hoisting, Scope and Closures/06. Tricky Questions](<../10. Execution Context, Hoisting, Scope and Closures/06. Tricky Questions.md>)
