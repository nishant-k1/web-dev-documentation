# Hoisting

**Hoisting** is JavaScript's behavior of moving declarations to the top of their scope during the Creation Phase of Execution Context. This affects **when and how you can access declarations** in your code.

> üìñ **Detailed Coverage:** [Hoisting Deep Dive](<../10. Execution Context, Hoisting, Scope and Closures/04.1. Hoisting.md>)

## What is Hoisting?

Hoisting allows you to **access some declarations before they appear in the code**, but the behavior varies by declaration type:

```javascript
// ‚úÖ Can access function before declaration
sayHello(); // "Hello!" (works)

function sayHello() {
  console.log("Hello!");
}

// ‚ùå Cannot access let/const before declaration
console.log(x); // ReferenceError (TDZ)
let x = 10;
```

## Hoisting Behavior by Declaration Type

| Declaration Type | Hoisted? | Initialized As | Can Access Before Declaration? |
| ---------------- | -------- | -------------- | ------------------------------ |
| `var`            | ‚úÖ Yes   | `undefined`    | ‚úÖ Yes (but `undefined`)       |
| `let`            | ‚úÖ Yes   | TDZ            | ‚ùå No (ReferenceError)         |
| `const`          | ‚úÖ Yes   | TDZ            | ‚ùå No (ReferenceError)         |
| `function`       | ‚úÖ Yes   | Full function  | ‚úÖ Yes (fully accessible)      |
| `class`          | ‚úÖ Yes   | TDZ            | ‚ùå No (ReferenceError)         |
| `import`         | ‚úÖ Yes   | Full value     | ‚úÖ Yes (fully accessible)      |

## How Hoisting Affects Accessing Declarations

### 1. Function Declarations - Fully Accessible

```javascript
// ‚úÖ Can call before declaration
greet(); // "Hello!"

function greet() {
  console.log("Hello!");
}
```

**Why it works:** Function declarations are **fully hoisted** - both the name and body are available.

### 2. `var` Declarations - Accessible but `undefined`

```javascript
// ‚úÖ Can access, but value is undefined
console.log(x); // undefined (not an error)
var x = 10;
console.log(x); // 10
```

**Why it works:** `var` is hoisted and initialized with `undefined` immediately.

### 3. `let` and `const` - Cannot Access (TDZ)

```javascript
// ‚ùå Cannot access before declaration
console.log(x); // ReferenceError: Cannot access 'x' before initialization
let x = 10;

console.log(y); // ReferenceError: Cannot access 'y' before initialization
const y = 20;
```

**Why it fails:** `let` and `const` are hoisted but remain in **Temporal Dead Zone (TDZ)** until the declaration line.

### 4. Class Declarations - Cannot Access (TDZ)

```javascript
// ‚ùå Cannot access before declaration
const obj = new MyClass(); // ReferenceError
class MyClass {}
```

**Why it fails:** Classes are hoisted but remain in TDZ, similar to `let`/`const`.

## Hoisting and Function Expressions

Function expressions are **NOT hoisted** as functions - only the variable is hoisted:

```javascript
// ‚ùå Error - variable is hoisted but function is not
sayHello(); // TypeError: sayHello is not a function

var sayHello = function () {
  console.log("Hello!");
};

// With let/const - also in TDZ
sayHi(); // ReferenceError
let sayHi = function () {
  console.log("Hi!");
};
```

## Hoisting in Different Scopes

### Global Scope

```javascript
console.log(globalVar); // undefined (var hoisted)
console.log(globalFunc()); // "Hello!" (function hoisted)
console.log(globalLet); // ReferenceError (let in TDZ)

var globalVar = 10;
function globalFunc() {
  return "Hello!";
}
let globalLet = 20;
```

### Function Scope

```javascript
function example() {
  console.log(funcVar); // undefined (var hoisted to function scope)
  console.log(funcFunc()); // "Hello!" (function hoisted)
  console.log(funcLet); // ReferenceError (let in TDZ)

  var funcVar = 10;
  function funcFunc() {
    return "Hello!";
  }
  let funcLet = 20;
}
```

### Block Scope

```javascript
{
  console.log(blockVar); // undefined (var hoisted to function/global scope)
  console.log(blockLet); // ReferenceError (let hoisted to block scope, TDZ)

  var blockVar = 10; // Function-scoped, not block-scoped
  let blockLet = 20; // Block-scoped
}
```

## Hoisting Order and Precedence

When multiple declarations share the same name, hoisting order matters:

```javascript
console.log(typeof myVar); // "function" (function takes precedence)

var myVar = 10;
function myVar() {
  return "Hello!";
}
```

**Order of precedence:**

1. Function declarations (highest)
2. `var` declarations
3. `let`/`const` declarations

## Practical Examples: Accessing Declarations

### Example 1: Function Hoisting

```javascript
// ‚úÖ Works - function is fully hoisted
calculate(5, 3); // 8

function calculate(a, b) {
  return a + b;
}
```

### Example 2: `var` Hoisting

```javascript
// ‚úÖ Works but returns undefined
console.log(x); // undefined
var x = 10;
console.log(x); // 10
```

### Example 3: `let`/`const` Hoisting (TDZ)

```javascript
// ‚ùå Fails - in TDZ
console.log(x); // ReferenceError
let x = 10;
```

### Example 4: Hoisting Trap

```javascript
var x = "outer";

function test() {
  console.log(x); // undefined (not "outer"!)
  var x = "inner"; // var is hoisted to function scope
}

test();
```

## Important Notes

1. **Only declarations are hoisted** - Initializations/assignments are not
2. **Hoisting happens during Creation Phase** - Before code execution
3. **Function declarations are fully hoisted** - Name and body available
4. **`var` is partially hoisted** - Name hoisted, initialized as `undefined`
5. **`let`/`const` are hoisted but in TDZ** - Cannot access until declaration
6. **Hoisting is per scope** - Each scope has its own hoisting

## Summary

- **Hoisting** = Declarations moved to top of scope during Creation Phase
- **Function declarations**: Fully accessible before declaration
- **`var`**: Accessible but `undefined` before declaration
- **`let`/`const`/`class`**: Hoisted but in TDZ (cannot access)
- **Purpose**: Allows accessing declarations before they appear in code (with limitations)
