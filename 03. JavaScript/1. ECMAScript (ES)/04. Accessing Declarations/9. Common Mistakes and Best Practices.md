# Common Mistakes and Best Practices

This document covers common mistakes developers make when accessing declarations, along with best practices to avoid these pitfalls.

---

## Common Mistakes

### 1. Using `var` in Loops (Closure Trap)

**‚ùå Mistake:**

```javascript
var funcs = [];

for (var i = 0; i < 3; i++) {
  funcs.push(function () {
    console.log(i); // All functions log 3
  });
}

funcs[0](); // 3
funcs[1](); // 3
funcs[2](); // 3
```

**Problem:** All closures share the same `i` variable because `var` is function-scoped.

**‚úÖ Solution 1: Use `let`**

```javascript
var funcs = [];

for (let i = 0; i < 3; i++) {
  funcs.push(function () {
    console.log(i); // Each function logs its own i
  });
}

funcs[0](); // 0
funcs[1](); // 1
funcs[2](); // 2
```

**‚úÖ Solution 2: IIFE (if you must use `var`)**

```javascript
var funcs = [];

for (var i = 0; i < 3; i++) {
  (function (j) {
    funcs.push(function () {
      console.log(j);
    });
  })(i);
}
```

---

### 2. Accessing Variables Before Declaration (TDZ)

**‚ùå Mistake:**

```javascript
console.log(x); // ReferenceError
let x = 10;
```

**Problem:** `let` and `const` are in TDZ until their declaration line.

**‚úÖ Solution: Declare before use**

```javascript
let x = 10;
console.log(x); // 10
```

**Note:** `var` doesn't have this issue (but has other problems):

```javascript
console.log(x); // undefined (not an error, but value is undefined)
var x = 10;
```

---

### 3. Assuming `var` is Block-Scoped

**‚ùå Mistake:**

```javascript
if (true) {
  var x = 1;
}

console.log(x); // 1 (not block-scoped!)
```

**Problem:** `var` is function-scoped, not block-scoped.

**‚úÖ Solution: Use `let` or `const`**

```javascript
if (true) {
  let x = 1;
}

console.log(x); // ReferenceError (correctly block-scoped)
```

---

### 4. Shadowing Without Understanding

**‚ùå Mistake:**

```javascript
let x = "global";

function test() {
  console.log(x); // ReferenceError
  let x = "local";
}

test();
```

**Problem:** Inner `x` shadows outer `x`, but it's in TDZ when `console.log` executes.

**‚úÖ Solution: Understand shadowing behavior**

```javascript
let x = "global";

function test() {
  let x = "local"; // Declare first
  console.log(x); // "local"
}

test();
console.log(x); // "global" (outer x unchanged)
```

---

### 5. Forgetting Block Scope in Switch Cases

**‚ùå Mistake:**

```javascript
switch (value) {
  case 1:
    let x = "one";
    break;
  case 2:
    let x = "two"; // SyntaxError: x already declared
    break;
}
```

**Problem:** All cases share the same scope without `{}`.

**‚úÖ Solution: Use block scope**

```javascript
switch (value) {
  case 1: {
    let x = "one";
    break;
  }
  case 2: {
    let x = "two"; // Different block, different x
    break;
  }
}
```

---

### 6. Using `typeof` on TDZ Variables

**‚ùå Mistake:**

```javascript
function test() {
  console.log(typeof x); // ReferenceError (not "undefined"!)
  let x = 10;
}

test();
```

**Problem:** `typeof` throws `ReferenceError` for TDZ variables, not `"undefined"`.

**‚úÖ Solution: Understand TDZ behavior**

```javascript
function test() {
  let x = 10;
  console.log(typeof x); // "number"
}

test();
```

**Note:** This only applies to `let`/`const`. `typeof` on undeclared variables returns `"undefined"`:

```javascript
console.log(typeof undeclaredVar); // "undefined" (no error)
```

---

### 7. Closure Capturing Loop Variables

**‚ùå Mistake:**

```javascript
const buttons = document.querySelectorAll("button");

for (var i = 0; i < buttons.length; i++) {
  buttons[i].addEventListener("click", function () {
    console.log("Button", i, "clicked"); // All log the same i
  });
}
```

**Problem:** All event handlers share the same `i` variable.

**‚úÖ Solution 1: Use `let`**

```javascript
for (let i = 0; i < buttons.length; i++) {
  buttons[i].addEventListener("click", function () {
    console.log("Button", i, "clicked"); // Each logs its own i
  });
}
```

**‚úÖ Solution 2: Use `forEach`**

```javascript
buttons.forEach((button, index) => {
  button.addEventListener("click", function () {
    console.log("Button", index, "clicked");
  });
});
```

---

### 8. React useState Closure Issue

**‚ùå Mistake:**

```javascript
function Component() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const interval = setInterval(() => {
      setCount(count + 1); // Always uses initial count (0)
    }, 1000);

    return () => clearInterval(interval);
  }, []); // Empty deps

  return <div>{count}</div>;
}
```

**Problem:** Closure captures initial `count` value (0), so it always increments from 0.

**‚úÖ Solution: Use functional update**

```javascript
useEffect(() => {
  const interval = setInterval(() => {
    setCount((prev) => prev + 1); // Uses latest state
  }, 1000);

  return () => clearInterval(interval);
}, []);
```

---

### 9. Assuming Hoisting Works the Same for All Declarations

**‚ùå Mistake:**

```javascript
console.log(a); // undefined
console.log(b); // ReferenceError
console.log(c); // ReferenceError

var a = 1;
let b = 2;
const c = 3;
```

**Problem:** Not understanding that `var`, `let`, and `const` hoist differently.

**‚úÖ Solution: Understand hoisting differences**

- `var`: Hoisted and initialized to `undefined`
- `let`/`const`: Hoisted but in TDZ until declaration

---

### 10. Accessing Variables Outside Their Scope

**‚ùå Mistake:**

```javascript
function test() {
  if (true) {
    let x = 1;
  }
  console.log(x); // ReferenceError
}

test();
```

**Problem:** Trying to access block-scoped variable outside its block.

**‚úÖ Solution: Declare in appropriate scope**

```javascript
function test() {
  let x;
  if (true) {
    x = 1;
  }
  console.log(x); // 1
}

test();
```

---

## Best Practices

### 1. Prefer `let` and `const` over `var`

**‚úÖ Best Practice:**

```javascript
// ‚úÖ Good
let count = 0;
const MAX_COUNT = 100;

// ‚ùå Avoid
var count = 0;
var MAX_COUNT = 100;
```

**Why:**

- Block scoping prevents accidental variable access
- TDZ prevents use before initialization
- No hoisting surprises
- Better for closures in loops

---

### 2. Use `const` by Default, `let` When Needed

**‚úÖ Best Practice:**

```javascript
// ‚úÖ Use const for values that don't change
const PI = 3.14159;
const config = { apiUrl: "https://api.example.com" };

// ‚úÖ Use let only when you need to reassign
let counter = 0;
counter++; // Reassignment needed

// ‚ùå Don't use let when const works
let name = "John"; // Should be const
```

**Why:**

- `const` prevents accidental reassignment
- Makes code intent clearer
- Helps catch bugs early

---

### 3. Declare Variables at the Top of Their Scope

**‚úÖ Best Practice:**

```javascript
function processData(data) {
  // ‚úÖ Declare all variables at the top
  let result = [];
  let isValid = true;
  let error = null;

  // Then use them
  if (!data) {
    isValid = false;
    error = "No data provided";
  } else {
    result = data.map((item) => item * 2);
  }

  return { result, isValid, error };
}
```

**Why:**

- Makes scope clear
- Avoids TDZ issues
- Easier to read and maintain

---

### 4. Use Block Scope to Isolate Temporary Variables

**‚úÖ Best Practice:**

```javascript
function calculateTotal(items) {
  let total = 0;

  for (const item of items) {
    // ‚úÖ Use block to isolate temporary calculations
    {
      let discount = item.price * 0.1;
      let finalPrice = item.price - discount;
      total += finalPrice;
    }
    // discount and finalPrice are cleaned up
  }

  return total;
}
```

**Why:**

- Prevents variable pollution
- Makes it clear which variables are temporary
- Prevents accidental reuse

---

### 5. Always Use Block Scope in Switch Cases

**‚úÖ Best Practice:**

```javascript
function getValue(type) {
  switch (type) {
    case "string": {
      let result = "text";
      return result.toUpperCase();
    }
    case "number": {
      let result = 42;
      return result * 2;
    }
    default: {
      let result = null;
      return result;
    }
  }
}
```

**Why:**

- Prevents variable name conflicts
- Each case has its own scope
- More maintainable

---

### 6. Use Descriptive Variable Names to Avoid Shadowing

**‚úÖ Best Practice:**

```javascript
// ‚úÖ Good: Descriptive names prevent shadowing confusion
let userCount = 0;

function processUsers(users) {
  let processedUserCount = 0;
  // Clear that these are different variables
}

// ‚ùå Avoid: Same names cause shadowing
let count = 0;

function process(data) {
  let count = 0; // Shadows outer count - confusing
}
```

**Why:**

- Reduces shadowing confusion
- Makes code more readable
- Easier to debug

---

### 7. Understand Closure Behavior in Loops

**‚úÖ Best Practice:**

```javascript
// ‚úÖ Good: Use let in loops
for (let i = 0; i < items.length; i++) {
  setTimeout(() => {
    console.log(items[i]); // Each closure has its own i
  }, 100);
}

// ‚úÖ Good: Use forEach
items.forEach((item, index) => {
  setTimeout(() => {
    console.log(item); // No closure issues
  }, 100);
});

// ‚ùå Avoid: var in loops with closures
for (var i = 0; i < items.length; i++) {
  setTimeout(() => {
    console.log(items[i]); // All closures share same i
  }, 100);
}
```

---

### 8. Minimize Global Scope Pollution

**‚úÖ Best Practice:**

```javascript
// ‚úÖ Good: Use modules or IIFE
(function () {
  let localVar = "not global";
  // Your code here
})();

// ‚úÖ Good: Use ES6 modules
// module.js
let localVar = "module-scoped";
export function doSomething() {
  // Use localVar
}

// ‚ùå Avoid: Polluting global scope
var globalVar = "pollution"; // Attached to window
```

**Why:**

- Prevents naming conflicts
- Better code organization
- Easier to maintain

---

### 9. Use Functional Updates in React for State

**‚úÖ Best Practice:**

```javascript
// ‚úÖ Good: Functional update
useEffect(() => {
  const interval = setInterval(() => {
    setCount((prev) => prev + 1); // Always uses latest state
  }, 1000);

  return () => clearInterval(interval);
}, []);

// ‚ùå Avoid: Direct value (closure issue)
useEffect(() => {
  const interval = setInterval(() => {
    setCount(count + 1); // Uses stale closure value
  }, 1000);

  return () => clearInterval(interval);
}, []);
```

---

### 10. Group Related Variables Together

**‚úÖ Best Practice:**

```javascript
function processOrder(order) {
  // ‚úÖ Group related variables
  let total = 0;
  let tax = 0;
  let discount = 0;

  // Then calculations
  discount = order.amount * 0.1;
  tax = (order.amount - discount) * 0.08;
  total = order.amount - discount + tax;

  return { total, tax, discount };
}
```

**Why:**

- Easier to understand
- Clearer code structure
- Easier to maintain

---

## Code Review Checklist

When reviewing code for declaration access issues, check:

- [ ] Are `let`/`const` used instead of `var`?
- [ ] Are variables declared before use?
- [ ] Are block-scoped variables accessed only within their blocks?
- [ ] Are loops using `let` when closures are involved?
- [ ] Are switch cases using `{}` for block scope?
- [ ] Are there any TDZ violations?
- [ ] Is shadowing intentional and clear?
- [ ] Are global variables minimized?
- [ ] Are closures capturing the intended values?
- [ ] Are React state updates using functional form when needed?

---

## Summary

### Common Mistakes to Avoid

1. ‚ùå Using `var` in loops with closures
2. ‚ùå Accessing variables before declaration (TDZ)
3. ‚ùå Assuming `var` is block-scoped
4. ‚ùå Shadowing without understanding
5. ‚ùå Forgetting block scope in switch cases
6. ‚ùå Using `typeof` on TDZ variables
7. ‚ùå Closure capturing loop variables incorrectly
8. ‚ùå React useState closure issues
9. ‚ùå Assuming all declarations hoist the same way
10. ‚ùå Accessing variables outside their scope

### Best Practices to Follow

1. ‚úÖ Prefer `let` and `const` over `var`
2. ‚úÖ Use `const` by default, `let` when needed
3. ‚úÖ Declare variables at the top of their scope
4. ‚úÖ Use block scope to isolate temporary variables
5. ‚úÖ Always use block scope in switch cases
6. ‚úÖ Use descriptive names to avoid shadowing confusion
7. ‚úÖ Understand closure behavior in loops
8. ‚úÖ Minimize global scope pollution
9. ‚úÖ Use functional updates in React
10. ‚úÖ Group related variables together

---

> üìñ **Related Topics:**
>
> - [7. Common Interview Questions and Tricky Scenarios](<./7. Common Interview Questions and Tricky Scenarios.md>) - More examples and solutions
> - [8. Block Scope in Different Contexts](<./8. Block Scope in Different Contexts.md>) - Understanding block scope
> - [4. TDZ](<./4. TDZ.md>) - Temporal Dead Zone details
> - [6. Closures](<./6. closures.md>) - Closure behavior
