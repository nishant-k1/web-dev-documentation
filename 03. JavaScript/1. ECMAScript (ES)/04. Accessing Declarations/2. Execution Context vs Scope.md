# Execution Context vs Scope

Execution Context and Scope are two related but distinct concepts in JavaScript. Understanding the difference is crucial for mastering JavaScript.

## Execution Context

- **Execution Context** is more about **object-based** execution environment.
- Execution Context is about the **value of `this`** and is determined by **how a function is called**.
- Execution Context says what's the value of the `this` keyword, which is a reference to the object that owns that current execution code.
- Execution Context is most often determined by how a function is invoked with the value of the `this` keyword.
- Execution Context is a **runtime concept** - it's created when code is executed.

### Key Characteristics of Execution Context

1. **Created at runtime** - When a function is called or code is executed
2. **Contains three components**:
   - Variable Environment (for `var` and function declarations)
   - Lexical Environment (for `let`, `const`, `class`, `import`)
   - `this` binding
3. **Manages execution** - Controls how code runs
4. **Has a lifecycle** - Creation Phase â†’ Execution Phase

### Types of Execution Context

1. **Global Execution Context (GEC)**

   - Created when script starts
   - One per program
   - `this` = global object (window/global)

2. **Function Execution Context (FEC)**

   - Created when function is called
   - One per function call
   - `this` = depends on how function is called

3. **Module Execution Context**
   - Created when module is imported
   - One per module
   - `this` = undefined (strict mode)

## Scope

- **Scope** refers to the **accessibility or visibility** of variables, functions, and objects in some particular part of your code during runtime.
- Scope is a **lexical (static) concept** - determined by where code is written.
- Scope determines **where variables can be accessed** from.

### Key Characteristics of Scope

1. **Determined at write-time** - Based on where code is written in source code
2. **Container of variables** - Defines which variables are accessible
3. **Lexical structure** - Based on code structure, not execution
4. **Scope chain** - Chain of scopes from inner to outer

### Types of Scope

1. **Global Scope** - Top-level scope
2. **Module Scope** - Scope within ES6 modules
3. **Function Scope** - Scope within functions
4. **Block Scope** - Scope within blocks `{}`

## Key Differences

| Aspect            | Execution Context                                 | Scope                             |
| ----------------- | ------------------------------------------------- | --------------------------------- |
| **Nature**        | Runtime concept                                   | Lexical (static) concept          |
| **Determined by** | How function is called                            | Where code is written             |
| **Main concern**  | `this` binding, execution environment             | Variable accessibility            |
| **Created**       | When code executes                                | When code is written              |
| **Changes**       | With each function call                           | Fixed based on code structure     |
| **Contains**      | Variable Environment, Lexical Environment, `this` | Variables and their accessibility |

## Relationship Between Execution Context and Scope

### How They Work Together

1. **Execution Context provides the environment** where code runs
2. **Scope determines which variables are accessible** in that environment
3. **Lexical Environment** (part of Execution Context) implements scope

### Example

```javascript
let globalVar = "global";

function outer() {
  let outerVar = "outer";

  function inner() {
    let innerVar = "inner";
    console.log(innerVar, outerVar, globalVar);
  }

  inner(); // Creates new Function Execution Context
}

outer(); // Creates new Function Execution Context
```

**What happens:**

1. **Scope (Lexical/Static):**

   - `inner()` has access to: `innerVar` (own scope), `outerVar` (outer scope), `globalVar` (global scope)
   - This is determined by **where the code is written**

2. **Execution Context (Runtime):**
   - When `outer()` is called â†’ Function Execution Context is created
   - When `inner()` is called â†’ Another Function Execution Context is created
   - Each context has its own `this` binding and environment
   - This is determined by **how functions are called**

## Practical Examples

### Example 1: Scope vs Execution Context

```javascript
let x = "global";

function test() {
  console.log(x); // Scope: accesses global x (lexical)
  console.log(this); // Execution Context: this binding (runtime)
}

test(); // Execution Context: this = window/global
```

### Example 2: Same Scope, Different Execution Contexts

```javascript
let count = 0;

function increment() {
  count++; // Same scope (global)
  console.log(this); // Different Execution Context (this binding)
}

increment(); // this = window
increment.call({}); // this = {}
// Scope is the same, but Execution Context (this) is different
```

### Example 3: Different Scopes, Same Execution Context Type

```javascript
function outer() {
  let x = "outer"; // Function scope

  function inner() {
    let y = "inner"; // Function scope (different from outer)
    console.log(x, y); // Access via scope chain
  }

  inner(); // Both create Function Execution Contexts
}

outer();
```

## Important Distinctions

### 1. Scope Chain vs Call Stack

- **Scope Chain**: Determined by lexical structure (where code is written)
- **Call Stack**: Determined by execution order (how functions are called)

```javascript
function a() {
  let x = "a";
  b();
}

function b() {
  console.log(x); // Scope: looks in global scope (where b is written)
  // Call Stack: b was called from a, but scope doesn't care
}

let x = "global";
a(); // Prints "global" (not "a")
```

### 2. `this` Binding vs Variable Access

- **`this` binding**: Part of Execution Context, determined at runtime
- **Variable access**: Part of Scope, determined at write-time

```javascript
let name = "global";

const obj = {
  name: "object",
  getName: function () {
    console.log(this.name); // Execution Context: this = obj
    console.log(name); // Scope: accesses global name
  },
};

obj.getName(); // "object" (this) and "global" (scope)
```

## Summary

- **Execution Context**: Runtime environment that manages execution, `this` binding, and provides Variable/Lexical Environments
- **Scope**: Lexical (static) concept that determines variable accessibility based on where code is written
- **They work together**: Execution Context provides the runtime environment, Scope determines what's accessible in that environment
- **Key difference**: Execution Context is about **how code runs** (runtime), Scope is about **where variables are accessible** (lexical)

> ðŸ“– **For detailed Execution Context internals:** See [10. Execution Context, Hoisting, Scope and Closures](<../10. Execution Context, Hoisting, Scope and Closures/>) for comprehensive coverage of Execution Context components, lifecycle, and internal mechanisms.
