# FP Core Principles: Function Composition

- It is an idea that any sort of composition that we do should be obvious.
- `pipe` is just reverse order of operation as in `compose`.
- We can choose whatever between compose and pipe based on our choice of readability.

---

## What is Function Composition?

Function composition is the process of combining two or more functions to produce a new function. The output of one function becomes the input of the next.

---

## Basic Example

```javascript
const compose = (f, g) => (data) => f(g(data));
const pipe = (f, g) => (data) => g(f(data));
const multiplyBy3 = (num) => num * 3;
const absolute = (num) => Math.abs(num);
const multiplyBy3AndAbsolute = compose(multiplyBy3, absolute);
multiplyBy3AndAbsolute(-50);
```

---

## Compose vs Pipe

### Compose (Right to Left)

```js
const compose = (f, g) => (x) => f(g(x));

// Usage: compose(f, g)(x) = f(g(x))
const add1 = (x) => x + 1;
const multiply2 = (x) => x * 2;

const addThenMultiply = compose(multiply2, add1);
addThenMultiply(5); // multiply2(add1(5)) = multiply2(6) = 12
```

### Pipe (Left to Right)

```js
const pipe = (f, g) => (x) => g(f(x));

// Usage: pipe(f, g)(x) = g(f(x))
const addThenMultiply = pipe(add1, multiply2);
addThenMultiply(5); // multiply2(add1(5)) = multiply2(6) = 12
```

---

## Multiple Functions

### Compose Multiple

```js
const compose =
  (...fns) =>
  (x) =>
    fns.reduceRight((acc, fn) => fn(acc), x);

const add1 = (x) => x + 1;
const multiply2 = (x) => x * 2;
const subtract3 = (x) => x - 3;

const transform = compose(subtract3, multiply2, add1);
transform(5); // subtract3(multiply2(add1(5))) = subtract3(multiply2(6)) = subtract3(12) = 9
```

### Pipe Multiple

```js
const pipe =
  (...fns) =>
  (x) =>
    fns.reduce((acc, fn) => fn(acc), x);

const transform = pipe(add1, multiply2, subtract3);
transform(5); // subtract3(multiply2(add1(5))) = subtract3(multiply2(6)) = subtract3(12) = 9
```

---

## Real-World Example

```js
const users = [
  { name: "John", age: 25, active: true },
  { name: "Jane", age: 30, active: false },
  { name: "Bob", age: 20, active: true },
];

const isActive = (user) => user.active;
const getName = (user) => user.name;
const uppercase = (str) => str.toUpperCase();

// Compose functions to get active user names in uppercase
const getActiveUserNames = pipe(
  (users) => users.filter(isActive),
  (users) => users.map(getName),
  (names) => names.map(uppercase)
);

getActiveUserNames(users); // ["JOHN", "BOB"]
```

---

## Benefits

1. **Readability**: Code reads like a pipeline of transformations
2. **Reusability**: Small functions can be composed in different ways
3. **Testability**: Each function can be tested independently
4. **Maintainability**: Easy to add, remove, or modify steps

---

## Interview Points

- Function composition combines simple functions to build complex ones
- `compose` applies functions right-to-left, `pipe` applies left-to-right
- Composition promotes code reusability and readability
- It's a fundamental concept in functional programming
- Libraries like Ramda and Lodash provide composition utilities
