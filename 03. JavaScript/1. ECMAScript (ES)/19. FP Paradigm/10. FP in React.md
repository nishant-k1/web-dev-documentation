# Functional Programming in React

React has embraced functional programming principles, especially with the introduction of hooks.

---

## Key FP Concepts in React

1. **Functional Components = Pure Functions**
2. **Pure Functions**
3. **useMemo / useCallback / useReducer**
4. **Component Composition (HOCs, hooks)**
5. **Avoiding side effects with useEffect**

---

## 1. Functional Components as Pure Functions

Functional components should ideally be pure functions - same props in, same output out.

```jsx
// Pure functional component
function UserCard({ name, age }) {
  return (
    <div>
      <h2>{name}</h2>
      <p>Age: {age}</p>
    </div>
  );
}
```

---

## 2. Pure Functions in React

Keep components and utility functions pure:

```jsx
// Pure function
function calculateTotal(items) {
  return items.reduce((sum, item) => sum + item.price, 0);
}

// Used in component
function Cart({ items }) {
  const total = calculateTotal(items); // Pure calculation
  return <div>Total: ${total}</div>;
}
```

---

## 3. useMemo for Memoization

Memoize expensive calculations:

```jsx
function ExpensiveComponent({ data }) {
  const processedData = useMemo(() => {
    // Expensive computation
    return data.map((item) => expensiveTransform(item));
  }, [data]);

  return <div>{/* Use processedData */}</div>;
}
```

---

## 4. useCallback for Function Memoization

Memoize callback functions:

```jsx
function Parent({ items }) {
  const handleClick = useCallback((id) => {
    // Handle click
  }, []); // Dependencies

  return items.map((item) => <Child key={item.id} onClick={handleClick} />);
}
```

---

## 5. useReducer for State Management

Functional state updates with reducers:

```jsx
function reducer(state, action) {
  switch (action.type) {
    case "increment":
      return { count: state.count + 1 };
    case "decrement":
      return { count: state.count - 1 };
    default:
      return state;
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, { count: 0 });
  return (
    <div>
      <button onClick={() => dispatch({ type: "increment" })}>+</button>
      <span>{state.count}</span>
    </div>
  );
}
```

---

## 6. Component Composition

Compose components functionally:

```jsx
// Higher-Order Component (HOC)
function withAuth(Component) {
  return function AuthenticatedComponent(props) {
    const isAuthenticated = useAuth();
    if (!isAuthenticated) return <Login />;
    return <Component {...props} />;
  };
}

// Custom Hooks for Composition
function useUserData(userId) {
  const [user, setUser] = useState(null);
  // Fetch logic
  return user;
}
```

---

## 7. Avoiding Side Effects with useEffect

Isolate side effects:

```jsx
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);

  useEffect(() => {
    // Side effect isolated here
    fetchUser(userId).then(setUser);
  }, [userId]);

  // Rest of component is pure
  return user ? <div>{user.name}</div> : <Loading />;
}
```

---

## 8. Immutability in React

Always use immutable updates:

```jsx
// ❌ Mutation
function updateUser(users, id, newName) {
  users.find((u) => u.id === id).name = newName;
  return users;
}

// ✅ Immutability
function updateUser(users, id, newName) {
  return users.map((user) =>
    user.id === id ? { ...user, name: newName } : user
  );
}
```

---

## Best Practices

1. **Keep components pure**: Same props → same output
2. **Isolate side effects**: Use `useEffect` for I/O operations
3. **Use immutability**: Always create new objects/arrays
4. **Memoize expensive operations**: Use `useMemo` and `useCallback`
5. **Compose with hooks**: Create reusable custom hooks
6. **Functional state updates**: Use reducers for complex state

---

## Interview Points

- React functional components align with FP principles
- Hooks enable functional patterns (useMemo, useCallback, useReducer)
- Side effects should be isolated in useEffect
- Immutability is crucial for React state management
- Component composition follows FP composition patterns
- Redux reducers must be pure functions
- Custom hooks enable functional composition
