# Composition vs Inheritance: Deep Dive

A comprehensive guide to understanding composition and inheritance, their trade-offs, and when to use each approach in JavaScript.

---

## üéØ Core Concepts

### Inheritance: "is-a" Relationship

**Definition:** A child class inherits properties and methods from a parent class, creating an "is-a" relationship.

```js
// Dog IS A Animal
class Animal {
  eat() {
    console.log("Eating");
  }
}

class Dog extends Animal {
  bark() {
    console.log("Woof!");
  }
}

const dog = new Dog();
dog.eat(); // Inherited from Animal
dog.bark(); // Own method
```

**Characteristics:**

- Tight coupling between parent and child
- Changes in parent affect all children
- Creates hierarchy
- Code reuse via inheritance

---

### Composition: "has-a" Relationship

**Definition:** An object contains or uses other objects to achieve functionality, creating a "has-a" relationship.

```js
// Dog HAS capabilities (eat, bark)
const canEat = {
  eat() {
    console.log("Eating");
  },
};

const canBark = {
  bark() {
    console.log("Woof!");
  },
};

const dog = {
  ...canEat,
  ...canBark,
  name: "Buddy",
};

dog.eat(); // From canEat
dog.bark(); // From canBark
```

**Characteristics:**

- Loose coupling
- Flexible and changeable
- No hierarchy
- Code reuse via composition

---

## ‚öñÔ∏è Detailed Comparison

### 1. Coupling

**Inheritance: Tight Coupling**

```js
class Vehicle {
  start() {
    console.log("Starting engine");
  }

  stop() {
    console.log("Stopping engine");
  }
}

class Car extends Vehicle {
  drive() {
    this.start();
    console.log("Driving");
  }
}

// Problem: Car is tightly coupled to Vehicle
// If Vehicle.start() changes, Car is affected
// If we want to change how Car starts, we're limited
```

**Composition: Loose Coupling**

```js
const engine = {
  start() {
    console.log("Starting engine");
  },
  stop() {
    console.log("Stopping engine");
  },
};

const car = {
  engine,
  drive() {
    this.engine.start();
    console.log("Driving");
  },
};

// Benefit: Can swap engine implementation
const electricEngine = {
  start() {
    console.log("Starting electric motor");
  },
  stop() {
    console.log("Stopping electric motor");
  },
};

car.engine = electricEngine; // Easy to change
```

**Winner:** Composition (more flexible)

---

### 2. Fragile Base Class Problem

**Inheritance: Fragile Base Class**

```js
class Collection {
  constructor() {
    this.items = [];
  }

  add(item) {
    this.items.push(item);
  }

  // Later, we add this method
  addAll(items) {
    items.forEach((item) => this.add(item)); // Calls add()
  }
}

class Set extends Collection {
  add(item) {
    if (!this.items.includes(item)) {
      this.items.push(item); // Override to prevent duplicates
    }
  }
}

// Problem: addAll() calls add(), which Set overrides
// But addAll() might not work correctly with Set's add()
const mySet = new Set();
mySet.addAll([1, 2, 2, 3]); // Might add duplicates if not careful
```

**Composition: No Fragile Base**

```js
const collection = {
  items: [],
  add(item) {
    this.items.push(item);
  },
  addAll(items) {
    items.forEach((item) => this.add(item));
  },
};

const setBehavior = {
  add(item) {
    if (!this.items.includes(item)) {
      this.items.push(item);
    }
  },
};

const mySet = {
  items: [],
  ...setBehavior,
  addAll(items) {
    items.forEach((item) => this.add(item)); // Uses setBehavior.add
  },
};

// No fragile base class - each behavior is independent
```

**Winner:** Composition (avoids fragile base class)

---

### 3. Flexibility

**Inheritance: Rigid Structure**

```js
// Problem: What if we need a flying car?
class Vehicle {
  drive() {}
}

class Car extends Vehicle {
  drive() {}
}

class Airplane extends Vehicle {
  fly() {}
}

// Flying car? Can't inherit from both!
// class FlyingCar extends Car, Airplane { } // ‚ùå Not possible
```

**Composition: Flexible**

```js
const driving = {
  drive() {
    console.log("Driving");
  },
};

const flying = {
  fly() {
    console.log("Flying");
  },
};

// Easy to combine
const flyingCar = {
  ...driving,
  ...flying,
};

flyingCar.drive(); // ‚úÖ
flyingCar.fly(); // ‚úÖ
```

**Winner:** Composition (more flexible)

---

### 4. Code Reuse

**Inheritance: Reuse via Hierarchy**

```js
class Animal {
  eat() {}
  sleep() {}
}

class Dog extends Animal {
  // Gets eat() and sleep() for free
  bark() {}
}

class Cat extends Animal {
  // Gets eat() and sleep() for free
  meow() {}
}
```

**Composition: Reuse via Mixing**

```js
const canEat = {
  eat() {},
};

const canSleep = {
  sleep() {},
};

const canBark = {
  bark() {},
};

const canMeow = {
  meow() {},
};

const dog = {
  ...canEat,
  ...canSleep,
  ...canBark,
};

const cat = {
  ...canEat,
  ...canSleep,
  ...canMeow,
};
```

**Winner:** Tie (both enable code reuse, different approaches)

---

## üéØ When to Use Inheritance

### 1. Clear "is-a" Relationship

**Use inheritance when:**

- Relationship is truly "is-a"
- Hierarchy is stable and won't change
- All subclasses need all parent methods
- You have a well-defined taxonomy

**Example: UI Components**

```js
class Component {
  constructor(element) {
    this.element = element;
  }

  render() {
    throw new Error("Must implement render()");
  }

  mount() {
    document.body.appendChild(this.element);
  }
}

class Button extends Component {
  constructor(text) {
    super(document.createElement("button"));
    this.element.textContent = text;
  }

  render() {
    this.mount();
  }
}

class Input extends Component {
  constructor(type) {
    super(document.createElement("input"));
    this.element.type = type;
  }

  render() {
    this.mount();
  }
}

// Button IS A Component
// Input IS A Component
// Clear hierarchy, stable
```

---

### 2. Shared Implementation

**Use inheritance when:**

- Multiple classes share significant implementation
- You want to avoid code duplication
- Shared code is unlikely to change

**Example: Game Entities**

```js
class Entity {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.health = 100;
  }

  move(dx, dy) {
    this.x += dx;
    this.y += dy;
  }

  takeDamage(amount) {
    this.health -= amount;
    if (this.health <= 0) {
      this.die();
    }
  }

  die() {
    console.log("Entity died");
  }
}

class Player extends Entity {
  constructor(x, y, name) {
    super(x, y);
    this.name = name;
  }

  attack(target) {
    target.takeDamage(10);
  }
}

class Enemy extends Entity {
  constructor(x, y, type) {
    super(x, y);
    this.type = type;
  }

  attack(target) {
    target.takeDamage(5);
  }
}

// Both Player and Enemy share Entity implementation
// Inheritance makes sense here
```

---

### 3. Polymorphism Needed

**Use inheritance when:**

- You need polymorphic behavior
- Same interface, different implementations
- Working with collections of different types

**Example: Shape Hierarchy**

```js
class Shape {
  area() {
    throw new Error("Must implement area()");
  }

  perimeter() {
    throw new Error("Must implement perimeter()");
  }
}

class Circle extends Shape {
  constructor(radius) {
    super();
    this.radius = radius;
  }

  area() {
    return Math.PI * this.radius ** 2;
  }

  perimeter() {
    return 2 * Math.PI * this.radius;
  }
}

class Rectangle extends Shape {
  constructor(width, height) {
    super();
    this.width = width;
    this.height = height;
  }

  area() {
    return this.width * this.height;
  }

  perimeter() {
    return 2 * (this.width + this.height);
  }
}

// Polymorphism: Same interface, different implementations
const shapes = [new Circle(5), new Rectangle(4, 6)];

shapes.forEach((shape) => {
  console.log(shape.area()); // Works for both types
});
```

---

## üéØ When to Use Composition

### 1. Need Flexibility

**Use composition when:**

- Requirements might change
- You need to combine behaviors dynamically
- You want to avoid tight coupling

**Example: Character Abilities**

```js
// Composition: Mix and match abilities
const canWalk = {
  walk() {
    console.log("Walking");
  },
};

const canFly = {
  fly() {
    console.log("Flying");
  },
};

const canSwim = {
  swim() {
    console.log("Swimming");
  },
};

// Create different combinations
const human = {
  ...canWalk,
  name: "John",
};

const bird = {
  ...canWalk,
  ...canFly,
  name: "Eagle",
};

const duck = {
  ...canWalk,
  ...canFly,
  ...canSwim,
  name: "Duck",
};

// Easy to add/remove abilities
const superHuman = {
  ...canWalk,
  ...canFly,
  ...canSwim,
  name: "Superman",
};
```

---

### 2. Avoiding Deep Hierarchies

**Use composition when:**

- Inheritance would create deep hierarchies
- You want to avoid the fragile base class problem
- You need to change behavior without affecting parent

**Example: Instead of Deep Inheritance**

```js
// ‚ùå Deep inheritance (problematic)
class Animal {}
class Mammal extends Animal {}
class Dog extends Mammal {}
class Puppy extends Dog {}
class GoldenRetrieverPuppy extends Puppy {} // Too deep!

// ‚úÖ Composition (better)
const behaviors = {
  eat: () => console.log("Eating"),
  sleep: () => console.log("Sleeping"),
  play: () => console.log("Playing"),
};

const dog = {
  ...behaviors,
  name: "Buddy",
  age: 2,
};

const puppy = {
  ...behaviors,
  name: "Max",
  age: 0.5,
  play: () => console.log("Playing extra hard!"), // Override if needed
};
```

---

### 3. React Component Composition

**Use composition in React:**

- Children prop
- Render props
- Higher-order components (HOCs)
- Custom hooks

**Example: React Composition**

```js
// Composition with children
function Layout({ children, header, footer }) {
  return (
    <div className="layout">
      {header && <header>{header}</header>}
      <main>{children}</main>
      {footer && <footer>{footer}</footer>}
    </div>
  );
}

function App() {
  return (
    <Layout header={<Header />} footer={<Footer />}>
      <Content />
    </Layout>
  );
}

// Composition with hooks
function useAuth() {
  const [user, setUser] = useState(null);
  // Auth logic
  return { user, login, logout };
}

function useUserData(userId) {
  const [data, setData] = useState(null);
  // Fetch logic
  return data;
}

function UserProfile({ userId }) {
  const { user } = useAuth(); // Compose auth
  const userData = useUserData(userId); // Compose data
  return <div>{user?.name}</div>;
}
```

---

## üîÑ Mixins: Alternative to Inheritance

**Mixins** are a way to share code without inheritance.

### Object Mixins

```js
// Define mixins
const canEat = {
  eat() {
    console.log("Eating");
  },
};

const canSleep = {
  sleep() {
    console.log("Sleeping");
  },
};

// Apply mixins
function createAnimal(name) {
  return {
    name,
    ...canEat,
    ...canSleep,
  };
}

const dog = createAnimal("Buddy");
dog.eat(); // ‚úÖ
dog.sleep(); // ‚úÖ
```

### Function Mixins

```js
// Function mixins
function withEat(target) {
  return {
    ...target,
    eat() {
      console.log("Eating");
    },
  };
}

function withSleep(target) {
  return {
    ...target,
    sleep() {
      console.log("Sleeping");
    },
  };
}

// Compose mixins
const dog = withSleep(
  withEat({
    name: "Buddy",
  })
);

dog.eat(); // ‚úÖ
dog.sleep(); // ‚úÖ
```

### Class Mixins (Advanced)

```js
// Mixin function
function withEat(Base) {
  return class extends Base {
    eat() {
      console.log("Eating");
    }
  };
}

function withSleep(Base) {
  return class extends Base {
    sleep() {
      console.log("Sleeping");
    }
  };
}

// Apply mixins
class Animal {
  constructor(name) {
    this.name = name;
  }
}

const Dog = withSleep(withEat(Animal));

const dog = new Dog("Buddy");
dog.eat(); // ‚úÖ
dog.sleep(); // ‚úÖ
```

---

## üéØ Real-World Examples

### Example 1: E-commerce System

**Inheritance Approach:**

```js
class Product {
  constructor(name, price) {
    this.name = name;
    this.price = price;
  }

  getPrice() {
    return this.price;
  }
}

class DigitalProduct extends Product {
  download() {
    console.log("Downloading...");
  }
}

class PhysicalProduct extends Product {
  ship() {
    console.log("Shipping...");
  }
}
```

**Composition Approach:**

```js
const productBase = {
  getPrice() {
    return this.price;
  },
};

const downloadable = {
  download() {
    console.log("Downloading...");
  },
};

const shippable = {
  ship() {
    console.log("Shipping...");
  },
};

// Compose products
const digitalProduct = {
  name: "E-book",
  price: 9.99,
  ...productBase,
  ...downloadable,
};

const physicalProduct = {
  name: "Book",
  price: 19.99,
  ...productBase,
  ...shippable,
};

// What if we need a product that's both?
const hybridProduct = {
  name: "Book + E-book",
  price: 24.99,
  ...productBase,
  ...downloadable,
  ...shippable,
};
```

**Winner:** Composition (more flexible for hybrid products)

---

### Example 2: React Patterns

**Inheritance (Legacy - Not Recommended):**

```js
class BaseComponent extends React.Component {
  state = {
    loading: false,
    error: null,
  };

  setLoading(loading) {
    this.setState({ loading });
  }

  setError(error) {
    this.setState({ error });
  }
}

class UserList extends BaseComponent {
  // Inherits loading/error state
  render() {
    if (this.state.loading) return <Spinner />;
    if (this.state.error) return <Error />;
    return <div>Users</div>;
  }
}
```

**Composition (Modern - Recommended):**

```js
// Custom hook (composition)
function useLoading() {
  const [loading, setLoading] = useState(false);
  return { loading, setLoading };
}

function useError() {
  const [error, setError] = useState(null);
  return { error, setError };
}

// Compose in component
function UserList() {
  const { loading, setLoading } = useLoading();
  const { error, setError } = useError();

  if (loading) return <Spinner />;
  if (error) return <Error />;
  return <div>Users</div>;
}
```

**Winner:** Composition (React's recommended approach)

---

## ‚ö†Ô∏è Common Pitfalls

### Pitfall 1: Inheritance for Everything

**Mistake:**

```js
// Overusing inheritance
class Calculator {
  add(a, b) {
    return a + b;
  }
}

class ScientificCalculator extends Calculator {
  sin(x) {
    return Math.sin(x);
  }
}

class GraphingCalculator extends ScientificCalculator {
  plot() {}
}

// Problem: Tight coupling, hard to change
```

**Better:**

```js
// Use composition
const basicOps = {
  add(a, b) {
    return a + b;
  },
  subtract(a, b) {
    return a - b;
  },
};

const scientificOps = {
  sin(x) {
    return Math.sin(x);
  },
  cos(x) {
    return Math.cos(x);
  },
};

const calculator = {
  ...basicOps,
  ...scientificOps,
};
```

---

### Pitfall 2: Composition When Inheritance Makes Sense

**Mistake:**

```js
// Awkward composition for clear hierarchy
const animalBehaviors = {
  eat() {},
  sleep() {},
};

const dogBehaviors = {
  ...animalBehaviors,
  bark() {},
};

// Problem: Loses the natural "is-a" relationship
```

**Better:**

```js
// Inheritance makes sense here
class Animal {
  eat() {}
  sleep() {}
}

class Dog extends Animal {
  bark() {}
}

// Clear "Dog IS A Animal" relationship
```

---

### Pitfall 3: Not Using Both When Appropriate

**Mistake:**

```js
// Trying to force one paradigm
class Everything {
  // Mixing concerns awkwardly
}
```

**Better:**

```js
// Use inheritance for entities
class User {
  // User-specific logic
}

// Use composition for utilities
const validators = {
  validateEmail(email) {},
  validatePassword(password) {},
};

const user = new User();
user.validators = validators; // Compose when needed
```

---

## üìã Decision Framework

### Ask These Questions:

1. **Is there a clear "is-a" relationship?**

   - YES ‚Üí Consider inheritance
   - NO ‚Üí Use composition

2. **Will the hierarchy change?**

   - NO ‚Üí Inheritance might work
   - YES ‚Üí Use composition

3. **Do you need to combine multiple behaviors?**

   - YES ‚Üí Use composition
   - NO ‚Üí Either works

4. **Is the relationship stable?**

   - YES ‚Üí Inheritance might work
   - NO ‚Üí Use composition

5. **Do you need polymorphism?**
   - YES ‚Üí Inheritance is natural
   - NO ‚Üí Composition might be simpler

---

## üéØ Best Practices

### 1. Favor Composition Over Inheritance

**React Team's Recommendation:**

> "We recommend using composition instead of inheritance to reuse code between components."

**Why:**

- More flexible
- Easier to change
- Avoids fragile base class
- Better for testing

---

### 2. Use Inheritance for Stable Hierarchies

**When inheritance is appropriate:**

- Clear taxonomy (Animal ‚Üí Mammal ‚Üí Dog)
- Stable relationship (won't change)
- Shared implementation (significant code reuse)
- Polymorphism needed

---

### 3. Use Composition for Flexibility

**When composition is appropriate:**

- Requirements might change
- Need to combine behaviors
- Want to avoid coupling
- Building React components

---

### 4. Combine Both When Needed

**Example:**

```js
// Inheritance for entities
class User extends BaseEntity {
  // User-specific logic
}

// Composition for capabilities
const canEdit = {
  edit() {},
};

const canDelete = {
  delete() {},
};

// Combine
class AdminUser extends User {
  constructor() {
    super();
    Object.assign(this, canEdit, canDelete);
  }
}
```

---

## üìù Summary

**Key Takeaways:**

1. **Inheritance:**

   - "is-a" relationship
   - Tight coupling
   - Good for stable hierarchies
   - Enables polymorphism

2. **Composition:**

   - "has-a" relationship
   - Loose coupling
   - Good for flexibility
   - Preferred in modern React

3. **General Rule:**

   - **Favor composition over inheritance**
   - Use inheritance when relationship is truly "is-a" and stable
   - Use composition for flexibility and changeability

4. **React:**
   - Use composition (hooks, children, render props)
   - Avoid class component inheritance
   - Compose behaviors, not inherit them

---

> üí° **Pro Tip:** In interviews, mention "Favor composition over inheritance" (Gang of Four principle). Show you understand both and can choose appropriately. Demonstrate React composition patterns (hooks, children).
