# OOP Core Principles: Inheritance

- JavaScript uses prototypal inheritance rather than classical class-based inheritance, but ES6 introduced class syntax which is syntactic sugar over the prototype chain.
- One class (child) inherits methods/properties from another (parent).
- The core aspect of Object Oriented Programming is inheritance
- Inheritance means passing knowledge down
- Constructor function inside the class gets run every time we instantiate the class or use the new keyword
- When doing object oriented programming using Class and instance of class is created every time we use class to create a new Object using new keyword. The Object is called the instance of that class.
- Class with the new keyword is called its instance and the process is called instantiation.
- Every time we instantiate a class, its constructor runs.
- Class keyword is just a prototypal inheritance.

---

## What is Inheritance?

Inheritance is a mechanism where a child class (subclass) inherits properties and methods from a parent class (superclass), allowing code reuse and the creation of hierarchical relationships.

---

## Problem Without Inheritance

```javascript
// Problem if we don't use class inheritance.
class Elf {
  constructor(name, weapon) {
    this.name = name;
    this.weapon = weapon;
  }
  attack() {
    return "attack with " + this.weapon;
  }
}

const fiona = new Elf("Fiona", "Stones");
const ogre = { ...fiona }; // fiona and ogre points to different memory locations in javascript engine. We also lost the prototypal inheritance, because ogre isn't in the same prototypal chain.
console.log(ogre === fiona); // returns false
ogre.attack(); // returns error
```

---

## Solution: Class Inheritance

```javascript
// class inheritance.
class Character {
  constructor(name, weapon) {
    this.name = name;
    this.weapon = weapon;
  }
  attack() {
    return "attack with " + this.weapon;
  }
}

class Elf extends Character {
  // Elf has now prototype chain up to the Character
  constructor(name, weapon, type) {
    super(name, weapon); // calls the constructor of the parent class
    console.log(this);
    this.type = type;
  }
}

const fiona = new Elf("Fiona", "Stones", "house");
fiona.attack();

class Ogre extends Character {
  // Ogre has now prototype chain up to the Character
  constructor(name, weapon, color) {
    super(name, weapon); // calls the constructor of the parent class
    console.log(this);
    this.color = color;
  }
  makeFort() {
    // it is similar to Ogre.prototype.makeFort
    return this.name + " make fort";
  }
}

const shrek = new Ogre("Shrek", "sticks", "black");
shrek.makeFort();

console.log(fiona instanceof shrek); // returns false
console.log(fiona instanceof Character); // returns true
```

---

## Key Points

- In JavaScript, objects inherit from objects, there's no actual class while in languages like Java classes are a thing and class inherits from the class
- Languages like Java and C++ copy objects when extend a class while JavaScript link is created between objects and objects gets referenced to the same memory when a class extends another class so JavaScript provides some efficiency in terms of memory over other languages that uses class like Java and C++.

---

## Prototype

Every JavaScript object has an internal link to another object called its prototype, accessible via `__proto__` or `Object.getPrototypeOf(obj)`.

```js
const person = { name: "Nishant" };
console.log(person.__proto__ === Object.prototype); // true
```

Let us assume prototype of object A is B, then B is called prototype of object A. It means A inherits properties and methods from B.

When we say "B is the prototype of A" we mean:

```js
Object.getPrototypeOf(A) === B; // true
```

A is a "child" (or inheriting object) of B, but JavaScript does not have a special name for A from B's perspective. But A is just an object that inherits from B — we can casually call it a child, inheritor, or instance.

| Relationship | Description                                                                         |
| ------------ | ----------------------------------------------------------------------------------- |
| B → A        | B is the **prototype** of A                                                         |
| A → B        | A is a **"descendant"**, "child", or "instance-like" object — but **not prototype** |

### What That Implies

1. **Property / method lookup:**
   When you do `A.someProp`, the engine looks for someProp on A itself. If it's not there, it climbs to B. If B doesn't have it, it climbs to B's prototype, and so on, until it hits null. This climb/mechanism is the prototype chain, and that's how inheritance happens.

2. **Shared, not copied:**
   Nothing gets duplicated or cloned from B into A; the properties live on B. If `B.count = 0`, every object that prototypes from B "sees" that same count slot unless they shadow it with their own own-property.

3. **Dynamic:**
   Because the reference is live, if you later add `B.newMethod = …`, all objects inheriting from B immediately "inherit" it too.

### `Prototype` vs. `__proto__` vs. `.prototype`

| Term                         | Meaning                                                              |
| ---------------------------- | -------------------------------------------------------------------- |
| `obj.__proto__`              | Refers to the prototype of the object                                |
| `Function.prototype`         | Property of constructor functions — used when creating new instances |
| `Class.prototype`            | Where instance methods live                                          |
| `Object.getPrototypeOf(obj)` | Preferred over `__proto__` (standard)                                |

### What is the Prototype Chain?

If a property/method is not found on an object, JavaScript looks up the prototype chain until it finds it — or reaches null.

```js
const obj = {};
obj.toString(); // Found on Object.prototype

// Chain: obj → Object.prototype → null
```

### JavaScript Has Two Kinds of "Prototypes"

1. Regular `prototype` and `Function.prototype`
2. When you define a function, it gets a `.prototype` property (NOT the same as [[Prototype]]).
3. This is used only when you create objects using `new` (you're using a function as a constructor with new).
4. The `.prototype` property exists only on functions.

| #     | Context                          | What "prototype" refers to                                                                                          |
| ----- | -------------------------------- | ------------------------------------------------------------------------------------------------------------------- |
| **1** | When we say `A inherits from B`  | B is the **prototype** of A → i.e., `Object.getPrototypeOf(A) === B`                                                |
| **2** | When dealing with a **function** | `Function.prototype` is an object that will become the prototype of any object created by that function using `new` |

---

## Prototypal Inheritance

Prototypal inheritance is a way in which JavaScript objects can inherit properties and methods from their prototypes. Prototypal Inheritance is object getting access to the properties and methods of another object.

- Array gets access to the methods and properties of Object.
- Function gets access to the methods and properties of Object.
- There is no class in javascript. It's just a syntactic sugar.
- Prototypal inheritance is unique to JavaScript and is not found in other programming languages.
- JavaScript uses prototypal inheritance while other programming languages use classical inheritance.

### In JavaScript, Every Object Has a Prototype

A prototype is an object from which the current object inherits properties and methods. It allows objects to share behavior and reduce memory consumption.

```javascript
const array = [];
array.__proto__; // returns base Array
array.__proto__.__proto__; // returns base Object
```

```javascript
function a() {}
a.__proto__; // returns base Function
a.__proto__.__proto__; // returns base Object
```

```javascript
const obj = {};
obj.__proto__; // returns base Object
```

### Method Borrowing vs Prototypal Inheritance

If we had no prototypal feature then we'd need to borrow methods to keep our code DRY:

```javascript
let dragon = {
  name: "Tanya",
  fire: true,
  fight() {
    return 5;
  },
  sing() {
    return `I am ${this.name}, the breather of fire`;
  },
};

let lizard = {
  name: "kiki",
  fight() {
    return 1;
  },
};

const singLizard = dragon.sing.bind(lizard); // method borrowing
singLizard(); // returns I am Kiki, the breather of fire
```

Prototypal feature makes it easy to use the methods and properties of another object (without the need of borrowing):

```javascript
let dragon = {
  name: "Tanya",
  fire: true,
  fight() {
    return 5;
  },
  sing() {
    return `I am ${this.name}, the breather of fire`;
  },
};

let lizard = {
  name: "kiki",
  fight() {
    return 1;
  },
};

lizard.__proto__ = dragon; // We shouldn't really use it. It's bad for performance. Actually we should never use it.
lizard.sing(); // we can use sing method of dragon for lizard now.
```

**Important Notes:**

- Here, dragon is prototype of lizard; means lizard inherit from dragon
- The first created tank is called prototype, the next tanks are created from the prototype inheriting all its features.
- We should not use `__proto__` for prototypal inheritance. Never manually assign prototype chain and create that chaining ourselves. It can mess up javascript compiler badly.
- `.__proto__`: We shouldn't really use it. It's bad for performance. Actually we should never use it. There are different other ways to inherit when it comes to prototypal inheritance.
- Prototypes are useful because we can have objects with properties that point to the same place in the memory thus being more efficient.

### hasOwnProperty

`hasOwnProperty` method of object gives us the list of properties of that object which does not get inherited from prototypal chain.

```javascript
// Eg:1
const obj = {
  name: "Sally",
};

obj.hasOwnProperty("name"); // returns true
obj.hasOwnProperty("hasOwnProperty"); // returns false because obj has this property inherited from up the prototypal chain.

// Eg:2
function a() {}
a.hasOwnProperty("call"); // returns false because a function object has this property inherited from up the prototypal chain.
a.hasOwnProperty("apply"); // returns false because a function object has this property inherited from up the prototypal chain.
a.hasOwnProperty("bind"); // returns false because a function object has this property inherited from up the prototypal chain.
```

### Key Concepts

- The object whose properties/methods are inherited is called a `prototype`
- Every object has `.__proto__` property and every object can be a `prototype`. In other words every `prototype` has `.__proto__` property.
- `prototype` is up the prototypal chain with respect to the object who is inheriting its properties.
- `.__proto__` property of an object links to the properties of the object up the prototypal chain.
- `.__proto__` is simply a reference or a pointer to up the chain prototypal object.
- `.__proto__` points to the prototype up the chain.
- In other words `.__proto__` links to the properties of the object's prototype. `.__proto__` ----> `prototype`

```javascript
const obj = {
  name: "Sally",
};
obj.__proto__; // returns Object.prototype which is one step up the prototypal chain here it is `Object` i.e. {constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, …}
obj.prototype; // returns undefined; every object is kind of a prototype for the object one step down the prototypal chain.
Object.prototype; // returns {constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, …}

Object.prototype.__proto__; // returns null
```

### Creating Our Own Prototypes

```javascript
const human = {
  mortal: true,
};

const socrates = Object.create(human);
socrates.age = 45;
console.log(socrates.mortal); // returns true because using Object.create, we created a prototypal chain.
```

### Prototype as Property (Not Objects)

- Only functions have the `prototype` property
- The thing that contains the `prototype` object is always a function
- In the code below if we do `someObj.prototype` then it will return undefined because only functions (special objects) contain literally a `prototype` property

```javascript
const someObj = {
  name: "nishant",
};
someObj.prototype; // returns undefined
```

- Only functions (special objects) and every function (special objects) contain prototype property

```javascript
function someFun() {}

someFun.prototype; // returns {constructor: ƒ}
someFun.__proto__; // returns ƒ () { [native code] }
someFun.prototype.__proto__; // returns base Object
```

- `prototype` is all though a property on all functions but we never use it.
- Only time we use `prototype` when we use what we call constructor functions.
- Constructor functions usually start with a capital letter and they contain the actual blueprint or prototype what we use.

- When we do `const obj = {}`, underneath the hood JavaScript has to create that object and in order to create that object JavaScript uses object constructor.
- Every function has a prototype property and it references to an object used to attach properties that will be inherited by objects further down the prototypal chain. The last/top object in the chain is the built in `Object.prototype`
- `Object` is a function because it has the prototype.
- `Object.prototype` is the base object which is the last object up the prototypal chain.

### Conclusion

- Everything in JavaScript is an object.
- Array and Functions in JavaScript are special objects and they inherit their properties through the prototypal chain from the base object.
- The `prototype` property has the `__proto__` property inside of it that links higher up to the next prototypal chain
- `__proto__` always points to the `prototype`
- Only functions have the `prototype` property
- With the help of prototypes we avoid repeating ourselves. Code is DRY and thus memory efficient.

### `__proto__` vs `prototype`

- `__proto__` is a property that every object in JavaScript has. It points to the object's prototype.
- `prototype` is a property that functions have. It's used when creating objects using the new keyword. The prototype is the object that will become the prototype for instances created using that function as a constructor.

---

## Interview Points

- Inheritance allows code reuse by enabling child classes to inherit from parent classes
- JavaScript uses prototypal inheritance (object-to-object) rather than classical inheritance
- The `extends` keyword in ES6 classes provides syntactic sugar over prototypal inheritance
- The prototype chain enables property/method lookup up the inheritance hierarchy
- `super()` is used to call the parent class constructor
- Inheritance should be used carefully to avoid tight coupling and fragile base class problems
