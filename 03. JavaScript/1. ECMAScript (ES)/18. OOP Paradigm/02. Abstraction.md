# OOP Core Principles: Abstraction

- Abstraction means just hiding the complexity from the user that is creating simpler interfaces such as "hey I'll take care of the class and there you go, you have a class with all the properties now all you do is instantiate a class and there you go, you have all the properties and methods of that class already in for you."
- The idea of abstraction says, "hey, here are the methods and properties that you can use. Don't worry about anything else, I'll do all the calculations behind the scenes."
- This reduces complexity because we can just see the methods and understand what this class can do.
- The idea of abstraction also helps when we have private variables and private methods.

---

## What is Abstraction?

Abstraction is the concept of hiding the internal implementation details and showing only the essential features or functionality to the user. It focuses on **what** an object does rather than **how** it does it.

---

## Benefits of Abstraction

1. **Simplifies Complexity**: Users only need to know the interface, not the implementation
2. **Reduces Cognitive Load**: Hides unnecessary details from the user
3. **Improves Maintainability**: Internal changes don't affect code that uses the abstraction
4. **Enhances Security**: Prevents direct access to sensitive implementation details
5. **Promotes Reusability**: Abstract interfaces can be used across different implementations

---

## Abstraction in JavaScript

### Example: Car Class

```js
class Car {
  constructor(make, model) {
    this.make = make;
    this.model = model;
    this.engine = this.#initializeEngine(); // Private method
  }

  // Public interface - what users interact with
  start() {
    this.#checkFuel();
    this.#igniteEngine();
    return "Car started";
  }

  stop() {
    this.#shutDownEngine();
    return "Car stopped";
  }

  // Private methods - implementation details hidden
  #initializeEngine() {
    // Complex engine initialization logic
    return { status: "ready" };
  }

  #checkFuel() {
    // Fuel checking logic
  }

  #igniteEngine() {
    // Engine ignition logic
  }

  #shutDownEngine() {
    // Engine shutdown logic
  }
}

const myCar = new Car("Toyota", "Camry");
myCar.start(); // User only needs to know start() method
// Internal engine details are hidden
```

---

## Abstraction vs Encapsulation

| Aspect      | Abstraction                         | Encapsulation                        |
| ----------- | ----------------------------------- | ------------------------------------ |
| **Focus**   | Hiding complexity                   | Bundling data and methods            |
| **Purpose** | Show only essential features        | Protect data from external access    |
| **Level**   | Design level (what)                 | Implementation level (how)           |
| **Example** | Car.start() - user doesn't know how | Private fields prevent direct access |

---

## Real-World Examples

### 1. Array Methods

```js
const arr = [1, 2, 3];
arr.map((x) => x * 2); // User doesn't need to know how map() is implemented
```

### 2. Fetch API

```js
fetch("/api/data") // User doesn't need to know HTTP protocol details
  .then((res) => res.json())
  .then((data) => console.log(data));
```

### 3. DOM Manipulation

```js
element.addEventListener("click", handler); // Hides event loop complexity
```

---

## Interview Points

- Abstraction hides implementation details and exposes only essential features
- It simplifies complex systems by providing a clean, simple interface
- JavaScript achieves abstraction through classes, interfaces (TypeScript), and well-designed APIs
- Abstraction works hand-in-hand with encapsulation to create maintainable code
- Good abstraction makes code easier to understand and use
