# Async Function Declarations (async function)

Async functions are a way to write asynchronous code that looks synchronous. They are declared using the `async` keyword before the `function` keyword. Introduced in ES2017, async functions make working with Promises easier.

## Syntax

```js
async function functionName() {
  // Function body
  await promise;
  return value;
}
```

## Key Characteristics

- **Scope**: Function-scoped (like regular function declarations)
- **Hoisting**: Fully hoisted (like regular function declarations)
- **Storage**: Stored in **Variable Environment** (not Lexical Environment)
- **Return Type**: Always returns a **Promise** (even if you return a non-Promise value)
- **Execution**: Can use `await` to pause execution until a Promise resolves
- **Re-declaration**: Cannot be re-declared within the same scope

## How Async Functions Work

1. An async function always returns a Promise
2. If you return a value, it's wrapped in a resolved Promise
3. If you throw an error, it's wrapped in a rejected Promise
4. The `await` keyword pauses execution until the Promise resolves/rejects

### Example

```js
async function fetchData() {
  const response = await fetch("https://api.example.com/data");
  const data = await response.json();
  return data;
}

// Returns a Promise
fetchData().then((data) => console.log(data));
```

## The `await` Keyword

- **`await`**: Pauses execution until the Promise settles
- Can only be used inside async functions
- Returns the resolved value of the Promise
- Throws an error if the Promise rejects (can be caught with try/catch)

```js
async function example() {
  try {
    const value = await somePromise();
    console.log(value); // Resolved value
  } catch (error) {
    console.error(error); // Rejected error
  }
}
```

## Hoisting Behavior

Async function declarations are hoisted just like regular function declarations:

```js
// ✅ Works - async function is hoisted
const promise = fetchData();
promise.then((data) => console.log(data));

async function fetchData() {
  const response = await fetch("/api/data");
  return response.json();
}
```

## Return Behavior

Async functions always return a Promise:

```js
// Returns a value → wrapped in resolved Promise
async function getValue() {
  return 42;
}
getValue().then((value) => console.log(value)); // 42

// Returns a Promise → returned as-is
async function getPromise() {
  return Promise.resolve(42);
}
getPromise().then((value) => console.log(value)); // 42

// Throws error → wrapped in rejected Promise
async function throwError() {
  throw new Error("Something went wrong");
}
throwError().catch((error) => console.error(error)); // Error caught
```

## Async Function Expressions

Similar to function expressions, you can create async function expressions:

```js
// Async function expression assigned to const
const fetchData = async function () {
  const response = await fetch("/api/data");
  return response.json();
};

// Hoisting behavior follows the variable declaration
// If assigned to `var`: hoisted but undefined
// If assigned to `let`/`const`: in TDZ
```

## Async Arrow Functions

Arrow functions can also be async:

```js
const fetchData = async () => {
  const response = await fetch("/api/data");
  return response.json();
};
```

## Error Handling

Errors in async functions can be handled with try/catch or .catch():

```js
// Using try/catch
async function example() {
  try {
    const data = await fetchData();
    return data;
  } catch (error) {
    console.error("Error:", error);
    throw error; // Re-throw if needed
  }
}

// Using .catch()
async function example() {
  const data = await fetchData().catch((error) => {
    console.error("Error:", error);
    return null; // Default value
  });
  return data;
}
```

## Comparison with Regular Functions

| Feature        | Regular Function     | Async Function             |
| -------------- | -------------------- | -------------------------- |
| Syntax         | `function name() {}` | `async function name() {}` |
| Return         | Direct value         | Always a Promise           |
| Execution      | Synchronous          | Can pause with `await`     |
| Hoisting       | Fully hoisted        | Fully hoisted              |
| Storage        | Variable Environment | Variable Environment       |
| Use of `await` | ❌ Not allowed       | ✅ Required for pausing    |

## Comparison with Generator Functions

| Feature         | Generator Function                | Async Function             |
| --------------- | --------------------------------- | -------------------------- |
| Syntax          | `function* name() {}`             | `async function name() {}` |
| Pause Mechanism | `yield`                           | `await`                    |
| Return Type     | Generator object                  | Promise                    |
| Use Case        | Custom iterators, lazy evaluation | Asynchronous operations    |
| Error Handling  | try/catch or .throw()             | try/catch or .catch()      |

## Comparison with Async Generator Functions

**Key Difference**: An async function returns **one Promise with one value**, while an async generator function returns **multiple values over time**.

| Feature     | Async Function             | Async Generator Function                     |
| ----------- | -------------------------- | -------------------------------------------- |
| Syntax      | `async function name() {}` | `async function* name() {}`                  |
| Return Type | Promise (single value)     | AsyncGenerator object (multiple values)      |
| Returns     | Once (one value)           | Multiple times (many values)                 |
| Usage       | `await functionName()`     | `for await (const value of functionName())`  |
| When to use | Single async operation     | Streaming, pagination, multiple async values |

### When to Use Which?

**Use `async function` when:**

- You need to perform **one async operation** and get **one result**
- Example: Fetch a single user, save a file, make one API call

**Use `async function*` when:**

- You need to **yield multiple values** over time asynchronously
- Example: Stream data, paginate through results, process items one-by-one

## Use Cases

1. **API Calls**: Fetching data from APIs
2. **File Operations**: Reading/writing files (Node.js)
3. **Database Queries**: Waiting for database responses
4. **Sequential Async Operations**: Performing async operations in order
5. **Error Handling**: Cleaner error handling than Promise chains

### Example: Sequential Operations

```js
async function processUser(userId) {
  const user = await fetchUser(userId);
  const posts = await fetchUserPosts(userId);
  const comments = await fetchUserComments(userId);

  return {
    user,
    posts,
    comments,
  };
}
```

### Example: Parallel Operations

```js
async function processUser(userId) {
  // Execute in parallel
  const [user, posts, comments] = await Promise.all([
    fetchUser(userId),
    fetchUserPosts(userId),
    fetchUserComments(userId),
  ]);

  return { user, posts, comments };
}
```

## Important Notes

1. **Always Returns Promise**: Even if you return a non-Promise value, it's wrapped in a resolved Promise
2. **Top-Level Await**: In modules, you can use `await` at the top level (ES2022)
3. **Execution Order**: Async functions run synchronously until they hit `await`
4. **Error Propagation**: Unhandled errors in async functions become rejected Promises
5. **Performance**: Async functions don't block the main thread; they allow other code to run while waiting
