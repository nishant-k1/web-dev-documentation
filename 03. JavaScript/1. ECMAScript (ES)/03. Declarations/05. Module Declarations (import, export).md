# Module Declarations (import, export)

Module declarations in JavaScript allow you to organize code into separate modules that can be imported and exported. Introduced in ES6 (ES2015), modules provide a way to split code into multiple files and manage dependencies.

## Import Declarations

The `import` declaration is used to import bindings (functions, objects, primitives) that have been exported from another module.

### Syntax

```js
// Named imports
import { name1, name2 } from "./module.js";

// Default import
import defaultExport from "./module.js";

// Namespace import
import * as namespace from "./module.js";

// Mixed imports
import defaultExport, { named1, named2 } from "./module.js";
import defaultExport, * as namespace from "./module.js";
```

### Key Characteristics

- **Scope**: Module-scoped (not global)
- **Hoisting**: Hoisted but in **Temporal Dead Zone (TDZ)** until the declaration line
- **Storage**: Stored in **Lexical Environment** (like `let` and `const`)
- **Re-declaration**: Cannot be re-declared within the same module
- **Access Before Declaration**: Throws a `ReferenceError` if accessed before the declaration (TDZ)
- **Behavior**: All imports are processed before any module code runs (hoisted to top)

### Examples

```js
// ✅ Valid - imports are hoisted
console.log(importedValue); // Works (if importedValue is imported)

import { importedValue } from "./module.js";

// ❌ Invalid - cannot access before import
console.log(importedValue); // ReferenceError: Cannot access 'importedValue' before initialization

import { importedValue } from "./module.js";
```

## Export Declarations

The `export` declaration is used to export functions, objects, primitives, or classes from a module so they can be used by other modules.

### Syntax

```js
// Named exports
export const name = "value";
export function myFunction() {}
export class MyClass {}

// Default export
export default function() {}
export default class {}

// Export list
export { name1, name2, name3 };
export { name1 as newName1, name2 };

// Re-export
export { name } from "./other-module.js";
export * from "./other-module.js";
```

### Key Characteristics

- **Scope**: Module-scoped
- **Hoisting**: Exports are processed during module evaluation
- **Re-declaration**: Cannot export the same name twice (unless using different export types)
- **Default Export**: Only one default export per module
- **Named Exports**: Multiple named exports allowed

### Examples

```js
// Named exports
export const PI = 3.14159;
export function calculateArea(radius) {
  return PI * radius * radius;
}

// Default export
export default class Circle {
  constructor(radius) {
    this.radius = radius;
  }
}

// Export list
const name = "John";
const age = 30;
export { name, age };
```

## Module Scope vs Global Scope

- Variables declared in a module are **module-scoped**, not globally accessible
- Even if exported, they remain module-scoped (other modules can import them, but they're not global)
- Modules run in their own **Module Execution Context**

```js
// module.js
const moduleVar = "I am module-scoped";
export { moduleVar };

// main.js
import { moduleVar } from "./module.js";
console.log(moduleVar); // ✅ Works
console.log(window.moduleVar); // ❌ undefined (not global)
```

## Hoisting Behavior

Import declarations are hoisted to the top of the module, but they remain in the Temporal Dead Zone until the import statement is processed:

```js
// All imports are processed first (before any code runs)
import { something } from "./module.js";

// Then module code executes
console.log(something); // ✅ Works
```

## Comparison with Other Declarations

| Declaration Type | Storage Location | Hoisting Behavior | TDZ |
|-----------------|------------------|-------------------|-----|
| `var` | Variable Environment | Hoisted, initialized with `undefined` | ❌ No |
| `let` | Lexical Environment | Hoisted, not initialized | ✅ Yes |
| `const` | Lexical Environment | Hoisted, not initialized | ✅ Yes |
| `function` | Variable Environment | Fully hoisted (body available) | ❌ No |
| `class` | Lexical Environment | Hoisted, not initialized | ✅ Yes |
| `import` | Lexical Environment | Hoisted, not initialized | ✅ Yes |

## Important Notes

1. **Static Analysis**: Import/export statements are statically analyzed at compile time
2. **Top-Level Only**: Import/export must be at the top level of the module (not inside blocks)
3. **Strict Mode**: All module code runs in strict mode by default
4. **Single Evaluation**: Each module is evaluated only once, even if imported multiple times
5. **Circular Dependencies**: Modules can have circular dependencies, but values may be `undefined` if accessed before initialization
