# Generator Function Declarations (function*)

Generator functions are a special type of function that can be paused and resumed, allowing you to control the execution flow. They are declared using the `function*` syntax.

## Syntax

```js
function* generatorName() {
  yield value1;
  yield value2;
  return value3;
}
```

## Key Characteristics

- **Scope**: Function-scoped (like regular function declarations)
- **Hoisting**: Fully hoisted (like regular function declarations)
- **Storage**: Stored in **Variable Environment** (not Lexical Environment)
- **Return Type**: Returns a **Generator object** (not the yielded value directly)
- **Execution**: Can be paused with `yield` and resumed with `.next()`
- **Re-declaration**: Cannot be re-declared within the same scope

## How Generators Work

1. When called, a generator function returns a **Generator object** (implements the Iterator protocol)
2. The function body doesn't execute immediately
3. Execution starts when you call `.next()` on the generator object
4. The function runs until it hits a `yield` statement, then pauses
5. The yielded value is returned, and execution resumes on the next `.next()` call

### Example

```js
function* numberGenerator() {
  yield 1;
  yield 2;
  yield 3;
  return 4; // Final value
}

const gen = numberGenerator();

console.log(gen.next()); // { value: 1, done: false }
console.log(gen.next()); // { value: 2, done: false }
console.log(gen.next()); // { value: 3, done: false }
console.log(gen.next()); // { value: 4, done: true }
```

## The `yield` Keyword

- **`yield`**: Pauses execution and returns a value
- **`yield*`**: Delegates to another generator or iterable

```js
function* gen1() {
  yield 1;
  yield 2;
}

function* gen2() {
  yield* gen1(); // Delegates to gen1
  yield 3;
}

const gen = gen2();
console.log(gen.next()); // { value: 1, done: false }
console.log(gen.next()); // { value: 2, done: false }
console.log(gen.next()); // { value: 3, done: false }
```

## Hoisting Behavior

Generator function declarations are hoisted just like regular function declarations:

```js
// ✅ Works - generator is hoisted
const gen = myGenerator();
console.log(gen.next()); // { value: 1, done: false }

function* myGenerator() {
  yield 1;
}
```

## Generator Expressions

Similar to function expressions, you can create generator expressions:

```js
// Generator expression assigned to const
const gen = function*() {
  yield 1;
};

// Hoisting behavior follows the variable declaration
// If assigned to `var`: hoisted but undefined
// If assigned to `let`/`const`: in TDZ
```

## Use Cases

1. **Lazy Evaluation**: Generate values on-demand
2. **Infinite Sequences**: Create infinite data structures
3. **State Machines**: Manage complex state transitions
4. **Iterators**: Create custom iterators easily
5. **Async-like Control Flow**: Before async/await, generators were used with libraries like co.js

### Example: Infinite Sequence

```js
function* infiniteNumbers() {
  let num = 0;
  while (true) {
    yield num++;
  }
}

const numbers = infiniteNumbers();
console.log(numbers.next().value); // 0
console.log(numbers.next().value); // 1
console.log(numbers.next().value); // 2
// ... continues infinitely
```

### Example: Custom Iterator

```js
function* range(start, end) {
  for (let i = start; i <= end; i++) {
    yield i;
  }
}

for (const num of range(1, 5)) {
  console.log(num); // 1, 2, 3, 4, 5
}
```

## Comparison with Regular Functions

| Feature | Regular Function | Generator Function |
|---------|-----------------|-------------------|
| Syntax | `function name() {}` | `function* name() {}` |
| Return | Single value | Generator object |
| Execution | Runs to completion | Can pause/resume |
| Hoisting | Fully hoisted | Fully hoisted |
| Storage | Variable Environment | Variable Environment |
| Use of `yield` | ❌ Not allowed | ✅ Required for pausing |

## Important Notes

1. **Generator Object**: The returned generator object implements both the Iterator and Iterable protocols
2. **One-Time Use**: Once a generator is exhausted (done: true), it cannot be restarted
3. **Early Return**: Using `return` in a generator sets `done: true` and the return value becomes the final `value`
4. **Error Handling**: Errors can be thrown into generators using `.throw()`
5. **State Preservation**: Generator functions maintain their state between calls to `.next()`
