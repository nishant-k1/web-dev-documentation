# Common Interview Questions and Tricky Scenarios

This document covers common interview questions and tricky scenarios related to JavaScript operators, coercion, and precedence from a practical coding perspective.

> ðŸ“– **For detailed operator information:** See [1. Operators](./1.%20Operators.md)
> ðŸ“– **For precedence details:** See [2. Operators Precedence](./2.%20Operators%20Precedence.md)
> ðŸ“– **For coercion details:** See [3. Coercion](./3.%20Coercion.md)

---

## Coercion-Related Questions

### Q1: What's the output?

```javascript
console.log([] + []);
console.log({} + []);
console.log([] + {});
console.log({} + {});
```

**Answer:**

- `[] + []` â†’ `""` (empty string)
- `{} + []` â†’ `0` (in some contexts) or `"[object Object]"` (in others)
- `[] + {}` â†’ `"[object Object]"`
- `{} + {}` â†’ `"[object Object][object Object]"` or `NaN` (in some contexts)

**Explanation:**

- Arrays convert to strings via `toString()`: `[].toString()` â†’ `""`
- Objects convert to strings: `{}.toString()` â†’ `"[object Object]"`
- `+` operator with objects/arrays triggers string concatenation
- `{}` at the start of a line can be interpreted as a block, not an object literal

---

### Q2: What does this return?

```javascript
console.log(true + true);
console.log(true + false);
console.log(false + false);
```

**Answer:**

- `true + true` â†’ `2`
- `true + false` â†’ `1`
- `false + false` â†’ `0`

**Explanation:**

- `+` operator coerces booleans to numbers
- `true` â†’ `1`, `false` â†’ `0`
- No string involved, so numeric addition occurs

---

### Q3: Tricky string concatenation

```javascript
console.log("5" + 3);
console.log("5" - 3);
console.log("5" * 3);
console.log("5" / 3);
```

**Answer:**

- `"5" + 3` â†’ `"53"` (string concatenation)
- `"5" - 3` â†’ `2` (numeric subtraction)
- `"5" * 3` â†’ `15` (numeric multiplication)
- `"5" / 3` â†’ `1.666...` (numeric division)

**Explanation:**

- `+` with a string performs concatenation
- `-`, `*`, `/` always convert to numbers

---

### Q4: What's the result?

```javascript
console.log([] == 0);
console.log([] == "");
console.log([] == false);
console.log([0] == false);
```

**Answer:**

- `[] == 0` â†’ `true`
- `[] == ""` â†’ `true`
- `[] == false` â†’ `true`
- `[0] == false` â†’ `true`

**Explanation:**

- Arrays convert to primitives via `toString()`
- `[].toString()` â†’ `""`
- `[0].toString()` â†’ `"0"`
- `"" == 0` â†’ `true` (empty string coerces to 0)
- `"0" == false` â†’ `true` (both coerce to 0)

---

### Q5: NaN comparisons

```javascript
console.log(NaN == NaN);
console.log(NaN === NaN);
console.log(NaN != NaN);
console.log(NaN !== NaN);
```

**Answer:**

- `NaN == NaN` â†’ `false`
- `NaN === NaN` â†’ `false`
- `NaN != NaN` â†’ `true`
- `NaN !== NaN` â†’ `true`

**Explanation:**

- `NaN` is the only value that is not equal to itself
- Use `Number.isNaN()` or `isNaN()` to check for NaN

---

## Equality Operator Questions

### Q6: == vs ===

```javascript
console.log(null == undefined);
console.log(null === undefined);
console.log(null == 0);
console.log(null === 0);
```

**Answer:**

- `null == undefined` â†’ `true` (special rule)
- `null === undefined` â†’ `false` (different types)
- `null == 0` â†’ `false`
- `null === 0` â†’ `false`

**Explanation:**

- `null` and `undefined` are loosely equal (special case)
- `null` does not coerce to `0` in equality comparisons
- `null` only equals `null` and `undefined` with `==`

---

### Q7: String and number comparison

```javascript
console.log("5" == 5);
console.log("5" === 5);
console.log("" == 0);
console.log("" === 0);
console.log(" " == 0);
```

**Answer:**

- `"5" == 5` â†’ `true` (coercion)
- `"5" === 5` â†’ `false` (strict, different types)
- `"" == 0` â†’ `true` (empty string coerces to 0)
- `"" === 0` â†’ `false` (strict)
- `" " == 0` â†’ `false` (space string coerces to 0, but " " != "")

**Explanation:**

- `==` performs type coercion
- `===` does not
- Empty string `""` coerces to `0`
- Space string `" "` coerces to `0` but is not equal to empty string

---

### Q8: Object comparison

```javascript
let obj1 = {};
let obj2 = {};
let obj3 = obj1;

console.log(obj1 == obj2);
console.log(obj1 === obj2);
console.log(obj1 == obj3);
console.log(obj1 === obj3);
```

**Answer:**

- `obj1 == obj2` â†’ `false`
- `obj1 === obj2` â†’ `false`
- `obj1 == obj3` â†’ `true`
- `obj1 === obj3` â†’ `true`

**Explanation:**

- Objects are compared by reference, not value
- `obj1` and `obj2` are different objects (different references)
- `obj3` references the same object as `obj1`

---

## Logical Operator Questions

### Q9: What's returned?

```javascript
console.log(0 && 1);
console.log(1 && 0);
console.log(0 || 1);
console.log(1 || 0);
console.log(null || undefined || "default");
```

**Answer:**

- `0 && 1` â†’ `0` (first falsy)
- `1 && 0` â†’ `0` (second operand, first is truthy)
- `0 || 1` â†’ `1` (first truthy)
- `1 || 0` â†’ `1` (first truthy)
- `null || undefined || "default"` â†’ `"default"` (first truthy)

**Explanation:**

- `&&` returns first falsy or last value
- `||` returns first truthy or last value
- Both short-circuit

---

### Q10: Nullish coalescing vs Logical OR

```javascript
console.log(0 || "default");
console.log(0 ?? "default");
console.log("" || "default");
console.log("" ?? "default");
console.log(false || "default");
console.log(false ?? "default");
```

**Answer:**

- `0 || "default"` â†’ `"default"` (0 is falsy)
- `0 ?? "default"` â†’ `0` (0 is not nullish)
- `"" || "default"` â†’ `"default"` (empty string is falsy)
- `"" ?? "default"` â†’ `""` (empty string is not nullish)
- `false || "default"` â†’ `"default"` (false is falsy)
- `false ?? "default"` â†’ `false` (false is not nullish)

**Explanation:**

- `||` returns first truthy (treats 0, "", false as falsy)
- `??` only checks for `null` or `undefined`

---

### Q11: Complex logical expression

```javascript
let x = 5;
let result = x > 0 && x < 10 && "valid";
console.log(result);

let y = 15;
let result2 = y > 0 && y < 10 && "valid";
console.log(result2);
```

**Answer:**

- `result` â†’ `"valid"`
- `result2` â†’ `false`

**Explanation:**

- `&&` returns last value if all are truthy
- `&&` returns first falsy value
- `y < 10` is `false`, so `result2` is `false`

---

## Precedence Questions

### Q12: What's the result?

```javascript
console.log(2 + 3 * 4);
console.log((2 + 3) * 4);
console.log(2 ** (3 ** 2));
console.log((2 ** 3) ** 2);
```

**Answer:**

- `2 + 3 * 4` â†’ `14` (multiplication first)
- `(2 + 3) * 4` â†’ `20` (parentheses first)
- `2 ** 3 ** 2` â†’ `512` (right-to-left: 2 ** (3 ** 2))
- `(2 ** 3) ** 2` â†’ `64` (left-to-right: 8 \*\* 2)

**Explanation:**

- Multiplication has higher precedence than addition
- Exponentiation is right-to-left associative
- Parentheses override precedence

---

### Q13: Logical operator precedence

```javascript
console.log(true && false || true);
console.log(true || false && true);
console.log(null || "A" ?? "B");
```

**Answer:**

- `true && false || true` â†’ `true` (AND first, then OR)
- `true || false && true` â†’ `true` (OR short-circuits)
- `null || "A" ?? "B"` â†’ `"A"` (OR has higher precedence than ??)

**Explanation:**

- `&&` has higher precedence than `||`
- `||` has higher precedence than `??`
- Use parentheses to control evaluation

---

### Q14: Assignment precedence

```javascript
let a, b, c;
a = b = c = 5;
console.log(a, b, c);

let x = 2 + 3 * 4;
console.log(x);
```

**Answer:**

- `a, b, c` â†’ `5, 5, 5`
- `x` â†’ `14`

**Explanation:**

- Assignment is right-to-left associative
- `c = 5` happens first, then `b = c`, then `a = b`
- Arithmetic has higher precedence than assignment

---

## Unary Operator Questions

### Q15: Unary plus and minus

```javascript
console.log(+"5");
console.log(+"");
console.log(+[]);
console.log(+[1, 2]);
console.log(+{});
```

**Answer:**

- `+"5"` â†’ `5`
- `+""` â†’ `0`
- `+[]` â†’ `0` (empty array â†’ "" â†’ 0)
- `+[1, 2]` â†’ `NaN` (`[1,2].toString()` â†’ `"1,2"` â†’ `NaN`)
- `+{}` â†’ `NaN`

**Explanation:**

- Unary `+` converts to number
- Arrays convert to string first, then to number
- Empty array â†’ empty string â†’ 0
- Non-empty array â†’ comma-separated string â†’ NaN

---

### Q16: typeof operator

```javascript
console.log(typeof null);
console.log(typeof undefined);
console.log(typeof []);
console.log(typeof {});
console.log(typeof typeof 1);
```

**Answer:**

- `typeof null` â†’ `"object"` (historical bug)
- `typeof undefined` â†’ `"undefined"`
- `typeof []` â†’ `"object"`
- `typeof {}` â†’ `"object"`
- `typeof typeof 1` â†’ `"string"` (typeof returns string)

**Explanation:**

- `typeof` always returns a string
- `typeof null` is a known bug (should be `"null"`)
- Use `Array.isArray()` to check for arrays

---

### Q17: Increment and decrement

```javascript
let a = 5;
console.log(a++);
console.log(a);

let b = 5;
console.log(++b);
console.log(b);

let c = 5;
let d = c++ + ++c;
console.log(d);
```

**Answer:**

- First `a++` â†’ `5`, then `a` â†’ `6`
- First `++b` â†’ `6`, then `b` â†’ `6`
- `d` â†’ `12`

**Explanation:**

- Postfix: use value, then increment
- Prefix: increment, then use value
- `c++ + ++c`: `c++` returns 5 (c becomes 6), then `++c` increments to 7 and returns 7, so `5 + 7 = 12`

---

## Ternary Operator Questions

### Q18: Nested ternary

```javascript
let x = 5;
let result = x > 10 ? "large" : x > 5 ? "medium" : "small";
console.log(result);
```

**Answer:** `"small"`

**Explanation:**

- Evaluates as: `x > 10 ? "large" : (x > 5 ? "medium" : "small")`
- `x > 10` is false, so evaluates right side
- `x > 5` is false, so returns `"small"`

---

### Q19: Ternary with logical operators

```javascript
let value = null;
let result = value && value.prop ? value.prop : "default";
console.log(result);

let result2 = value?.prop ?? "default";
console.log(result2);
```

**Answer:**

- `result` â†’ `"default"`
- `result2` â†’ `"default"`

**Explanation:**

- `value && value.prop` short-circuits (null is falsy)
- Optional chaining `?.` safely accesses properties
- Nullish coalescing `??` provides default

---

## Real-World Scenarios

### Q20: Default value pattern

```javascript
function greet(name) {
  name = name || "Guest";
  return `Hello, ${name}!`;
}

console.log(greet("John"));
console.log(greet(""));
console.log(greet(0));
```

**Answer:**

- `greet("John")` â†’ `"Hello, John!"`
- `greet("")` â†’ `"Hello, Guest!"` (empty string is falsy)
- `greet(0)` â†’ `"Hello, Guest!"` (0 is falsy)

**Problem:** `||` treats `""` and `0` as falsy, which might not be desired.

**Better Solution:**

```javascript
function greet(name) {
  name = name ?? "Guest"; // Only null/undefined get default
  return `Hello, ${name}!`;
}
```

---

### Q21: Conditional property access

```javascript
let user = null;
let name = (user && user.name) || "Anonymous";
console.log(name);

let name2 = user?.name ?? "Anonymous";
console.log(name2);
```

**Answer:**

- `name` â†’ `"Anonymous"`
- `name2` â†’ `"Anonymous"`

**Explanation:**

- `user && user.name` returns `null` (falsy)
- `null || "Anonymous"` returns `"Anonymous"`
- Optional chaining is cleaner and safer

---

### Q22: Array operations

```javascript
let arr = [1, 2, 3];
let sum = arr.reduce((a, b) => a + b, 0);
console.log(sum);

let arr2 = ["1", "2", "3"];
let sum2 = arr2.reduce((a, b) => a + b, 0);
console.log(sum2);
```

**Answer:**

- `sum` â†’ `6`
- `sum2` â†’ `"0123"` (string concatenation!)

**Explanation:**

- First: numbers add correctly
- Second: `+` with strings concatenates
- Initial value `0` gets coerced to string `"0"`

**Fix:**

```javascript
let sum2 = arr2.reduce((a, b) => Number(a) + Number(b), 0);
// Or: arr2.map(Number).reduce((a, b) => a + b, 0);
```

---

## Edge Cases and Gotchas

### Q23: Empty array operations

```javascript
console.log([].toString());
console.log([].valueOf());
console.log(+[]);
console.log([] == 0);
console.log([] == "");
console.log([] == false);
```

**Answer:**

- `[].toString()` â†’ `""`
- `[].valueOf()` â†’ `[]` (returns array itself)
- `+[]` â†’ `0`
- `[] == 0` â†’ `true`
- `[] == ""` â†’ `true`
- `[] == false` â†’ `true`

**Explanation:**

- Empty array converts to empty string
- Empty string coerces to `0` in numeric context
- All comparisons end up as `true` due to coercion chain

---

### Q24: Object to primitive conversion

```javascript
let obj = {
  valueOf() {
    return 10;
  },
};

console.log(obj + 5);
console.log(obj == 10);
console.log(obj === 10);
```

**Answer:**

- `obj + 5` â†’ `15`
- `obj == 10` â†’ `true`
- `obj === 10` â†’ `false`

**Explanation:**

- `valueOf()` is called for numeric operations
- `==` triggers coercion, `===` does not

---

### Q25: Symbol.toPrimitive

```javascript
let obj = {
  [Symbol.toPrimitive](hint) {
    if (hint === "number") return 42;
    if (hint === "string") return "hello";
    return "default";
  },
};

console.log(+obj);
console.log(String(obj));
console.log(obj + "");
```

**Answer:**

- `+obj` â†’ `42`
- `String(obj)` â†’ `"hello"`
- `obj + ""` â†’ `"default"` (hint is "default" for `+` with string)

**Explanation:**

- `Symbol.toPrimitive` allows custom conversion
- Hint can be "number", "string", or "default"

---

## Summary

### Key Takeaways

1. **Coercion Rules:**

   - `+` with string â†’ concatenation
   - `-`, `*`, `/` â†’ numeric conversion
   - Arrays/objects â†’ string via `toString()`

2. **Equality:**

   - `==` performs coercion
   - `===` does not
   - `null == undefined` is `true` (special case)
   - `NaN` is never equal to itself

3. **Logical Operators:**

   - Return values, not just booleans
   - Short-circuit evaluation
   - `||` vs `??` - know the difference

4. **Precedence:**

   - `&&` > `||` > `??`
   - Exponentiation is right-to-left
   - Assignment is right-to-left

5. **Common Patterns:**
   - Use `??` for default values (not `||`)
   - Use `?.` for safe property access
   - Use `===` for comparisons (avoid `==`)

---

> ðŸ“– **Related Topics:**
>
> - [1. Operators](./1.%20Operators.md) - Complete operator reference
> - [2. Operators Precedence](./2.%20Operators%20Precedence.md) - Precedence details
> - [3. Coercion](./3.%20Coercion.md) - Type coercion deep dive
> - [6. Common Mistakes and Best Practices](./6.%20Common%20Mistakes%20and%20Best%20Practices.md) - Best practices
