# Coercion

1. Coercion typically converts operands to one of the following types:

   1. string
   2. number
   3. boolean

2. In JavaScript, the `==`, `-`, `*`, and `/` operators coerce operands to numbers (even if the operands are of any primitive type).

3. The `+` operator also coerces operands to numbers only if neither operand is a string; otherwise, it prefers string concatenation if either operand is a string.

4. If either or both operands are objects, their `ToPrimitive` conversion is triggered (via `Symbol.toPrimitive`, `valueOf()`, or `toString()`), before coercion by all these operators.

5. `undefined`, `null`, and `symbol` will behave specially but do not automatically coerce into the other types during normal coercion.

Note: null is a primitive, not an object, so this rule doesn’t apply to it.

## null == undefined but null !== undefined

**Special Case for null and undefined**: null == undefined is true. This is `not` coercion but a defined behavior in the Abstract Equality Comparison algorithm. Both are loosely equal.

## Either or both operand is NaN

returns false

NaN === NaN is false, because NaN is the only value in JavaScript that is not equal to itself.

```js
NaN == NaN; // false
NaN == {}; // false
```

## Order of Operands

The order doesn't affect coercion (e.g., 5 == '5' is the same as '5' == 5).

## **Key Takeaways on Type Coercion in JavaScript**

1. **Arithmetic Operators** (except `+` for strings) convert operands to numbers.
2. **`+` with a string** converts the other operand to a string.
3. **`==` compares values after coercion**, but **`===` does not**.
4. **Logical operators return values** instead of just `true`/`false`.
5. **Bitwise operators** convert operands to **32-bit integers**.
6. **Nullish coalescing (`??`) only checks `null` and `undefined`.**

---

# Unary operator coercion

1. Number coercion
   Internally, it calls the ToNumber() function

   1. Unary Plus (+)
      Purpose: Converts the operand to a number.
      Rules for +array and +plain object: It will try to coerce array to a string → then to a number.

      ```j
         +true        // 1
         +false       // 0
         +null        // 0
         +undefined   // NaN
         +"123"       // 123
         +""          // 0
         +[]          // 0
         +[1, 2]      // NaN
         +{}          // NaN

      ```

   2. Unary Negation (-)

      ```j
         -"5"         // -5
         -false       // 0
         -true        // -1
         -null        // -0
         -undefined   // NaN
      ```

2. Boolean coercion

   1. Logical NOT (!)

   ```js
   !true; // false
   !false; // true
   !0; // true
   !1; // false
   !""; // true
   !"hello"; // false
   !null; // true
   !undefined; // true
   !{}; // false
   ![]; // false
   ```

---

# Comparison Operators Coercion

1. **Number Coercion**

   The loose equality operator (==) compares two values for equality, performing type coercion if the operands have different types. Coercion converts one or both operands to a common Number type before comparison.

   `Example: '123' == 123 → true (string '123' becomes number 123).`

   `Example: true == 1 → true.`
   `Example: true == '0' → false.`

---

**Object and Primitive**: Objects (e.g., arrays) are converted to primitives via toString() or valueOf() similar to arithmetic + operator coercion.

`Example: [] == '' → true (array [] becomes '' via toString()).`

**Special Case for null and undefined**: `null == undefined is true`. `This is not coercion but a defined behavior in the Abstract Equality Comparison algorithm`.

**NaN: If either operand is NaN**: return false (even NaN == NaN is false).
Example: NaN == NaN → false.

**Order of Operands**: The order doesn't affect coercion (e.g., 5 == '5' is the same as '5' == 5).

---

# Arithmetic Operators Coercion

1. **String Coercion**
   When an operation involves a string and another type with (+ operator), JavaScript tries to convert the non-string operand to a string.

   ```Javascript
    let num = 5;
    let str = "Hello";
    let result = str + num; // "Hello5" - number coerced to string for concatenation

    console.log(5 + '5'); // "55" (number 5 is coerced to string)
    console.log('5' + 5); // "55" (number 5 is coerced to string)
   ```

2. **Number Coercion**
   When a number is involved in arithmetic or comparison operations `(except for +)`, JavaScript tries to convert non-numeric types to numbers.

   ```Javascript
    let str = "10";
    let result = str * 2; // 20 - string coerced to number for multiplication

    console.log("5" - 2); // 3 (string "5" is coerced to number)

    console.log("5" * 2); // 10 (string "5" is coerced to number)

    console.log("5" / 2); // 2.5 (string "5" is coerced to number)

    '123' == 123 → true // string '123' becomes number 123.

    true == 1 → true. // true becomes number 1

    true == '0' → false // both gets coerced to Number, so  the comparison becomes 1 === 0, which returns false

    false == '0' → true // both gets coerced to Number, so  the comparison becomes 0 === 0, which returns false
   ```

3. **Object to Primitive Coercion**
   JavaScript can convert objects to primitive values when necessary. This happens when objects are used in operations like string concatenation, comparison, or arithmetic.
   By default, JavaScript calls the toString() or valueOf() method of objects to convert them into a primitive value.

<!-- By default, plain objects are converted using .toString(), which returns: -->

```Javascript
 let obj = { name: "John" };
 console.log(obj + ""); // "[object Object]" (object coerced to string)

 let obj = {
 valueOf() {
     return 10;
   }
 };

 console.log(obj + 5); // 15 (obj coerced to number)
```

Type coercion happens. The + operator attempts to convert both operands to primitive values.
[] converts to "" (empty string).
{} converts to "[object Object]" (the default string representation of a plain JavaScript object).

**During string coercion, the non-string operand is converted to a string, and this typically involves calling its .toString() method, unless overridden by custom behavior via Symbol.toPrimitive or valueOf().**

**When JavaScript needs to turn something into a string (like when using + with a string), it tries to call .toString() on it — unless the object has a custom way of converting itself using Symbol.toPrimitive.**

```js
console.log([] + []);
console.log({} + []);
console.log([] + {});
console.log(+[1]);
console.log({}.toString());
console.log([1, 2, 3, 4, 5].toString());
console.log(`[1, 2, 3, 4, 5, 6]`);
console.log(String([1, 2, 3, 4, 5, 6]));
console.log("TEST" + {});
console.log("TEST" + []);
console.log(++{});
console.log(++[]);

function test() {}

console.log([] + (() => {}));
console.log({} + (() => {}));

console.log([] + test);
console.log({} + test);
```
