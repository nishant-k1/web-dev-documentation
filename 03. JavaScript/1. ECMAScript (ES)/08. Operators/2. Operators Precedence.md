# Operators Precedence

Operator precedence determines the order in which operators are evaluated in an expression. Higher precedence operators are evaluated before lower precedence operators.

---

## Complete Precedence Table

| Precedence | Operator Type               | Operators                                                         | Associativity | Example                         |
| ---------- | --------------------------- | ----------------------------------------------------------------- | ------------- | ------------------------------- | ------------- | ------------- | ----------------- | --- |
| **21**     | Grouping                    | `()`                                                              | N/A           | `(a + b) * c`                   |
| **20**     | Member Access               | `.` `[]`                                                          | Left-to-right | `obj.prop`, `arr[0]`            |
| **19**     | Function Call               | `()`                                                              | Left-to-right | `func()`                        |
| **18**     | Optional Chaining           | `?.`                                                              | Left-to-right | `obj?.prop`                     |
| **17**     | Postfix Increment/Decrement | `++` `--`                                                         | N/A           | `i++`, `i--`                    |
| **16**     | Unary Operators             | `!` `~` `+` `-` `typeof` `void` `delete` `++` `--`                | Right-to-left | `!x`, `+x`, `-x`, `typeof x`    |
| **15**     | Exponentiation              | `**`                                                              | Right-to-left | `2 ** 3 ** 2`                   |
| **14**     | Multiplicative              | `*` `/` `%`                                                       | Left-to-right | `a * b / c`                     |
| **13**     | Additive                    | `+` `-`                                                           | Left-to-right | `a + b - c`                     |
| **12**     | Bitwise Shift               | `<<` `>>` `>>>`                                                   | Left-to-right | `a << 2`                        |
| **11**     | Relational                  | `<` `<=` `>` `>=` `in` `instanceof`                               | Left-to-right | `a < b`, `obj instanceof Class` |
| **10**     | Equality                    | `==` `!=` `===` `!==`                                             | Left-to-right | `a == b`, `a === b`             |
| **9**      | Bitwise AND                 | `&`                                                               | Left-to-right | `a & b`                         |
| **8**      | Bitwise XOR                 | `^`                                                               | Left-to-right | `a ^ b`                         |
| **7**      | Bitwise OR                  | `                                                                 | `             | Left-to-right                   | `a            | b`            |
| **6**      | Logical AND                 | `&&`                                                              | Left-to-right | `a && b`                        |
| **5**      | Logical OR                  | `                                                                 |               | `                               | Left-to-right | `a            |                   | b`  |
| **4**      | Nullish Coalescing          | `??`                                                              | Left-to-right | `a ?? b`                        |
| **3**      | Conditional (Ternary)       | `? :`                                                             | Right-to-left | `a ? b : c`                     |
| **2**      | Assignment                  | `=` `+=` `-=` `*=` `/=` `%=` `**=` `<<=` `>>=` `>>>=` `&=` `^=` ` | =` `&&=` `    |                                 | =` `??=`      | Right-to-left | `a = b`, `a += b` |
| **1**      | Comma                       | `,`                                                               | Left-to-right | `a, b, c`                       |

> **Note:** Higher numbers = Higher precedence (evaluated first)

---

## Associativity

### Left-to-Right Associativity

Operators with left-to-right associativity are evaluated from left to right:

```javascript
// Addition (left-to-right)
10 - 5 - 2;
// Step 1: (10 - 5) = 5
// Step 2: 5 - 2 = 3
// Result: 3

// Logical AND (left-to-right)
true && false && true;
// Step 1: true && false = false
// Step 2: false && true = false
// Result: false
```

### Right-to-Left Associativity

Operators with right-to-left associativity are evaluated from right to left:

```javascript
// Exponentiation (right-to-left)
2 ** (3 ** 2);
// Step 1: 3 ** 2 = 9
// Step 2: 2 ** 9 = 512
// Result: 512
// NOT: (2 ** 3) ** 2 = 8 ** 2 = 64

// Assignment (right-to-left)
a = b = 5;
// Step 1: b = 5 (b becomes 5)
// Step 2: a = b (a becomes 5)
// Result: a = 5, b = 5

// Unary operators (right-to-left)
!typeof x;
// Step 1: typeof x (evaluates first)
// Step 2: !(result of typeof)
```

---

## Common Precedence Groups

### Group 1: Highest Precedence (Grouping and Access)

```javascript
// Parentheses override all precedence
(2 + 3) * 4; // 20 (not 14)

// Member access
obj.prop;
arr[0];
func();
```

### Group 2: Unary Operators

```javascript
!x; // Logical NOT
~x + // Bitwise NOT
  x - // Unary plus
  x; // Unary minus
typeof x; // Type check
void x; // Returns undefined
delete obj.prop; // Delete property
++x; // Prefix increment
--x; // Prefix decrement
```

### Group 3: Arithmetic Operators

```javascript
// Exponentiation (right-to-left)
2 ** (3 ** 2); // 512 (not 64)

// Multiplication, Division, Modulus (left-to-right)
(10 * 5) / 2; // 25
(10 / 5) * 2; // 4

// Addition, Subtraction (left-to-right)
10 + 5 - 3; // 12
```

### Group 4: Comparison Operators

```javascript
// Relational (left-to-right)
5 < 10 < 15; // true (because (5 < 10) = true, then true < 15 = true)

// Equality (left-to-right)
(5 == 5) == true; // false (because (5 == 5) = true, then true == true = true... wait, this is tricky)
```

### Group 5: Logical Operators

```javascript
// Logical AND (left-to-right)
true && false && true; // false

// Logical OR (left-to-right)
false || false || true; // true

// Nullish Coalescing (left-to-right)
null ?? undefined ?? "default"; // "default"
```

### Group 6: Conditional (Ternary)

```javascript
// Right-to-left associativity
a ? b : c ? d : e;
// Evaluates as: a ? b : (c ? d : e)
// NOT as: (a ? b : c) ? d : e
```

### Group 7: Assignment (Lowest Precedence)

```javascript
// Assignment has very low precedence
let x = 5 + 3; // x = 8 (addition happens first)

// Right-to-left associativity
a = b = 5; // Both a and b become 5
```

---

## Practical Examples

### Example 1: Arithmetic Precedence

```javascript
let result = 2 + 3 * 4;
// Step 1: 3 * 4 = 12 (multiplication first)
// Step 2: 2 + 12 = 14
// Result: 14

let result2 = (2 + 3) * 4;
// Step 1: (2 + 3) = 5 (parentheses first)
// Step 2: 5 * 4 = 20
// Result: 20
```

### Example 2: Logical Operators

```javascript
let x = (true && false) || true;
// Step 1: true && false = false (AND has higher precedence)
// Step 2: false || true = true
// Result: true

let y = true || (false && true);
// Step 1: false && true = false (AND has higher precedence)
// Step 2: true || false = true
// Result: true
```

### Example 3: Nullish Coalescing vs Logical OR

```javascript
// Nullish coalescing has lower precedence than logical OR
let result = null || "A" ?? "B";
// Step 1: null || "A" = "A" (OR evaluated first)
// Step 2: "A" ?? "B" = "A" (but this never happens because result is already "A")
// Result: "A"

// Use parentheses to control evaluation
let result2 = (null || "A") ?? "B";  // "A"
let result3 = null || ("A" ?? "B");  // "A"
```

### Example 4: Assignment Precedence

```javascript
let a, b, c;
a = b = c = 5;
// Step 1: c = 5 (c becomes 5)
// Step 2: b = c (b becomes 5)
// Step 3: a = b (a becomes 5)
// Result: a = 5, b = 5, c = 5
```

### Example 5: Complex Expression

```javascript
let result = (2 + 3 * 4 < 20 && true) || false;
// Step 1: 3 * 4 = 12 (multiplication)
// Step 2: 2 + 12 = 14 (addition)
// Step 3: 14 < 20 = true (comparison)
// Step 4: true && true = true (logical AND)
// Step 5: true || false = true (logical OR)
// Result: true
```

---

## Common Pitfalls

### Pitfall 1: Exponentiation Right-to-Left

```javascript
// âŒ Wrong assumption
2 ** (3 ** 2); // NOT (2 ** 3) ** 2 = 64
// âœ… Correct evaluation
2 ** (3 ** 2); // 2 ** (3 ** 2) = 2 ** 9 = 512
```

### Pitfall 2: Nullish Coalescing with Logical OR

```javascript
// âŒ Unexpected behavior
null || "A" ?? "B"  // "A" (OR evaluated first, not what you might expect)

// âœ… Use parentheses
(null || "A") ?? "B"  // "A"
null || ("A" ?? "B")  // "A"
```

### Pitfall 3: Assignment in Conditionals

```javascript
// âŒ Common mistake
if ((x = 5)) {
  // Assignment, not comparison!
  // This always runs if assignment succeeds
}

// âœ… Correct
if (x === 5) {
  // Comparison
}
```

### Pitfall 4: Ternary Operator Nesting

```javascript
// âŒ Confusing
a ? b : c ? d : e;
// This is: a ? b : (c ? d : e)

// âœ… Clear with parentheses
a ? b : c ? d : e;
```

### Pitfall 5: Typeof with Unary Operators

```javascript
// âŒ typeof has higher precedence than !
typeof !x; // typeof (!x) - checks type of boolean

// âœ… Use parentheses if needed
!typeof x; // Negates the type string result
```

---

## Operator Precedence in Practice

### Best Practices

1. **Use Parentheses for Clarity**: Even when not required, parentheses can make code more readable:

```javascript
// âœ… Clear
if ((a && b) || (c && d)) {
  // ...
}

// âŒ Less clear (though correct)
if ((a && b) || (c && d)) {
  // ...
}
```

2. **Understand Nullish Coalescing Precedence**: `??` has lower precedence than `&&` and `||`:

```javascript
// âœ… Correct usage
let value = (a || b) ?? "default";
let value2 = a ?? (b || "default");
```

3. **Be Careful with Assignment**: Assignment has very low precedence:

```javascript
// âœ… Correct
let sum = a + b;

// âŒ Wrong (though this would be a syntax error anyway)
let sum = a + b = c;  // Syntax error
```

---

## Quick Reference

### Evaluation Order (High to Low)

1. **Grouping**: `()`
2. **Member Access**: `.` `[]` `()`
3. **Unary**: `!` `~` `+` `-` `typeof` `void` `delete` `++` `--`
4. **Exponentiation**: `**` (right-to-left)
5. **Multiplicative**: `*` `/` `%`
6. **Additive**: `+` `-`
7. **Bitwise Shift**: `<<` `>>` `>>>`
8. **Relational**: `<` `<=` `>` `>=` `in` `instanceof`
9. **Equality**: `==` `!=` `===` `!==`
10. **Bitwise**: `&` `^` `|`
11. **Logical**: `&&` `||`
12. **Nullish**: `??`
13. **Conditional**: `? :` (right-to-left)
14. **Assignment**: `=` `+=` `-=` etc. (right-to-left)
15. **Comma**: `,`

---

## Summary

- **Precedence** determines which operators are evaluated first
- **Associativity** determines the order when operators have the same precedence
- **Parentheses** `()` override all precedence rules
- **Exponentiation** and **Assignment** are right-to-left associative
- **Most operators** are left-to-right associative
- **When in doubt, use parentheses** for clarity

> ðŸ“– **Related Topics:**
>
> - [1. Operators](./1.%20Operators.md) - Overview of all operators
> - [3. Coercion](./3.%20Coercion.md) - How operators handle type coercion
