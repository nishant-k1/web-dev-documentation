# Deep Copy

Deep copy creates a completely independent copy where nested objects and arrays are also copied, not just referenced.

## Key Characteristics

- Creates a completely independent copy
- Nested objects and arrays are also copied recursively
- Changes to the copy do not affect the original at any level

## Methods for Deep Copy

### 1. Using `structuredClone()` (Modern Browsers)

- ✅ Native browser API
- ✅ Handles circular references
- ✅ Preserves most data types
- ⚠️ Limitations: Not available in older browsers

```js
const original = { a: 1, b: { c: 2 } };
const copy = structuredClone(original);

copy.b.c = 42;
console.log(original.b.c); // 2 ✅
console.log(copy.b.c); // 42
```

**Supported types:**

- Objects, arrays, primitives
- Maps, Sets
- Dates, RegExp
- ArrayBuffers, TypedArrays
- Circular references

**Not supported:**

- Functions
- Symbol properties
- DOM nodes
- Some built-in objects

### 2. Using Third-Party Libraries

#### Lodash `_.cloneDeep()`

- ✅ Robust and reliable
- ✅ Handles edge cases
- ❌ Requires a dependency

```js
import cloneDeep from "lodash/cloneDeep";

const original = { a: 1, b: { c: 2 } };
const copy = cloneDeep(original);

copy.b.c = 42;
console.log(original.b.c); // 2 ✅
```

#### Other Libraries

- **deepdash** - Extended Lodash with deep operations
- **clone** - Simple cloning library
- **rfdc** - Really fast deep clone

### 3. JSON Method (Quick & Dirty) ⚠️

- ✅ Simple and quick
- ❌ Limitations:
  - Loses functions, Dates, undefined, NaN, RegExp, Map, Set, etc.
  - Throws on circular references
  - Only works with JSON-serializable data

```js
const original = { a: 1, b: { c: 2 } };
const copy = JSON.parse(JSON.stringify(original));

copy.b.c = 42;
console.log(original.b.c); // 2 ✅
console.log(copy.b.c); // 42
```

## Custom Deep Copy Implementation

```js
function deepCopy(obj) {
  // Handle primitives and null
  if (obj === null || typeof obj !== "object") return obj;

  // Handle Date
  if (obj instanceof Date) return new Date(obj.getTime());

  // Handle Array
  if (Array.isArray(obj)) {
    return obj.map((item) => deepCopy(item));
  }

  // Handle Object
  const copy = {};
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      copy[key] = deepCopy(obj[key]);
    }
  }
  return copy;
}
```

## When to Use

- When you need completely independent copies
- When nested structures must not be shared
- When working with complex data structures
- When you need to modify a copy without affecting the original

## Important Notes

1. **Performance** - Deep copy is slower than shallow copy
2. **Memory usage** - Creates new objects for all nested structures
3. **Circular references** - Custom implementations may fail (use `structuredClone()` or libraries)
4. **Edge cases** - Functions, Dates, and special objects need special handling

## Best Practices

1. **Use `structuredClone()`** for modern browsers (ES2022+)
2. **Use Lodash `cloneDeep()`** for production code with complex requirements
3. **Avoid JSON method** unless you're certain about data structure
4. **Consider performance** - Deep copy can be expensive for large objects
5. **Handle edge cases** - Functions, Dates, and circular references need special handling
