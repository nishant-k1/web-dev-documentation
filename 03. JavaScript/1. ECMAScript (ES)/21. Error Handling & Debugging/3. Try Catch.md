# Try-Catch Blocks

There are two main ways to handle errors/exceptions in JavaScript:

1. **Try-Catch blocks** - For synchronous code
2. **`.catch()` method** - For Promises (see [4. Async Error Handling.md](./4.%20Async%20Error%20Handling.md))

---

## Basic Try-Catch

The `try-catch` block is the simplest way to handle errors in synchronous code.

```javascript
function fail() {
  try {
    console.log("this works");
    throw new Error("oopsie!!");
  } catch (error) {
    console.log(error);
    console.log(error.message); // "oopsie!!"
    console.log(error.stack); // Stack trace
  }
}
fail();
```

**How it works:**

- Code in the `try` block executes
- If an error is thrown, execution jumps to the `catch` block
- The `catch` block receives the error object
- Code after the try-catch continues normally

---

## Finally Block

The `finally` block **always executes**, regardless of whether an error occurred or not.

```javascript
function fail() {
  try {
    console.log("this works");
    throw new Error("oopsie!!");
  } catch (error) {
    console.log(error);
  } finally {
    console.log("will run definitely");
    return "returning fail";
  }
  console.log("won't get executed"); // This line never runs
}
fail();
```

**Key points about `finally`:**

- Always executes, even if there's a `return` in `try` or `catch`
- Useful for cleanup (closing files, clearing resources)
- If `finally` has a `return`, it overrides returns in `try`/`catch`

---

## Try-Catch Limitations

### ❌ Doesn't Work with Asynchronous Code

Try-catch **only catches errors in synchronous code**. It won't catch errors in:

- `setTimeout` / `setInterval`
- Event handlers
- Promise callbacks (without async/await)

```javascript
// ❌ This won't catch the error
try {
  setTimeout(function () {
    fakevariable; // ReferenceError - not caught!
  }, 1000);
} catch (e) {
  console.log("got it", e); // Never executes
}
```

**Why?** The error occurs **after** the try-catch block has already finished executing.

**Solution:** Use async/await or Promise `.catch()` (see [4. Async Error Handling.md](./4.%20Async%20Error%20Handling.md))

---

## Nested Try-Catch

You can nest try-catch blocks for more granular error handling.

```javascript
try {
  try {
    something();
  } catch (e) {
    // Handle inner error
    throw new Error("Wrapped: " + e.message);
  }
} catch (e) {
  // Handle outer error
  console.log("got it", e);
}
```

**Use cases:**

- Different error handling at different levels
- Wrapping errors with additional context
- Selective error propagation

---

## Best Practices

### ✅ Do

```javascript
// Catch specific errors
try {
  riskyOperation();
} catch (error) {
  if (error instanceof TypeError) {
    // Handle TypeError specifically
  } else {
    // Handle other errors
  }
}

// Always handle errors meaningfully
try {
  processData();
} catch (error) {
  logError(error); // Log for debugging
  showUserFriendlyMessage(); // Show to user
}
```

### ❌ Don't

```javascript
// Don't swallow errors silently
try {
  importantOperation();
} catch (e) {
  // Empty catch - bad practice!
}

// Don't catch errors you can't handle
try {
  JSON.parse(userInput);
} catch (e) {
  // If you can't fix it, let it propagate
  throw e; // Re-throw
}
```

---

## Related Topics

- [4. Async Error Handling.md](./4.%20Async%20Error%20Handling.md) - Handling async errors
- [7. Built-in Error Types.md](./7.%20Built-in%20Error%20Types.md) - Different error types
- [9. Best Practices.md](./9.%20Best%20Practices.md) - Error handling patterns
