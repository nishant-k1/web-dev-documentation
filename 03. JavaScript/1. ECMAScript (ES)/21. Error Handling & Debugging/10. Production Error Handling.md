# Production Error Handling

Production error handling requires different strategies than development. This guide covers patterns and practices for handling errors in production environments.

---

## Production vs Development

| Aspect              | Development       | Production                |
| ------------------- | ----------------- | ------------------------- |
| **Error Details**   | Full stack traces | User-friendly messages    |
| **Logging**         | Console logs      | Error monitoring services |
| **Debugging**       | Detailed errors   | Sanitized errors          |
| **User Experience** | Technical errors  | Friendly messages         |

---

## 1. Error Sanitization

Never expose sensitive information to users.

### ❌ Bad

```javascript
app.use((err, req, res, next) => {
  res.status(500).json({
    error: err.message,
    stack: err.stack, // Exposes code structure
    database: err.query, // Exposes database info
    file: err.filePath, // Exposes file system
    connection: err.connection, // Exposes credentials
  });
});
```

### ✅ Good

```javascript
app.use((err, req, res, next) => {
  // Log full error internally
  logger.error("Internal error:", {
    message: err.message,
    stack: err.stack,
    url: req.url,
    method: req.method,
    userId: req.user?.id,
  });

  // Send sanitized error to user
  if (err instanceof AppError) {
    res.status(err.statusCode).json({
      error: err.message,
      code: err.code,
    });
  } else {
    res.status(500).json({
      error: "An internal error occurred",
      code: "INTERNAL_ERROR",
    });
  }
});
```

---

## 2. Error Monitoring

Use error monitoring services to track errors in production.

### Popular Services

- **Sentry** - Error tracking and performance monitoring
- **LogRocket** - Session replay and error tracking
- **Rollbar** - Real-time error tracking
- **Bugsnag** - Error monitoring and reporting
- **Datadog** - APM and error tracking

### Sentry Example

```javascript
import * as Sentry from "@sentry/browser";

// Initialize
Sentry.init({
  dsn: "your-sentry-dsn",
  environment: "production",
  tracesSampleRate: 0.1, // 10% of transactions
  beforeSend(event, hint) {
    // Filter sensitive data
    if (event.request) {
      delete event.request.cookies;
      delete event.request.headers.Authorization;
    }
    return event;
  },
});

// Capture errors
try {
  riskyOperation();
} catch (error) {
  Sentry.captureException(error, {
    tags: { section: "checkout" },
    extra: { userId: user.id },
  });
}
```

---

## 3. Structured Logging

Use structured logging for better error analysis.

### ❌ Bad

```javascript
console.log("Error:", error);
console.log("User:", user);
```

### ✅ Good

```javascript
logger.error("Payment processing failed", {
  error: {
    message: error.message,
    stack: error.stack,
    code: error.code,
  },
  context: {
    userId: user.id,
    orderId: order.id,
    amount: order.amount,
    paymentMethod: order.paymentMethod,
  },
  timestamp: new Date().toISOString(),
  environment: process.env.NODE_ENV,
});
```

### Using Winston (Node.js)

```javascript
import winston from "winston";

const logger = winston.createLogger({
  level: "error",
  format: winston.format.json(),
  transports: [
    new winston.transports.File({ filename: "error.log" }),
    new winston.transports.Console(),
  ],
});

logger.error("Operation failed", {
  error: error.message,
  stack: error.stack,
  userId: user.id,
});
```

---

## 4. Error Codes and Types

Use error codes for better error handling and user communication.

```javascript
class AppError extends Error {
  constructor(message, code, statusCode = 500, details = {}) {
    super(message);
    this.code = code;
    this.statusCode = statusCode;
    this.details = details;
    this.timestamp = new Date().toISOString();
  }
}

// Usage
throw new AppError("User not found", "USER_NOT_FOUND", 404, { userId: id });

throw new AppError("Payment failed", "PAYMENT_FAILED", 402, {
  orderId: order.id,
  reason: "insufficient_funds",
});
```

---

## 5. Graceful Degradation

Handle errors gracefully to maintain user experience.

```javascript
async function loadUserDashboard(userId) {
  try {
    const [user, posts, notifications] = await Promise.allSettled([
      fetchUser(userId),
      fetchPosts(userId),
      fetchNotifications(userId),
    ]);

    return {
      user: user.status === "fulfilled" ? user.value : null,
      posts: posts.status === "fulfilled" ? posts.value : [],
      notifications:
        notifications.status === "fulfilled" ? notifications.value : [],
      errors: [
        user.status === "rejected" && user.reason,
        posts.status === "rejected" && posts.reason,
        notifications.status === "rejected" && notifications.reason,
      ].filter(Boolean),
    };
  } catch (error) {
    logger.error("Dashboard load failed:", error);
    return {
      user: null,
      posts: [],
      notifications: [],
      errors: [error.message],
    };
  }
}
```

---

## 6. Circuit Breaker Pattern

Prevent cascading failures with circuit breaker pattern.

```javascript
class CircuitBreaker {
  constructor(threshold = 5, timeout = 60000) {
    this.failureCount = 0;
    this.threshold = threshold;
    this.timeout = timeout;
    this.state = "CLOSED"; // CLOSED, OPEN, HALF_OPEN
    this.nextAttempt = Date.now();
  }

  async execute(fn) {
    if (this.state === "OPEN") {
      if (Date.now() < this.nextAttempt) {
        throw new Error("Circuit breaker is OPEN");
      }
      this.state = "HALF_OPEN";
    }

    try {
      const result = await fn();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }

  onSuccess() {
    this.failureCount = 0;
    this.state = "CLOSED";
  }

  onFailure() {
    this.failureCount++;
    if (this.failureCount >= this.threshold) {
      this.state = "OPEN";
      this.nextAttempt = Date.now() + this.timeout;
    }
  }
}

// Usage
const breaker = new CircuitBreaker();

async function callAPI() {
  return breaker.execute(async () => {
    const response = await fetch("/api/data");
    if (!response.ok) throw new Error("API failed");
    return response.json();
  });
}
```

---

## 7. Retry with Exponential Backoff

Retry transient errors with exponential backoff.

```javascript
async function retryWithBackoff(fn, maxRetries = 3, baseDelay = 1000) {
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      if (attempt === maxRetries - 1) throw error;

      // Exponential backoff: 1s, 2s, 4s
      const delay = baseDelay * Math.pow(2, attempt);
      await new Promise((resolve) => setTimeout(resolve, delay));
    }
  }
}

// Usage
const data = await retryWithBackoff(
  () => fetch("/api/data").then((r) => r.json()),
  3,
  1000
);
```

---

## 8. Health Checks

Implement health check endpoints to monitor application status.

```javascript
app.get("/health", (req, res) => {
  const health = {
    status: "ok",
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    database: checkDatabase(),
    cache: checkCache(),
    externalAPI: checkExternalAPI(),
  };

  const isHealthy = Object.values(health).every(
    (v) => v === "ok" || typeof v !== "string"
  );

  res.status(isHealthy ? 200 : 503).json(health);
});
```

---

## 9. Error Rate Monitoring

Monitor error rates to detect issues early.

```javascript
class ErrorRateMonitor {
  constructor(threshold = 0.1, window = 60000) {
    this.errors = [];
    this.threshold = threshold;
    this.window = window;
  }

  recordError() {
    this.errors.push(Date.now());
    this.cleanOldErrors();

    if (this.getErrorRate() > this.threshold) {
      this.alertHighErrorRate();
    }
  }

  getErrorRate() {
    const totalRequests = this.getTotalRequests(); // From your metrics
    return this.errors.length / totalRequests;
  }

  cleanOldErrors() {
    const cutoff = Date.now() - this.window;
    this.errors = this.errors.filter((time) => time > cutoff);
  }

  alertHighErrorRate() {
    // Send alert to monitoring service
    sendAlert({
      type: "HIGH_ERROR_RATE",
      rate: this.getErrorRate(),
      threshold: this.threshold,
    });
  }
}
```

---

## 10. User-Friendly Error Messages

Show user-friendly messages instead of technical errors.

```javascript
const ERROR_MESSAGES = {
  USER_NOT_FOUND:
    "We couldn't find your account. Please check your credentials.",
  NETWORK_ERROR:
    "Connection problem. Please check your internet and try again.",
  SERVER_ERROR: "Something went wrong on our end. We're working on it!",
  VALIDATION_ERROR: "Please check your input and try again.",
  RATE_LIMIT: "Too many requests. Please wait a moment and try again.",
};

function getUserFriendlyMessage(error) {
  if (error instanceof AppError && ERROR_MESSAGES[error.code]) {
    return ERROR_MESSAGES[error.code];
  }
  return ERROR_MESSAGES.SERVER_ERROR;
}

// Usage
try {
  await processRequest();
} catch (error) {
  const message = getUserFriendlyMessage(error);
  showNotification(message);
  logger.error("Request failed:", error);
}
```

---

## 11. Error Recovery Strategies

Implement recovery strategies for different error types.

```javascript
class ErrorRecovery {
  async handleError(error, context) {
    if (error instanceof NetworkError) {
      return this.retryWithBackoff(context.operation);
    }

    if (error instanceof ValidationError) {
      return this.showValidationErrors(error);
    }

    if (error instanceof RateLimitError) {
      return this.waitAndRetry(context.operation);
    }

    // Default: log and show generic message
    logger.error("Unhandled error:", error);
    return this.showGenericError();
  }
}
```

---

## Best Practices Summary

- ✅ **Sanitize errors** - Never expose internal details
- ✅ **Monitor errors** - Use error tracking services
- ✅ **Log structured data** - Include context and metadata
- ✅ **Use error codes** - For better error handling
- ✅ **Graceful degradation** - Maintain user experience
- ✅ **Implement circuit breakers** - Prevent cascading failures
- ✅ **Retry transient errors** - With exponential backoff
- ✅ **Health checks** - Monitor application status
- ✅ **User-friendly messages** - Don't show technical errors
- ✅ **Recovery strategies** - Handle different error types

---

## Related Topics

- [8. Global Error Handlers.md](./8.%20Global%20Error%20Handlers.md) - Global error handling
- [9. Best Practices.md](./9.%20Best%20Practices.md) - General best practices
- [11. Common Interview Questions.md](./11.%20Common%20Interview%20Questions.md) - Interview scenarios
