# Error Handling Best Practices

Following best practices for error handling makes your code more robust, maintainable, and user-friendly.

---

## 1. Always Handle Errors

### ❌ Bad

```javascript
function fetchUser(id) {
  return fetch(`/api/users/${id}`).then((res) => res.json());
  // No error handling!
}
```

### ✅ Good

```javascript
async function fetchUser(id) {
  try {
    const response = await fetch(`/api/users/${id}`);
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    return await response.json();
  } catch (error) {
    console.error("Failed to fetch user:", error);
    throw error; // Re-throw or return null
  }
}
```

---

## 2. Use Specific Error Types

### ❌ Bad

```javascript
throw "Something went wrong"; // String error
throw { error: "Failed" }; // Object error
```

### ✅ Good

```javascript
throw new Error("Something went wrong");
throw new ValidationError("Email is required");
throw new NetworkError("Failed to connect", url);
```

**Benefits:**

- Better debugging (stack traces)
- Can use `instanceof` to check error types
- Consistent error structure

---

## 3. Don't Swallow Errors Silently

### ❌ Bad

```javascript
try {
  importantOperation();
} catch (error) {
  // Silent failure - no one knows what happened!
}
```

### ✅ Good

```javascript
try {
  importantOperation();
} catch (error) {
  // Log the error
  logger.error("Operation failed:", error);

  // Handle appropriately
  showUserMessage("Operation failed. Please try again.");

  // Or re-throw if you can't handle it
  throw error;
}
```

---

## 4. Provide Meaningful Error Messages

### ❌ Bad

```javascript
throw new Error("Error");
throw new Error("Failed");
```

### ✅ Good

```javascript
throw new Error(
  "Failed to connect to database: connection timeout after 5 seconds"
);
throw new ValidationError("Email is required", "email");
throw new TypeError(`Expected number, got ${typeof value}`);
```

---

## 5. Handle Errors at the Right Level

### ❌ Bad

```javascript
// Catching at wrong level
function processData(data) {
  try {
    return data.map((item) => {
      try {
        return item.value.toUpperCase(); // Too nested
      } catch (e) {
        return null;
      }
    });
  } catch (e) {
    return [];
  }
}
```

### ✅ Good

```javascript
// Handle at appropriate level
function processData(data) {
  if (!Array.isArray(data)) {
    throw new TypeError("Expected array");
  }

  return data.map((item) => {
    if (!item?.value) {
      return null; // Handle missing value
    }
    return item.value.toUpperCase();
  });
}
```

---

## 6. Use Try-Catch for Expected Errors

### ✅ Do

```javascript
// Expected errors - handle them
try {
  const data = JSON.parse(userInput);
} catch (error) {
  // User input might be invalid - expected
  return { error: "Invalid JSON" };
}
```

### ❌ Don't

```javascript
// Programming errors - fix the code, don't catch
try {
  const result = obj.property.method(); // If this fails, fix the code!
} catch (error) {
  // This shouldn't fail - fix the bug instead
}
```

---

## 7. Clean Up Resources in Finally

### ✅ Good

```javascript
let fileHandle;
try {
  fileHandle = await openFile("data.txt");
  await processFile(fileHandle);
} catch (error) {
  console.error("File processing failed:", error);
} finally {
  // Always close the file
  if (fileHandle) {
    await fileHandle.close();
  }
}
```

---

## 8. Don't Catch Errors You Can't Handle

### ❌ Bad

```javascript
try {
  criticalOperation();
} catch (error) {
  // Can't actually fix it, just log and continue
  console.log(error);
  // Continue with undefined state - dangerous!
}
```

### ✅ Good

```javascript
try {
  criticalOperation();
} catch (error) {
  // Log the error
  logger.error("Critical operation failed:", error);

  // Can't continue - re-throw or exit
  throw error; // Or process.exit(1) in Node.js
}
```

---

## 9. Use Error Boundaries (React)

In React, use Error Boundaries to catch component errors:

```javascript
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    // Log error to service
    logErrorToService(error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return <h1>Something went wrong.</h1>;
    }
    return this.props.children;
  }
}
```

---

## 10. Validate Input Early

### ❌ Bad

```javascript
function processUser(user) {
  const email = user.email.toLowerCase(); // Might fail
  const age = user.age.toString(); // Might fail
  // ...
}
```

### ✅ Good

```javascript
function processUser(user) {
  if (!user) {
    throw new TypeError("User object is required");
  }
  if (!user.email) {
    throw new ValidationError("Email is required", "email");
  }
  if (typeof user.age !== "number") {
    throw new TypeError("Age must be a number");
  }

  // Now safe to process
  const email = user.email.toLowerCase();
  const age = user.age.toString();
}
```

---

## 11. Use Error Codes for API Responses

```javascript
class AppError extends Error {
  constructor(message, code, statusCode = 500) {
    super(message);
    this.code = code;
    this.statusCode = statusCode;
  }
}

// Usage
throw new AppError("User not found", "USER_NOT_FOUND", 404);
throw new AppError("Invalid credentials", "AUTH_FAILED", 401);
```

---

## 12. Log Errors with Context

### ❌ Bad

```javascript
catch (error) {
  console.log(error); // Not enough context
}
```

### ✅ Good

```javascript
catch (error) {
  logger.error('Failed to process order', {
    error: error.message,
    stack: error.stack,
    orderId: order.id,
    userId: user.id,
    timestamp: new Date().toISOString(),
    environment: process.env.NODE_ENV
  });
}
```

---

## 13. Handle Async Errors Properly

### ✅ Good Patterns

```javascript
// Always handle promise rejections
async function fetchData() {
  try {
    const data = await apiCall();
    return data;
  } catch (error) {
    // Handle error
    logger.error(error);
    return null; // Or throw
  }
}

// Or use .catch()
fetchData()
  .then((data) => process(data))
  .catch((error) => {
    logger.error(error);
    handleError(error);
  });
```

---

## 14. Don't Expose Internal Details

### ❌ Bad

```javascript
// Exposes internal details
res.status(500).json({
  error: err.message,
  stack: err.stack, // Don't expose!
  database: err.query, // Don't expose!
  file: err.filePath, // Don't expose!
});
```

### ✅ Good

```javascript
// User-friendly message
if (process.env.NODE_ENV === "production") {
  res.status(500).json({
    error: "An internal error occurred",
    code: "INTERNAL_ERROR",
  });
} else {
  // Development - show more details
  res.status(500).json({
    error: err.message,
    stack: err.stack,
  });
}
```

---

## 15. Use Retry Logic for Transient Errors

```javascript
async function fetchWithRetry(url, maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fetch(url);
    } catch (error) {
      if (i === maxRetries - 1) throw error;
      await sleep(1000 * (i + 1)); // Exponential backoff
    }
  }
}
```

---

## Summary Checklist

- ✅ Always handle errors (don't ignore them)
- ✅ Use specific error types (Error, TypeError, etc.)
- ✅ Provide meaningful error messages
- ✅ Log errors with context
- ✅ Clean up resources in finally blocks
- ✅ Don't expose internal details to users
- ✅ Handle errors at the right level
- ✅ Validate input early
- ✅ Use error boundaries (React)
- ✅ Handle async errors properly

---

## Related Topics

- [3. Try Catch.md](./3.%20Try%20Catch.md) - Error handling basics
- [4. Async Error Handling.md](./4.%20Async%20Error%20Handling.md) - Async error patterns
- [10. Production Error Handling.md](./10.%20Production%20Error%20Handling.md) - Production strategies
