# Common Interview Questions: Error Handling & Debugging

This document covers frequently asked interview questions about error handling and debugging in JavaScript.

---

## üî∑ 1. Error Basics

### Q1: What's the difference between Error and Exception?

**Answer:**

In JavaScript, **Error** and **Exception** are the same thing. The term "exception" is more common in other languages (Java, Python), while JavaScript uses "Error".

- Both refer to runtime problems that interrupt normal execution
- Both can be thrown and caught
- JavaScript's base class is `Error`, not `Exception`

---

### Q2: What happens when an error is thrown?

**Answer:**

1. **Current execution stops** - The function where error occurred stops
2. **Call stack unwinding** - JavaScript looks up the call stack for a handler
3. **Handler search** - Checks each execution context for a `catch` block
4. **Runtime handling** - If no handler found:
   - Browser: Calls `window.onerror()`
   - Node.js: Calls `process.on('uncaughtException')`

```javascript
function a() {
  b(); // Error propagates up
}

function b() {
  c(); // Error propagates up
}

function c() {
  throw new Error("Error!"); // Error starts here
}

a(); // Error bubbles up: c ‚Üí b ‚Üí a ‚Üí global
```

---

## üî∑ 2. Try-Catch Questions

### Q3: Why doesn't try-catch work with setTimeout?

**Answer:**

Try-catch only works with **synchronous code**. `setTimeout` executes asynchronously, so by the time the error occurs, the try-catch block has already finished.

```javascript
// ‚ùå Won't catch the error
try {
  setTimeout(() => {
    throw new Error("Error!");
  }, 1000);
} catch (e) {
  console.log("Caught:", e); // Never executes
}

// ‚úÖ Solution: Handle inside setTimeout
setTimeout(() => {
  try {
    throw new Error("Error!");
  } catch (e) {
    console.log("Caught:", e); // Works!
  }
}, 1000);
```

---

### Q4: What does the `finally` block do?

**Answer:**

The `finally` block **always executes**, regardless of whether an error occurred or not. It's useful for cleanup operations.

```javascript
function example() {
  try {
    return "success";
  } catch (error) {
    return "error";
  } finally {
    console.log("Always runs"); // Executes even with return
  }
}
```

**Key points:**

- Executes even if there's a `return` in try/catch
- Executes even if an error is thrown
- If `finally` has a `return`, it overrides try/catch returns

---

## üî∑ 3. Error Types

### Q5: What are the different built-in error types?

**Answer:**

| Type             | When It Occurs                         |
| ---------------- | -------------------------------------- |
| `Error`          | Generic error (base class)             |
| `TypeError`      | Wrong type operation (`null.property`) |
| `ReferenceError` | Undefined variable                     |
| `SyntaxError`    | Syntax mistake                         |
| `RangeError`     | Out of range value (`new Array(-1)`)   |
| `URIError`       | URI encoding/decoding error            |
| `EvalError`      | eval() error (rare)                    |

```javascript
// TypeError
null.property; // TypeError

// ReferenceError
undefinedVariable; // ReferenceError

// RangeError
new Array(-1); // RangeError

// SyntaxError
eval("function test("); // SyntaxError
```

---

### Q6: How do you check error types?

**Answer:**

Use `instanceof` to check error types:

```javascript
try {
  riskyOperation();
} catch (error) {
  if (error instanceof TypeError) {
    // Handle TypeError
  } else if (error instanceof ReferenceError) {
    // Handle ReferenceError
  } else {
    // Handle other errors
  }
}
```

---

## üî∑ 4. Async Error Handling

### Q7: How do you handle errors in Promises?

**Answer:**

**Method 1: `.catch()` method**

```javascript
Promise.resolve()
  .then(() => {
    throw new Error("Error!");
  })
  .catch((error) => {
    console.log("Caught:", error);
  });
```

**Method 2: async/await with try-catch**

```javascript
async function example() {
  try {
    await somePromise();
  } catch (error) {
    console.log("Caught:", error);
  }
}
```

---

### Q8: What happens to unhandled promise rejections?

**Answer:**

Unhandled promise rejections trigger:

- **Browser**: `unhandledrejection` event
- **Node.js**: `unhandledRejection` event (crashes process in Node 15+)

```javascript
// Browser
window.addEventListener("unhandledrejection", (event) => {
  console.log("Unhandled rejection:", event.reason);
});

// Node.js
process.on("unhandledRejection", (reason, promise) => {
  console.log("Unhandled rejection:", reason);
});
```

---

### Q9: How do you handle errors in Promise.all?

**Answer:**

**Promise.all** - If any promise rejects, all fail:

```javascript
Promise.all([promise1, promise2, promise3])
  .then((results) => {
    // All succeeded
  })
  .catch((error) => {
    // Any one failed
  });
```

**Promise.allSettled** - Handle errors individually:

```javascript
Promise.allSettled([promise1, promise2, promise3]).then((results) => {
  results.forEach((result, index) => {
    if (result.status === "fulfilled") {
      console.log(`Promise ${index} succeeded`);
    } else {
      console.log(`Promise ${index} failed:`, result.reason);
    }
  });
});
```

---

## üî∑ 5. Custom Errors

### Q10: How do you create custom error classes?

**Answer:**

Extend the `Error` class:

```javascript
class ValidationError extends Error {
  constructor(message, field) {
    super(message);
    this.name = "ValidationError";
    this.field = field;
  }
}

// Usage
throw new ValidationError("Email is required", "email");
```

---

## üî∑ 6. Debugging Questions

### Q11: What's the difference between console.log and debugger?

**Answer:**

- **`console.log()`** - Prints values to console, doesn't pause execution
- **`debugger`** - Pauses execution when DevTools is open, allows step-through debugging

```javascript
// console.log - just prints
console.log(variable); // Prints value, continues execution

// debugger - pauses execution
debugger; // Execution stops here if DevTools open
```

---

### Q12: How do you debug async code?

**Answer:**

1. **Use async/await** - Makes debugging easier
2. **Add breakpoints** - In DevTools Sources tab
3. **Use console.trace()** - See call stack
4. **Log at key points** - Track async flow

```javascript
async function debugAsync() {
  console.log("Step 1");
  const data = await fetchData();
  console.log("Step 2:", data);
  const processed = await processData(data);
  console.log("Step 3:", processed);
}
```

---

## üî∑ 7. Tricky Scenarios

### Q13: What will this code output?

```javascript
try {
  setTimeout(() => {
    throw new Error("Error!");
  }, 1000);
  console.log("After setTimeout");
} catch (e) {
  console.log("Caught:", e);
}
```

**Answer:**

```
After setTimeout
// (1 second later) Uncaught Error: Error!
```

The error is **not caught** because it occurs after the try-catch block has finished.

---

### Q14: What will this code output?

```javascript
function test() {
  try {
    return "try";
  } catch (e) {
    return "catch";
  } finally {
    return "finally";
  }
}
console.log(test());
```

**Answer:**

```
"finally"
```

The `finally` block's return **overrides** the try block's return.

---

### Q15: How do you handle errors in a loop?

**Answer:**

Handle errors inside the loop to continue processing:

```javascript
const items = [1, 2, 3, null, 5];

for (const item of items) {
  try {
    console.log(item.toUpperCase());
  } catch (error) {
    console.log(`Error processing ${item}:`, error.message);
    // Continue with next item
  }
}
```

---

## üî∑ 8. Production Questions

### Q16: How do you handle errors in production?

**Answer:**

1. **Sanitize errors** - Don't expose internal details
2. **Log to monitoring service** - Use Sentry, LogRocket, etc.
3. **Show user-friendly messages** - Not technical errors
4. **Set up global handlers** - Catch unhandled errors
5. **Use error codes** - For better error handling

```javascript
// Production error handler
app.use((err, req, res, next) => {
  // Log internally
  logger.error("Error:", {
    message: err.message,
    stack: err.stack,
    url: req.url,
  });

  // Send sanitized error
  res.status(500).json({
    error: "An error occurred",
    code: "INTERNAL_ERROR",
  });
});
```

---

### Q17: What's the circuit breaker pattern?

**Answer:**

Circuit breaker prevents cascading failures by "opening" after too many failures:

```javascript
class CircuitBreaker {
  constructor(threshold = 5) {
    this.failureCount = 0;
    this.threshold = threshold;
    this.state = "CLOSED"; // CLOSED, OPEN, HALF_OPEN
  }

  async execute(fn) {
    if (this.state === "OPEN") {
      throw new Error("Circuit breaker is OPEN");
    }

    try {
      const result = await fn();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }

  onSuccess() {
    this.failureCount = 0;
    this.state = "CLOSED";
  }

  onFailure() {
    this.failureCount++;
    if (this.failureCount >= this.threshold) {
      this.state = "OPEN";
    }
  }
}
```

---

## üî∑ 9. Best Practices

### Q18: When should you re-throw an error?

**Answer:**

Re-throw when you can't handle the error meaningfully:

```javascript
try {
  criticalOperation();
} catch (error) {
  // Log the error
  logger.error("Operation failed:", error);

  // Can't fix it - re-throw
  throw error; // Let caller handle it
}
```

**Don't re-throw** if you've handled it:

```javascript
try {
  parseUserInput(input);
} catch (error) {
  // We can handle this - show user message
  showError("Invalid input");
  // Don't re-throw - we've handled it
}
```

---

### Q19: How do you prevent error swallowing?

**Answer:**

1. **Always log errors** - Even if you handle them
2. **Don't use empty catch blocks** - At least log the error
3. **Use linting rules** - ESLint rule: `no-empty`

```javascript
// ‚ùå Bad - swallows error
try {
  operation();
} catch (e) {
  // Empty - bad!
}

// ‚úÖ Good - logs error
try {
  operation();
} catch (e) {
  logger.error("Operation failed:", e);
  // Handle appropriately
}
```

---

## üî∑ 10. Debugging Scenarios

### Q20: How do you debug a "Cannot read property of undefined" error?

**Answer:**

1. **Check the property chain** - Which property is undefined?
2. **Use optional chaining** - `obj?.property?.method()`
3. **Add defensive checks** - Validate before accessing
4. **Use console.log** - Log intermediate values

```javascript
// Problem
user.profile.name; // TypeError: Cannot read property 'name' of undefined

// Debug
console.log("user:", user);
console.log("user.profile:", user?.profile);
console.log("user.profile.name:", user?.profile?.name);

// Fix
const name = user?.profile?.name || "Unknown";
```

---

## Summary

Key topics to remember:

- ‚úÖ Error types and when they occur
- ‚úÖ Try-catch limitations with async code
- ‚úÖ Promise error handling patterns
- ‚úÖ Custom error classes
- ‚úÖ Debugging techniques
- ‚úÖ Production error handling
- ‚úÖ Best practices and patterns

---

## Related Topics

- [2. Errors in javascript.md](./2.%20Errors%20in%20javascript.md) - Error basics
- [3. Try Catch.md](./3.%20Try%20Catch.md) - Error handling
- [6. Debugging.md](./6.%20Debugging.md) - Debugging techniques
- [9. Best Practices.md](./9.%20Best%20Practices.md) - Best practices
