# Type Checking Guide: Comprehensive Methods

This guide covers all methods for checking data types in JavaScript, when to use each, and their limitations.

---

## ğŸ”· 1. `typeof` Operator

### Basic Usage

```js
typeof "hello"; // "string"
typeof 42; // "number"
typeof true; // "boolean"
typeof undefined; // "undefined"
typeof Symbol(); // "symbol"
typeof 123n; // "bigint"
typeof function () {}; // "function"
typeof {}; // "object"
typeof []; // "object" (limitation!)
typeof null; // "object" (bug!)
```

### Limitations

```js
// âŒ Doesn't distinguish arrays from objects
typeof [] === "object"; // true
typeof {} === "object"; // true

// âŒ null returns "object" (historical bug)
typeof null === "object"; // true (should be "null")

// âŒ Doesn't distinguish object types
typeof new Date() === "object"; // true
typeof /regex/ === "object"; // true
typeof new Map() === "object"; // true
```

### When to Use

âœ… **Good for:**

- Checking primitives (string, number, boolean, undefined, symbol, bigint)
- Checking if something is a function
- Quick type checks for primitives

âŒ **Avoid for:**

- Arrays (use `Array.isArray()`)
- null (use `=== null`)
- Distinguishing object types (use `Object.prototype.toString.call()`)

---

## ğŸ”· 2. `instanceof` Operator

### Basic Usage

```js
[] instanceof Array           // true
{} instanceof Object          // true
new Date() instanceof Date    // true
/regex/ instanceof RegExp    // true
new Map() instanceof Map     // true

// Functions
function fn() {}
fn instanceof Function        // true

// Classes
class MyClass {}
new MyClass() instanceof MyClass  // true
```

### Limitations

```js
// âŒ Doesn't work across different execution contexts/frames
// (e.g., iframes, different windows)

// âŒ Primitives don't work (unless boxed)
"hello" instanceof String; // false
new String("hello") instanceof String; // true

// âŒ null and undefined
null instanceof Object; // false
undefined instanceof Object; // false
```

### When to Use

âœ… **Good for:**

- Checking if object is instance of a class/constructor
- Custom classes and constructors
- Built-in objects (Date, RegExp, Map, Set, etc.)

âŒ **Avoid for:**

- Primitives
- Arrays (use `Array.isArray()` - more reliable)
- Cross-frame scenarios

---

## ğŸ”· 3. `Array.isArray()`

### Basic Usage

```js
Array.isArray([]); // true
Array.isArray({}); // false
Array.isArray("hello"); // false
Array.isArray(null); // false
Array.isArray(undefined); // false
```

### Why Use This Instead of `instanceof`?

```js
// Works across different execution contexts
let iframe = document.createElement("iframe");
document.body.appendChild(iframe);
let iframeArray = iframe.contentWindow.Array;
let arr = new iframeArray();

arr instanceof Array; // false (different context)
Array.isArray(arr); // true âœ…
```

### When to Use

âœ… **Always use this for arrays** - Most reliable method

---

## ğŸ”· 4. `Object.prototype.toString.call()`

### Basic Usage

```js
Object.prototype.toString.call([]); // "[object Array]"
Object.prototype.toString.call({}); // "[object Object]"
Object.prototype.toString.call(null); // "[object Null]"
Object.prototype.toString.call(undefined); // "[object Undefined]"
Object.prototype.toString.call(new Date()); // "[object Date]"
Object.prototype.toString.call(/regex/); // "[object RegExp]"
Object.prototype.toString.call(new Map()); // "[object Map]"
Object.prototype.toString.call(new Set()); // "[object Set]"
Object.prototype.toString.call("hello"); // "[object String]"
Object.prototype.toString.call(42); // "[object Number]"
Object.prototype.toString.call(true); // "[object Boolean]"
Object.prototype.toString.call(Symbol()); // "[object Symbol]"
Object.prototype.toString.call(123n); // "[object BigInt]"
Object.prototype.toString.call(function () {}); // "[object Function]"
```

### Creating a Type Checker Function

```js
function getType(value) {
  return Object.prototype.toString.call(value).slice(8, -1).toLowerCase();
}

getType([]); // "array"
getType({}); // "object"
getType(null); // "null"
getType(new Date()); // "date"
```

### When to Use

âœ… **Best for:**

- Getting accurate type information for any value
- Distinguishing between different object types
- Creating comprehensive type checking utilities

---

## ğŸ”· 5. `===` (Strict Equality) for Specific Values

### Basic Usage

```js
// null check
value === null; // true only if value is null

// undefined check
value === undefined; // true only if value is undefined

// NaN check (doesn't work!)
NaN === NaN; // false (always!)
Number.isNaN(NaN); // true (use this instead)
```

### When to Use

âœ… **Use for:**

- Checking `null` explicitly
- Checking `undefined` explicitly
- Type-safe comparisons

---

## ğŸ”· 6. `Number.isNaN()` vs `isNaN()`

### Difference

```js
// isNaN() - Coerces to number first
isNaN(NaN); // true
isNaN("hello"); // true (problematic!)
isNaN("123"); // false (coerced to 123)
isNaN(undefined); // true (coerced to NaN)

// Number.isNaN() - Only true for actual NaN
Number.isNaN(NaN); // true
Number.isNaN("hello"); // false âœ…
Number.isNaN("123"); // false âœ…
Number.isNaN(undefined); // false âœ…
```

### When to Use

âœ… **Always use `Number.isNaN()`** - More accurate

âŒ **Avoid `isNaN()`** - Can give false positives

---

## ğŸ”· 7. `Number.isFinite()` vs `isFinite()`

### Difference

```js
// isFinite() - Coerces to number first
isFinite(42); // true
isFinite("42"); // true (coerced)
isFinite(Infinity); // false
isFinite(null); // true (coerced to 0)

// Number.isFinite() - Only true for actual finite numbers
Number.isFinite(42); // true
Number.isFinite("42"); // false âœ…
Number.isFinite(Infinity); // false
Number.isFinite(null); // false âœ…
```

### When to Use

âœ… **Use `Number.isFinite()`** for accurate checks

---

## ğŸ”· 8. `Number.isInteger()`

### Basic Usage

```js
Number.isInteger(42); // true
Number.isInteger(42.0); // true
Number.isInteger(42.5); // false
Number.isInteger("42"); // false
Number.isInteger(NaN); // false
Number.isInteger(Infinity); // false
```

### When to Use

âœ… **Use when you need to verify a value is an integer**

---

## ğŸ”· 9. Custom Type Checking Functions

### Comprehensive Type Checker

```js
function getType(value) {
  // Handle null first (typeof bug)
  if (value === null) return "null";

  // Handle primitives
  let primitiveType = typeof value;
  if (primitiveType !== "object") return primitiveType;

  // Handle objects - use toString
  let toString = Object.prototype.toString.call(value);
  return toString.slice(8, -1).toLowerCase();
}

// Usage
getType([]); // "array"
getType({}); // "object"
getType(null); // "null"
getType(undefined); // "undefined"
getType(new Date()); // "date"
getType(/regex/); // "regexp"
getType(new Map()); // "map"
getType(new Set()); // "set"
```

### Type-Specific Checkers

```js
// Plain object (not array, not null, not Date, etc.)
function isPlainObject(value) {
  return (
    typeof value === "object" &&
    value !== null &&
    !Array.isArray(value) &&
    Object.getPrototypeOf(value) === Object.prototype
  );
}

// Number (excluding NaN, Infinity)
function isNumber(value) {
  return typeof value === "number" && Number.isFinite(value);
}

// String (not String object)
function isString(value) {
  return typeof value === "string";
}

// Boolean (not Boolean object)
function isBoolean(value) {
  return typeof value === "boolean";
}

// Function
function isFunction(value) {
  return typeof value === "function";
}

// Array
function isArray(value) {
  return Array.isArray(value);
}

// Null
function isNull(value) {
  return value === null;
}

// Undefined
function isUndefined(value) {
  return value === undefined;
}
```

---

## ğŸ”· 10. Type Checking Patterns

### Pattern 1: Type Guard Functions

```js
function isUser(value) {
  return (
    isPlainObject(value) &&
    typeof value.name === "string" &&
    typeof value.age === "number"
  );
}

function processUser(data) {
  if (isUser(data)) {
    // TypeScript/IDE knows data is User here
    console.log(data.name); // Safe
  }
}
```

### Pattern 2: Assertion Functions

```js
function assertIsArray(value) {
  if (!Array.isArray(value)) {
    throw new TypeError(`Expected array, got ${typeof value}`);
  }
}

function processItems(items) {
  assertIsArray(items); // Throws if not array
  return items.map((x) => x * 2);
}
```

### Pattern 3: Type Coercion with Validation

```js
function toNumber(value) {
  if (typeof value === "number") return value;
  if (typeof value === "string") {
    let num = Number(value);
    if (Number.isNaN(num)) {
      throw new TypeError(`Cannot convert "${value}" to number`);
    }
    return num;
  }
  throw new TypeError(`Cannot convert ${typeof value} to number`);
}
```

---

## ğŸ”· 11. Type Checking for Specific Scenarios

### Check if Value is Empty

```js
function isEmpty(value) {
  if (value === null || value === undefined) return true;
  if (Array.isArray(value) || typeof value === "string") {
    return value.length === 0;
  }
  if (isPlainObject(value)) {
    return Object.keys(value).length === 0;
  }
  return false;
}
```

### Check if Value is Iterable

```js
function isIterable(value) {
  return value != null && typeof value[Symbol.iterator] === "function";
}

isIterable([]); // true
isIterable("hello"); // true
isIterable(new Map()); // true
isIterable({}); // false
```

### Check if Value is Promise-like

```js
function isPromise(value) {
  return (
    value != null &&
    typeof value.then === "function" &&
    typeof value.catch === "function"
  );
}
```

---

## ğŸ”· 12. Comparison Table

| Method                             | Primitives | Arrays | Objects | null | Custom Types | Cross-Frame |
| ---------------------------------- | ---------- | ------ | ------- | ---- | ------------ | ----------- |
| `typeof`                           | âœ…         | âŒ     | âš ï¸      | âŒ   | âŒ           | âœ…          |
| `instanceof`                       | âŒ         | âš ï¸     | âœ…      | âŒ   | âœ…           | âŒ          |
| `Array.isArray()`                  | âŒ         | âœ…     | âŒ      | âŒ   | âŒ           | âœ…          |
| `Object.prototype.toString.call()` | âœ…         | âœ…     | âœ…      | âœ…   | âœ…           | âœ…          |
| `=== null`                         | âœ…         | âŒ     | âŒ      | âœ…   | âŒ           | âœ…          |
| `Number.isNaN()`                   | âœ…         | âŒ     | âŒ      | âŒ   | âŒ           | âœ…          |

---

## âœ… Best Practices Summary

1. **For arrays:** Always use `Array.isArray()`
2. **For null:** Use `value === null`
3. **For undefined:** Use `value === undefined`
4. **For NaN:** Use `Number.isNaN()`
5. **For general type checking:** Use `Object.prototype.toString.call()`
6. **For primitives:** `typeof` is fine
7. **For custom classes:** `instanceof` works well
8. **For comprehensive checking:** Create custom type checker functions

---

## ğŸ¯ Interview Tips

1. **Know the limitations** - `typeof null`, `typeof []`, etc.
2. **Explain why** - Historical bugs, cross-frame issues
3. **Show alternatives** - Multiple ways to check types
4. **Discuss trade-offs** - Performance, reliability, readability

---

ğŸ’¡ **Pro Tip:** In interviews, mention that `Object.prototype.toString.call()` is the most reliable method for getting accurate type information, but `Array.isArray()` is preferred for arrays due to readability and cross-frame compatibility.
