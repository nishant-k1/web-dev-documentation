# Common Mistakes and Best Practices: Data Types

This document outlines common pitfalls, mistakes, and best practices when working with JavaScript data types in real-world development and interviews.

---

## üî¥ Common Mistakes

### 1. Using `==` Instead of `===`

**Mistake:**

```js
if (user.age == "25") {
  // Dangerous!
  // This might work, but can cause bugs
}
```

**Best Practice:**

```js
if (user.age === 25) {
  // Always use ===
  // Predictable behavior
}
```

**Why:** `==` performs type coercion which can lead to unexpected results. Always use `===` for strict equality.

---

### 2. Mutating Arrays When You Shouldn't

**Mistake:**

```js
function processItems(items) {
  items.sort(); // Mutates original!
  return items.map((x) => x * 2);
}

let arr = [3, 1, 2];
processItems(arr);
console.log(arr); // [1, 2, 3] - original changed!
```

**Best Practice:**

```js
function processItems(items) {
  let sorted = [...items].sort(); // Create copy first
  return sorted.map((x) => x * 2);
}

let arr = [3, 1, 2];
let result = processItems(arr);
console.log(arr); // [3, 1, 2] - original unchanged
```

**Why:** Mutating shared data can cause bugs in other parts of your code. Prefer immutability.

---

### 3. Using `isNaN()` Instead of `Number.isNaN()`

**Mistake:**

```js
function validateNumber(value) {
  if (isNaN(value)) {
    // Problematic!
    return "Invalid number";
  }
  return value;
}

validateNumber("hello"); // "Invalid number" ‚úÖ
validateNumber("123"); // "Invalid number" ‚ùå (should be valid!)
```

**Best Practice:**

```js
function validateNumber(value) {
  if (Number.isNaN(value)) {
    // Correct!
    return "Invalid number";
  }
  return value;
}

validateNumber("hello"); // "Invalid number" ‚úÖ
validateNumber("123"); // "123" ‚úÖ
```

**Why:** `isNaN()` coerces to number first, while `Number.isNaN()` checks if value is actually `NaN`.

---

### 4. Shallow Copy When You Need Deep Copy

**Mistake:**

```js
let original = { a: 1, b: { c: 2 } };
let copy = { ...original }; // Shallow copy
copy.b.c = 3;
console.log(original.b.c); // 3 - original changed!
```

**Best Practice:**

```js
// Method 1: structuredClone (modern browsers)
let copy = structuredClone(original);

// Method 2: JSON methods (limited - no functions, dates, etc.)
let copy = JSON.parse(JSON.stringify(original));

// Method 3: Library (Lodash)
let copy = _.cloneDeep(original);
```

**Why:** Shallow copy only copies top-level properties. Nested objects still share references.

---

### 5. Using `typeof` for Array/Null Checks

**Mistake:**

```js
if (typeof arr === "object") {
  // Wrong!
  // This matches arrays, objects, null, etc.
}

if (typeof value === "object" && value !== null) {
  // Better, but...
  // Still doesn't distinguish array from object
}
```

**Best Practice:**

```js
// For arrays
if (Array.isArray(arr)) {
  // Correct!
  // Handle array
}

// For null
if (value === null) {
  // Correct!
  // Handle null
}

// For objects (excluding arrays and null)
if (typeof value === "object" && value !== null && !Array.isArray(value)) {
  // Handle plain object
}
```

---

### 6. Not Understanding Reference vs Value

**Mistake:**

```js
let config = { theme: "dark" };
let userConfig = config; // Reference copy
userConfig.theme = "light";
console.log(config.theme); // "light" - unexpected!
```

**Best Practice:**

```js
let config = { theme: "dark" };
let userConfig = { ...config }; // Shallow copy
userConfig.theme = "light";
console.log(config.theme); // "dark" - correct!
```

**Why:** Objects are passed by reference. Changing one affects the other unless you create a copy.

---

### 7. Using `Object.freeze()` Thinking It's Deep

**Mistake:**

```js
let obj = { a: { b: 1 } };
Object.freeze(obj);
obj.a.b = 2; // Still works! (nested not frozen)
console.log(obj.a.b); // 2
```

**Best Practice:**

```js
// Deep freeze function
function deepFreeze(obj) {
  Object.freeze(obj);
  Object.keys(obj).forEach((key) => {
    if (typeof obj[key] === "object" && obj[key] !== null) {
      deepFreeze(obj[key]);
    }
  });
  return obj;
}

let obj = { a: { b: 1 } };
deepFreeze(obj);
obj.a.b = 2; // Fails (in strict mode) or silently ignored
```

---

### 8. Comparing Objects/Arrays with `===`

**Mistake:**

```js
let arr1 = [1, 2, 3];
let arr2 = [1, 2, 3];
if (arr1 === arr2) {
  // Always false!
  // This never executes
}
```

**Best Practice:**

```js
// For shallow equality
function shallowEqual(arr1, arr2) {
  if (arr1.length !== arr2.length) return false;
  return arr1.every((val, idx) => val === arr2[idx]);
}

// For deep equality (use library)
import { isEqual } from "lodash";
if (isEqual(arr1, arr2)) {
  // Deep comparison
}
```

---

### 9. Not Handling `undefined` vs `null` Properly

**Mistake:**

```js
function getUser(id) {
  // Returns undefined if not found
}

let user = getUser(999);
console.log(user.name); // TypeError: Cannot read property 'name' of undefined
```

**Best Practice:**

```js
function getUser(id) {
  // Return null for "not found" (explicit)
  return null;
}

let user = getUser(999);
if (user === null) {
  // Handle not found
} else {
  console.log(user.name); // Safe
}

// Or use optional chaining
console.log(user?.name); // undefined if user is null/undefined
```

---

### 10. Using `delete` on Array Elements

**Mistake:**

```js
let arr = [1, 2, 3, 4];
delete arr[1]; // Creates sparse array
console.log(arr); // [1, empty, 3, 4]
console.log(arr.length); // 4 (length unchanged!)
```

**Best Practice:**

```js
// Remove element (mutating)
arr.splice(1, 1); // [1, 3, 4]

// Remove element (non-mutating)
let filtered = arr.filter((_, idx) => idx !== 1); // [1, 3, 4]
```

---

## ‚úÖ Best Practices

### 1. Always Use Strict Equality (`===`)

```js
// ‚úÖ Good
if (value === 5) {
}
if (value === null) {
}
if (value === undefined) {
}

// ‚ùå Avoid
if (value == 5) {
}
```

**Exception:** Only use `==` when you explicitly need coercion (rare).

---

### 2. Prefer Immutability

```js
// ‚úÖ Good - Non-mutating
let doubled = numbers.map((n) => n * 2);
let filtered = items.filter((item) => item.active);
let sorted = [...arr].sort();

// ‚ùå Avoid - Mutating
numbers.forEach((n, i) => (numbers[i] = n * 2));
arr.sort(); // Mutates original
```

**Why:** Immutability makes code predictable, easier to debug, and works better with React/Redux.

---

### 3. Use Appropriate Data Structures

```js
// ‚úÖ Use Set for unique values
let uniqueIds = new Set([1, 2, 2, 3]); // [1, 2, 3]
if (uniqueIds.has(id)) {
} // O(1) lookup

// ‚úÖ Use Map for key-value pairs (when keys aren't strings)
let userMap = new Map();
userMap.set(userId, userData);

// ‚úÖ Use Object for simple key-value pairs
let config = { theme: "dark", lang: "en" };
```

---

### 4. Validate Input Types

```js
// ‚úÖ Good
function calculateTotal(items) {
  if (!Array.isArray(items)) {
    throw new TypeError("items must be an array");
  }
  return items.reduce((sum, item) => sum + item.price, 0);
}

// ‚ùå Bad
function calculateTotal(items) {
  return items.reduce((sum, item) => sum + item.price, 0);
  // Crashes if items is not an array
}
```

---

### 5. Use Type Checking Helpers

```js
// ‚úÖ Create utility functions
function isPlainObject(value) {
  return (
    typeof value === "object" &&
    value !== null &&
    !Array.isArray(value) &&
    Object.getPrototypeOf(value) === Object.prototype
  );
}

function isNumber(value) {
  return typeof value === "number" && !Number.isNaN(value);
}

// Use them
if (isPlainObject(data)) {
  // Handle object
}
```

---

### 6. Handle Edge Cases

```js
// ‚úÖ Good - Handle edge cases
function safeDivide(a, b) {
  if (!isNumber(a) || !isNumber(b)) {
    throw new TypeError("Arguments must be numbers");
  }
  if (b === 0) {
    throw new Error("Division by zero");
  }
  return a / b;
}

// Handle NaN
if (Number.isNaN(result)) {
  // Handle invalid calculation
}
```

---

### 7. Use Default Parameters Wisely

```js
// ‚úÖ Good
function createUser(name, age = 0, active = true) {
  return { name, age, active };
}

// ‚ùå Avoid
function createUser(name, age, active) {
  age = age || 0; // Problem: 0 is falsy!
  active = active || true; // Problem: false becomes true!
  return { name, age, active };
}
```

---

### 8. Prefer `const` for Non-Primitives Too

```js
// ‚úÖ Good - const prevents re-assignment, but allows mutation
const users = [];
users.push(newUser); // ‚úÖ Allowed (mutation)

const config = { theme: "dark" };
config.theme = "light"; // ‚úÖ Allowed (mutation)

// ‚ùå Avoid - Don't re-assign
users = []; // ‚ùå Error (re-assignment)
config = {}; // ‚ùå Error (re-assignment)
```

**Why:** `const` prevents accidental re-assignment while still allowing mutation when needed.

---

### 9. Use Structured Clone for Deep Copy

```js
// ‚úÖ Good - Modern approach
let deepCopy = structuredClone(original);

// ‚úÖ Good - JSON (with limitations)
let deepCopy = JSON.parse(JSON.stringify(original));
// Limitations: No functions, dates, undefined, symbols, etc.

// ‚ùå Avoid - Shallow copy when you need deep
let shallowCopy = { ...original }; // Only top level
```

---

### 10. Document Type Expectations

```js
// ‚úÖ Good - JSDoc comments
/**
 * Calculates the total price of items
 * @param {Array<{price: number}>} items - Array of items with price property
 * @returns {number} Total price
 */
function calculateTotal(items) {
  return items.reduce((sum, item) => sum + item.price, 0);
}

// Or use TypeScript for compile-time checking
function calculateTotal(items: Array<{ price: number }>): number {
  return items.reduce((sum, item) => sum + item.price, 0);
}
```

---

## üöÄ Performance Best Practices

### 1. Use Set for Membership Checks

```js
// ‚úÖ Good - O(1) lookup
let allowedIds = new Set([1, 2, 3, 4, 5]);
if (allowedIds.has(userId)) {
}

// ‚ùå Avoid - O(n) lookup
let allowedIds = [1, 2, 3, 4, 5];
if (allowedIds.includes(userId)) {
}
```

---

### 2. Pre-allocate Arrays When Size is Known

```js
// ‚úÖ Good - Pre-allocated
let results = new Array(1000);
for (let i = 0; i < 1000; i++) {
  results[i] = process(i);
}

// ‚ùå Avoid - Dynamic growth
let results = [];
for (let i = 0; i < 1000; i++) {
  results.push(process(i)); // Slower
}
```

---

### 3. Use Map for Frequent Add/Remove

```js
// ‚úÖ Good - Map is optimized for frequent changes
let cache = new Map();
cache.set(key, value);
cache.delete(key);

// ‚ùå Avoid - Object property deletion is slower
let cache = {};
cache[key] = value;
delete cache[key]; // Slower
```

---

### 4. Avoid Unnecessary Type Coercion

```js
// ‚úÖ Good - Direct comparison
if (value === 5) {
}

// ‚ùå Avoid - Unnecessary coercion
if (Number(value) === 5) {
}
if (String(value) === "5") {
}
```

---

## üéØ Interview-Specific Tips

1. **Always explain your reasoning** - Show you understand _why_, not just _what_
2. **Mention edge cases** - `null`, `undefined`, `NaN`, empty arrays/objects
3. **Discuss trade-offs** - When to use `Map` vs `Object`, `Set` vs `Array`
4. **Show awareness of performance** - Time/space complexity considerations
5. **Prefer modern methods** - `structuredClone()`, `Number.isNaN()`, `Array.isArray()`
6. **Demonstrate immutability awareness** - Critical for React/Redux interviews

---

üí° **Remember:** In interviews, showing you understand the _principles_ (reference vs value, immutability, type coercion) is more valuable than memorizing syntax.
