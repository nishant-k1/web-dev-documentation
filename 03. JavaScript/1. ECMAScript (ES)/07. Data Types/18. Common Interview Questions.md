# Common Interview Questions: Data Types

This document consolidates frequently asked interview questions about JavaScript data types, type coercion, primitives vs non-primitives, and related concepts.

---

## ðŸ”· 1. Primitive vs Non-Primitive Questions

### Q1: What's the difference between primitives and non-primitives?

**Answer:**

- **Primitives**: Immutable, stored by value, compared by value, fixed size
- **Non-primitives**: Mutable, stored by reference, compared by reference, dynamic size

```js
// Primitives - compared by value
let a = 5;
let b = 5;
console.log(a === b); // true

// Non-primitives - compared by reference
let obj1 = { x: 5 };
let obj2 = { x: 5 };
console.log(obj1 === obj2); // false (different references)
```

---

### Q2: What happens when you copy a primitive vs a non-primitive?

**Answer:**

- **Primitive**: Creates an independent copy
- **Non-primitive**: Copies the reference (both point to same object)

```js
// Primitive copy
let a = 10;
let b = a;
b = 20;
console.log(a); // 10 (unchanged)

// Non-primitive copy
let obj1 = { x: 10 };
let obj2 = obj1;
obj2.x = 20;
console.log(obj1.x); // 20 (changed!)
```

---

### Q3: Can you mutate a primitive value?

**Answer:** No. Primitives are immutable. Operations create new values.

```js
let str = "hello";
str.toUpperCase(); // Returns new string "HELLO"
console.log(str); // "hello" (unchanged)

// To actually change it:
str = str.toUpperCase(); // Re-assignment
```

---

## ðŸ”· 2. Type Coercion Questions

### Q4: What's the difference between `==` and `===`?

**Answer:**

- `==` (loose equality): Performs type coercion, then compares
- `===` (strict equality): No coercion, compares type and value

```js
console.log("5" == 5); // true (coercion: string â†’ number)
console.log("5" === 5); // false (different types)

console.log(null == undefined); // true (special case)
console.log(null === undefined); // false
```

---

### Q5: What will these comparisons return?

```js
console.log([] == ""); // true ([] â†’ "" â†’ "" == "")
console.log([] == 0); // true ([] â†’ "" â†’ 0 == 0)
console.log([] == false); // true ([] â†’ "" â†’ 0 == 0)
console.log([1] == 1); // true ([1] â†’ "1" â†’ 1 == 1)
console.log([1, 2] == "1,2"); // true
console.log([] === ""); // false (no coercion)
```

**Key Takeaway:** Avoid `==` in production. Use `===` for predictable behavior.

---

### Q6: What happens with the `+` operator?

**Answer:** `+` favors string concatenation. If one operand is a string, both are coerced to strings.

```js
console.log(5 + "5"); // "55" (number â†’ string)
console.log("5" + 5); // "55"
console.log(5 + 5); // 10 (both numbers)
console.log("5" - 2); // 3 (string â†’ number, subtraction)
console.log("5" * 2); // 10 (string â†’ number, multiplication)
```

---

### Q7: What are truthy and falsy values?

**Answer:**

**Falsy values (8 total):**

- `false`, `0`, `-0`, `0n` (BigInt zero), `""` (empty string), `null`, `undefined`, `NaN`

**Everything else is truthy**, including:

- `[]` (empty array), `{}` (empty object), `"0"`, `"false"`, `Infinity`

```js
if ([]) console.log("truthy"); // logs "truthy"
if ({}) console.log("truthy"); // logs "truthy"
if ("0") console.log("truthy"); // logs "truthy"
if (0) console.log("falsy"); // doesn't log
if ("") console.log("falsy"); // doesn't log
```

---

## ðŸ”· 3. Special Values Questions

### Q8: Why does `typeof null` return `"object"`?

**Answer:** This is a historical bug in JavaScript that's been preserved for backward compatibility. `null` is actually a primitive, not an object.

```js
console.log(typeof null); // "object" (bug!)
console.log(null instanceof Object); // false (correctly not an object)

// Correct way to check for null:
console.log(value === null);
```

---

### Q9: How do you check if a value is `NaN`?

**Answer:** Use `Number.isNaN()` (not `isNaN()`).

```js
console.log(NaN === NaN); // false (NaN != NaN)
console.log(isNaN(NaN)); // true
console.log(isNaN("hello")); // true (problematic!)
console.log(Number.isNaN(NaN)); // true (correct)
console.log(Number.isNaN("hello")); // false (correct)
```

**Why:** `isNaN()` coerces to number first, while `Number.isNaN()` checks if value is actually `NaN`.

---

### Q10: What's the difference between `null` and `undefined`?

**Answer:**

| Feature        | `null`                       | `undefined`                    |
| -------------- | ---------------------------- | ------------------------------ |
| **Type**       | `object` (bug)               | `undefined`                    |
| **Assignment** | Explicit                     | Automatic                      |
| **Use case**   | Intentional absence          | Uninitialized                  |
| **Equality**   | `null == undefined` â†’ `true` | `null === undefined` â†’ `false` |

```js
let a;
console.log(a); // undefined (not assigned)

let b = null;
console.log(b); // null (explicitly set)

console.log(null == undefined); // true
console.log(null === undefined); // false
```

---

## ðŸ”· 4. Copying and Mutation Questions

### Q11: What's the difference between shallow copy and deep copy?

**Answer:**

**Shallow Copy:**

- Copies top-level properties only
- Nested objects/arrays still share references

**Deep Copy:**

- Recursively copies all nested structures
- Completely independent copies

```js
// Shallow copy
let obj1 = { a: 1, b: { c: 2 } };
let obj2 = { ...obj1 }; // or Object.assign({}, obj1)
obj2.b.c = 3;
console.log(obj1.b.c); // 3 (changed! - shared reference)

// Deep copy
let obj3 = structuredClone(obj1); // or JSON.parse(JSON.stringify(obj1))
obj3.b.c = 4;
console.log(obj1.b.c); // 3 (unchanged)
```

---

### Q12: How do you prevent object mutation?

**Answer:** Use `Object.freeze()` (shallow), `Object.seal()`, or immutable libraries.

```js
let obj = { a: 1 };
Object.freeze(obj);
obj.a = 2; // Silently fails (or throws in strict mode)
console.log(obj.a); // 1

// Note: Only shallow freeze
let nested = { a: { b: 1 } };
Object.freeze(nested);
nested.a.b = 2; // Still works! (nested not frozen)
```

---

### Q13: What's the difference between mutation and re-assignment?

**Answer:**

**Mutation:** Changing the contents of an existing object/array (reference stays same)
**Re-assignment:** Changing which object/array a variable points to (new reference)

```js
// Mutation
let arr = [1, 2, 3];
arr.push(4); // Mutation: same array, different contents
console.log(arr); // [1, 2, 3, 4]

// Re-assignment
arr = [5, 6]; // Re-assignment: new array
console.log(arr); // [5, 6]

// const allows mutation but not re-assignment
const obj = { x: 1 };
obj.x = 2; // âœ… Mutation allowed
obj = { y: 1 }; // âŒ Re-assignment not allowed
```

---

## ðŸ”· 5. Type Checking Questions

### Q14: How do you check if a value is an array?

**Answer:** Use `Array.isArray()` (most reliable).

```js
let arr = [];
console.log(typeof arr); // "object" (not helpful)
console.log(arr instanceof Array); // true (works, but...)
console.log(Array.isArray(arr)); // true (best method)

// Why Array.isArray()?
// Works across different execution contexts/frames
```

---

### Q15: How do you get the actual type of a value?

**Answer:** Use `Object.prototype.toString.call()`.

```js
console.log(typeof null); // "object" (wrong!)
console.log(Object.prototype.toString.call(null)); // "[object Null]"

console.log(Object.prototype.toString.call([])); // "[object Array]"
console.log(Object.prototype.toString.call({})); // "[object Object]"
console.log(Object.prototype.toString.call(new Date())); // "[object Date]"
```

---

## ðŸ”· 6. Object-to-Primitive Conversion

### Q16: What happens when an object is used in a primitive context?

**Answer:** JavaScript calls `valueOf()` or `toString()` (or `Symbol.toPrimitive` if present).

```js
let obj = {
  valueOf() {
    return 10;
  },
  toString() {
    return "hello";
  },
};

console.log(obj + 5); // 15 (valueOf used for +)
console.log(String(obj)); // "hello" (toString used)
```

**Conversion order:**

1. `Symbol.toPrimitive` (if exists)
2. `valueOf()` (for number context)
3. `toString()` (for string context)

---

## ðŸ”· 7. Array Questions

### Q17: Which array methods mutate the original array?

**Answer:** Mutating methods: `push()`, `pop()`, `shift()`, `unshift()`, `splice()`, `sort()`, `reverse()`, `fill()`, `copyWithin()`

```js
let arr = [3, 1, 2];
arr.sort(); // Mutates original
console.log(arr); // [1, 2, 3]

// Non-mutating alternative:
let sorted = [...arr].sort(); // Create copy first
```

---

### Q18: How do you remove duplicates from an array?

**Answer:** Multiple approaches:

```js
// Method 1: Set (simplest)
let arr = [1, 2, 2, 3, 3, 3];
let unique = [...new Set(arr)]; // [1, 2, 3]

// Method 2: filter + indexOf
let unique2 = arr.filter((val, idx) => arr.indexOf(val) === idx);

// Method 3: reduce
let unique3 = arr.reduce((acc, val) => {
  if (!acc.includes(val)) acc.push(val);
  return acc;
}, []);
```

---

## ðŸ”· 8. Map vs Object Questions

### Q19: When should you use `Map` instead of `Object`?

**Answer:** Use `Map` when:

- Keys can be any type (not just strings/symbols)
- You need to maintain insertion order
- You frequently add/remove keys
- You need size property
- Keys might conflict with prototype properties

```js
// Object: keys must be strings/symbols
let obj = {};
obj[1] = "one"; // key becomes "1" (string)

// Map: keys can be any type
let map = new Map();
map.set(1, "one"); // number key
map.set({}, "object key"); // object key
map.set(true, "bool key"); // boolean key
```

---

## ðŸ”· 9. Set vs Array Questions

### Q20: When should you use `Set` instead of `Array`?

**Answer:** Use `Set` when:

- You need unique values only
- You frequently check membership (`has()` is O(1) vs `includes()` O(n))
- You don't need indexed access

```js
// Array: duplicates allowed, slower lookup
let arr = [1, 2, 2, 3];
console.log(arr.includes(2)); // true (but O(n) search)

// Set: unique values, fast lookup
let set = new Set([1, 2, 2, 3]); // [1, 2, 3]
console.log(set.has(2)); // true (O(1) lookup)
```

---

## ðŸ”· 10. Tricky Scenarios

### Q21: What will this code output?

```js
console.log([] + []); // "" (empty string)
console.log([] + {}); // "[object Object]"
console.log({} + []); // "[object Object]"
console.log({} + {}); // "[object Object][object Object]"
console.log(true + true); // 2 (boolean â†’ number)
console.log(true + false); // 1
```

**Explanation:** Objects are converted to primitives via `toString()`, then concatenated or added.

---

### Q22: What's the output?

```js
let a = [1, 2, 3];
let b = a;
b.push(4);
console.log(a); // [1, 2, 3, 4] (same reference)

let c = [...a]; // Shallow copy
c.push(5);
console.log(a); // [1, 2, 3, 4] (unchanged)
```

---

### Q23: What happens here?

```js
let obj = {
  a: 1,
  b: function () {
    return this.a;
  },
};

let fn = obj.b;
console.log(fn()); // undefined (lost context)
console.log(obj.b()); // 1 (correct context)

// Fix:
let boundFn = obj.b.bind(obj);
console.log(boundFn()); // 1
```

---

## ðŸ”· 11. BigInt Questions

### Q24: How do you work with BigInt?

**Answer:** Use `n` suffix or `BigInt()` constructor. Can't mix with regular numbers.

```js
let big = 1234567890123456789012345678901234567890n;
let big2 = BigInt("12345678901234567890");

console.log(big + big2); // Works
console.log(big + 5); // TypeError (can't mix)
console.log(big + 5n); // Works

// Convert back:
console.log(Number(big)); // May lose precision
```

---

## ðŸ”· 12. Symbol Questions

### Q25: What are Symbols used for?

**Answer:** Unique identifiers, private properties, avoiding name collisions.

```js
let sym1 = Symbol("id");
let sym2 = Symbol("id");
console.log(sym1 === sym2); // false (always unique)

// Private property pattern:
let _private = Symbol("private");
class MyClass {
  constructor() {
    this[_private] = "secret";
  }
}
```

---

## âœ… Interview Tips

1. **Always use `===`** unless you have a specific reason for `==`
2. **Know the 8 falsy values** by heart
3. **Understand reference vs value** - critical for arrays/objects
4. **Prefer immutability** - use non-mutating methods when possible
5. **Know when to use Map/Set** vs Object/Array
6. **Practice type checking** - `typeof`, `instanceof`, `Array.isArray()`, etc.
7. **Understand coercion rules** - especially with `+`, `==`, and logical operators

---

ðŸ’¡ **Pro Tip:** In interviews, explain your reasoning. Show you understand _why_ something behaves a certain way, not just _what_ it does.
