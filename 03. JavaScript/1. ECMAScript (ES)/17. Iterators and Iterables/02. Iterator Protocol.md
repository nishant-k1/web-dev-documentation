# Iterator Protocol

The **Iterator Protocol** defines how to create an iterator object. An iterator is an object that implements a `next()` method.

---

## Iterator Requirements

An iterator must have a `next()` method that returns an object with:

- **`value`**: The current value (can be any type, or `undefined` if `done` is `true`)
- **`done`**: A boolean indicating if iteration is complete

---

## Basic Iterator

```javascript
const iterator = {
  data: [1, 2, 3],
  index: 0,

  next() {
    if (this.index < this.data.length) {
      return {
        value: this.data[this.index++],
        done: false,
      };
    }
    return { done: true };
  },
};

console.log(iterator.next()); // { value: 1, done: false }
console.log(iterator.next()); // { value: 2, done: false }
console.log(iterator.next()); // { value: 3, done: false }
console.log(iterator.next()); // { done: true }
```

---

## Iterator Return Value

When `done` is `true`, the `value` property is typically omitted (or can be `undefined`):

```javascript
// Both are valid:
{ done: true }
{ value: undefined, done: true }
```

---

## Optional Methods

Iterators can optionally implement:

- **`return(value)`**: Called when iteration is stopped early
- **`throw(error)`**: Called when an error is thrown into the iterator

---

## Using Iterators

### Manual Iteration

```javascript
const iterator = createIterator();
let result = iterator.next();

while (!result.done) {
  console.log(result.value);
  result = iterator.next();
}
```

### With `for...of`

```javascript
// for...of automatically uses iterator
for (const value of iterable) {
  console.log(value);
}
```

---

## Related Topics

- [03. Iterable Protocol.md](./03.%20Iterable%20Protocol.md) - Making objects iterable
- [05. Custom Iterators.md](./05.%20Custom%20Iterators.md) - Creating custom iterators
- [06. Generators as Iterators.md](./06.%20Generators%20as%20Iterators.md) - Using generators
