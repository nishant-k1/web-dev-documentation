# this Binding Precedence

When multiple binding rules could apply to determine `this`, JavaScript follows a specific **precedence order**. Understanding this precedence is crucial for predicting `this` behavior.

---

## Precedence Order (Highest to Lowest)

1. **`new` Binding** (highest priority)
2. **Explicit Binding** (call, apply, bind)
3. **Implicit Binding** (method invocation)
4. **Default Binding** (lowest priority)

**Special Case:** **Arrow Functions** ignore all precedence rules and use lexical binding.

---

## 1. new Binding (Highest Priority)

When a function is called with `new`, `new` binding takes precedence over everything else.

```javascript
function Person(name) {
  this.name = name;
}

const obj = { name: "Object" };

// new binding wins
const person = new Person("John");
console.log(person.name); // "John" (new instance, not obj)
```

### new vs Explicit

```javascript
function Test() {
  console.log(this);
}

const obj = { name: "Object" };

// new takes precedence
new Test.call(obj); // Syntax error - can't combine
// But if we could, new would win

const bound = Test.bind(obj);
new bound(); // {} (new instance, bind is ignored)
```

---

## 2. Explicit Binding (Second Priority)

Explicit binding (using `call()`, `apply()`, or `bind()`) takes precedence over implicit and default binding.

```javascript
function greet() {
  console.log(this.name);
}

const obj1 = { name: "Object 1" };
const obj2 = { name: "Object 2" };

// Explicit binding overrides implicit
obj1.greet = greet;
obj1.greet.call(obj2); // "Object 2" (explicit wins)
```

### Explicit vs Implicit

```javascript
const obj1 = {
  name: "Object 1",
  method: function () {
    return this.name;
  },
};

const obj2 = {
  name: "Object 2",
};

// Implicit binding
obj1.method(); // "Object 1"

// Explicit binding overrides
obj1.method.call(obj2); // "Object 2" (explicit wins)
```

### Explicit vs Default

```javascript
function test() {
  console.log(this);
}

// Default binding
test(); // window/undefined

// Explicit binding overrides
test.call({ name: "Object" }); // { name: "Object" }
```

---

## 3. Implicit Binding (Third Priority)

Implicit binding (method invocation) takes precedence over default binding.

```javascript
const obj = {
  name: "Object",
  method: function () {
    console.log(this.name);
  },
};

// Implicit binding
obj.method(); // "Object"

// Default binding (when detached)
const method = obj.method;
method(); // undefined (default binding)
```

### Implicit vs Default

```javascript
const obj = {
  name: "Object",
  method: function () {
    return this.name;
  },
};

// Implicit binding wins
obj.method(); // "Object"

// When detached, default binding applies
const fn = obj.method;
fn(); // undefined (default binding)
```

---

## 4. Default Binding (Lowest Priority)

Default binding is the fallback when no other rule applies.

```javascript
function test() {
  console.log(this);
}

// No other binding applies, so default
test(); // window/global (non-strict) or undefined (strict)
```

---

## Precedence Examples

### Example 1: new > Explicit

```javascript
function Person(name) {
  this.name = name;
}

const obj = { name: "Object" };
const BoundPerson = Person.bind(obj);

// new takes precedence over bind
const person = new BoundPerson("John");
console.log(person.name); // "John" (new instance)
console.log(person instanceof Person); // true
console.log(obj.name); // "Object" (unchanged)
```

### Example 2: Explicit > Implicit

```javascript
const obj1 = {
  name: "Object 1",
  method: function () {
    return this.name;
  },
};

const obj2 = {
  name: "Object 2",
};

// Explicit overrides implicit
obj1.method.call(obj2); // "Object 2"
```

### Example 3: Implicit > Default

```javascript
const obj = {
  name: "Object",
  method: function () {
    return this.name;
  },
};

// Implicit wins
obj.method(); // "Object"

// Default when detached
const method = obj.method;
method(); // undefined
```

---

## Edge Cases

### Case 1: new with call/apply

You **cannot** use `new` with `call()` or `apply()` directly:

```javascript
function Person(name) {
  this.name = name;
}

const obj = {};

// âŒ Syntax error
// new Person.call(obj, "John");

// âœ… Workaround: bind then new
const BoundPerson = Person.bind(obj);
new BoundPerson("John"); // new takes precedence
```

### Case 2: bind with new

When you use `bind()` and then call with `new`, `new` takes precedence:

```javascript
function Test() {
  console.log(this);
}

const obj = { name: "Object" };
const BoundTest = Test.bind(obj);

// new overrides bind
new BoundTest(); // {} (new instance, not obj)
```

### Case 3: Multiple bind Calls

```javascript
function test() {
  console.log(this.name);
}

const obj1 = { name: "Object 1" };
const obj2 = { name: "Object 2" };

const bound1 = test.bind(obj1);
const bound2 = bound1.bind(obj2);

bound2(); // "Object 1" (first bind wins, can't rebind)
```

**Note:** Once a function is bound, it cannot be rebound. The first `bind()` is permanent.

---

## Arrow Functions: No Precedence

Arrow functions **ignore all precedence rules** because they use lexical binding:

```javascript
const obj = {
  name: "Object",
  method: function () {
    const arrow = () => {
      console.log(this.name);
    };

    // Arrow function ignores how it's called
    arrow(); // "Object" (lexical)
    arrow.call({ name: "Other" }); // "Object" (still lexical, call ignored)
    new arrow(); // Error: arrow is not a constructor
  },
};

obj.method();
```

---

## Determining `this` - Decision Tree

To determine `this` in any context, follow this decision tree:

```
1. Is it an arrow function?
   â†’ YES: this = from outer (lexical) scope
   â†’ NO: Continue...

2. Was function called with new?
   â†’ YES: this = new instance
   â†’ NO: Continue...

3. Was function called with call/apply/bind?
   â†’ YES: this = first argument (or bound value)
   â†’ NO: Continue...

4. Was function called as method (obj.method())?
   â†’ YES: this = object before dot
   â†’ NO: Continue...

5. Default: this = window/global (non-strict) or undefined (strict)
```

---

## Practical Examples

### Example 1: Complex Scenario

```javascript
function Test() {
  console.log(this.name);
}

const obj1 = { name: "Object 1" };
const obj2 = { name: "Object 2" };

// Explicit binding
Test.call(obj1); // "Object 1"

// new binding (overrides)
const BoundTest = Test.bind(obj1);
new BoundTest(); // undefined (new instance has no name)

// Implicit binding
obj2.method = Test;
obj2.method(); // "Object 2"

// Explicit overrides implicit
obj2.method.call(obj1); // "Object 1"
```

### Example 2: Method Chaining

```javascript
const obj = {
  name: "Object",
  method1: function () {
    console.log("method1:", this.name);
    return this;
  },
  method2: function () {
    console.log("method2:", this.name);
    return this;
  },
};

// Implicit binding maintained through chain
obj.method1().method2();
// "method1: Object"
// "method2: Object"
```

### Example 3: Nested Invocations

```javascript
const obj = {
  name: "Object",
  outer: function () {
    function inner() {
      console.log(this.name); // undefined (default binding)
    }
    inner();

    const arrowInner = () => {
      console.log(this.name); // "Object" (lexical from outer)
    };
    arrowInner();
  },
};

obj.outer();
```

---

## Summary

### Precedence Rules

1. **`new` Binding** - Highest priority
2. **Explicit Binding** - Second priority
3. **Implicit Binding** - Third priority
4. **Default Binding** - Lowest priority
5. **Arrow Functions** - Ignore all rules (lexical)

### Key Takeaways

- **Higher precedence** always wins
- **`new`** cannot be overridden
- **Explicit binding** can override implicit
- **Implicit binding** can override default
- **Arrow functions** are special (lexical only)
- **Once bound** with `bind()`, cannot be rebound

### Decision Process

1. Check if arrow function â†’ lexical `this`
2. Check if called with `new` â†’ new instance
3. Check if called with `call`/`apply`/`bind` â†’ explicit `this`
4. Check if method call â†’ object before dot
5. Otherwise â†’ default (window/undefined)

---

> ðŸ“– **Related Topics:**
>
> - [2. Understanding this Binding.md](./2.%20Understanding%20this%20Binding.md) - Overview
> - [6. new Binding.md](./6.%20new%20Binding.md) - Highest precedence
> - [5. Explicit Binding (call, apply, bind).md](<./5.%20Explicit%20Binding%20(call,%20apply,%20bind).md>) - Second precedence
> - [4. Implicit Binding.md](./4.%20Implicit%20Binding.md) - Third precedence
> - [3. Default Binding.md](./3.%20Default%20Binding.md) - Lowest precedence
> - [7. Arrow Functions and this.md](./7.%20Arrow%20Functions%20and%20this.md) - Lexical binding
