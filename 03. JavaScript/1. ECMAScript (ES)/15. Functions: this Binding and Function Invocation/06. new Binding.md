# new Binding

The `new` binding occurs when a function is called with the `new` keyword as a **constructor**. When `new` is used, `this` is bound to the newly created instance.

---

## What is new Binding?

When you call a function with the `new` keyword, JavaScript:

1. Creates a new empty object
2. Binds `this` to that new object
3. Executes the function body
4. Returns the new object (unless the function returns something else)

---

## Basic Example

```javascript
function Person(name, age) {
  this.name = name;
  this.age = age;
}

const person = new Person("John", 30);
console.log(person.name); // "John"
console.log(person.age); // 30
```

In this example:

- `new Person()` creates a new object
- `this` inside the constructor refers to that new object
- Properties are assigned to the new object via `this`

---

## What Happens with new

### Step-by-Step Process

```javascript
function Car(brand) {
  // Step 1: New object created and bound to this
  // Step 2: Function body executes
  this.brand = brand;
  // Step 3: New object is returned (unless function returns something else)
}

const myCar = new Car("Toyota");
```

**Internally, JavaScript does something like:**

```javascript
function Car(brand) {
  // const this = {}; // (implicit)
  this.brand = brand;
  // return this; // (implicit, unless you return something else)
}
```

---

## Constructor Functions

Functions intended to be used with `new` are called **constructor functions**. By convention, they start with a capital letter.

### Good Practice

```javascript
function Person(name) {
  this.name = name;
}

const person = new Person("John");
```

### Bad Practice (but works)

```javascript
function person(name) {
  this.name = name;
}

const p = new person("John"); // Works, but violates convention
```

---

## Return Values

### Default Behavior (No Return)

```javascript
function Person(name) {
  this.name = name;
  // No return statement
}

const person = new Person("John");
console.log(person); // Person { name: "John" }
```

### Returning an Object

If you return an **object**, that object replaces the default return:

```javascript
function Person(name) {
  this.name = name;
  return { custom: "object" }; // Object return overrides
}

const person = new Person("John");
console.log(person); // { custom: "object" } (not Person instance)
```

### Returning a Primitive

If you return a **primitive** (string, number, boolean, etc.), it's **ignored**:

```javascript
function Person(name) {
  this.name = name;
  return 42; // Primitive return is ignored
}

const person = new Person("John");
console.log(person); // Person { name: "John" } (primitive ignored)
```

### Examples

```javascript
// Returns object - overrides
function Test1() {
  this.value = 1;
  return { value: 2 };
}
console.log(new Test1()); // { value: 2 }

// Returns primitive - ignored
function Test2() {
  this.value = 1;
  return 100;
}
console.log(new Test2()); // Test2 { value: 1 }

// No return - default
function Test3() {
  this.value = 1;
}
console.log(new Test3()); // Test3 { value: 1 }
```

---

## new Binding vs Other Bindings

### new vs Default

```javascript
function Person(name) {
  this.name = name;
}

// Default binding - this = window/global
Person("John");
console.log(window.name); // "John" (non-strict, pollutes global)

// new binding - this = new instance
const person = new Person("John");
console.log(person.name); // "John"
```

### new vs Explicit

```javascript
function Person(name) {
  this.name = name;
}

const obj = {};

// Explicit binding - this = obj
Person.call(obj, "John");
console.log(obj.name); // "John"

// new binding - this = new instance (overrides explicit)
const person = new Person("John");
console.log(person.name); // "John"
```

**Note:** `new` binding has **higher precedence** than explicit binding when used together (though you typically don't use them together).

### new vs Implicit

```javascript
const obj = {
  createPerson: function (name) {
    this.name = name;
  },
};

// Implicit binding - this = obj
obj.createPerson("Object");
console.log(obj.name); // "Object"

// new binding - this = new instance (overrides implicit)
const person = new obj.createPerson("John");
console.log(person.name); // "John"
console.log(obj.name); // Still "Object"
```

---

## Checking if Function Called with new

### Using instanceof

```javascript
function Person(name) {
  if (this instanceof Person) {
    this.name = name;
  } else {
    throw new Error("Person must be called with new");
  }
}

new Person("John"); // OK
Person("John"); // Error
```

### Using new.target (ES6)

```javascript
function Person(name) {
  if (new.target) {
    this.name = name;
  } else {
    throw new Error("Person must be called with new");
  }
}

new Person("John"); // OK
Person("John"); // Error
```

**Better approach:**

```javascript
function Person(name) {
  if (!new.target) {
    return new Person(name); // Auto-correct
  }
  this.name = name;
}

Person("John"); // Works - automatically uses new
new Person("John"); // Also works
```

---

## Prototype and new

When a function is called with `new`, the new object's prototype is set to the function's `prototype` property.

```javascript
function Person(name) {
  this.name = name;
}

Person.prototype.greet = function () {
  return `Hello, I'm ${this.name}`;
};

const person = new Person("John");
console.log(person.greet()); // "Hello, I'm John"
console.log(person instanceof Person); // true
```

---

## ES6 Classes and new

ES6 classes work the same way with `new`:

```javascript
class Person {
  constructor(name) {
    this.name = name; // this = new instance
  }

  greet() {
    return `Hello, I'm ${this.name}`;
  }
}

const person = new Person("John");
console.log(person.greet()); // "Hello, I'm John"
```

**Note:** Classes **must** be called with `new`:

```javascript
class Person {
  constructor(name) {
    this.name = name;
  }
}

Person("John"); // TypeError: Class constructor Person cannot be invoked without 'new'
```

---

## Common Patterns

### Pattern 1: Factory Function Alternative

```javascript
// Constructor pattern
function Person(name) {
  this.name = name;
}
const person1 = new Person("John");

// Factory pattern (alternative)
function createPerson(name) {
  return { name: name };
}
const person2 = createPerson("John");
```

### Pattern 2: Constructor with Methods

```javascript
function Calculator() {
  this.value = 0;

  this.add = function (num) {
    this.value += num;
    return this;
  };

  this.multiply = function (num) {
    this.value *= num;
    return this;
  };
}

const calc = new Calculator();
calc.add(5).multiply(2);
console.log(calc.value); // 10
```

### Pattern 3: Constructor with Prototype Methods

```javascript
function Person(name) {
  this.name = name;
}

// Methods on prototype (shared across instances)
Person.prototype.greet = function () {
  return `Hello, I'm ${this.name}`;
};

const person1 = new Person("John");
const person2 = new Person("Jane");

console.log(person1.greet()); // "Hello, I'm John"
console.log(person2.greet()); // "Hello, I'm Jane"
console.log(person1.greet === person2.greet); // true (same function)
```

---

## Edge Cases

### Case 1: Constructor Returns Object

```javascript
function Test() {
  this.value = 1;
  return { value: 2 }; // Overrides
}

const test = new Test();
console.log(test.value); // 2 (not 1)
console.log(test instanceof Test); // false
```

### Case 2: Constructor Returns Primitive

```javascript
function Test() {
  this.value = 1;
  return "primitive"; // Ignored
}

const test = new Test();
console.log(test.value); // 1
console.log(test instanceof Test); // true
```

### Case 3: Constructor with Arrow Function

```javascript
const Person = (name) => {
  this.name = name; // Error - arrow functions can't be constructors
};

// new Person("John"); // TypeError: Person is not a constructor
```

### Case 4: Built-in Constructors

```javascript
// Built-in constructors also use new binding
const arr = new Array(1, 2, 3);
const obj = new Object({ key: "value" });
const date = new Date();
```

---

## Summary

### Key Points

1. **`new` binding** occurs when function is called with `new`
2. **`this`** refers to the newly created instance
3. **New object** is created and returned (unless function returns object)
4. **Prototype** is set to function's `prototype` property
5. **Highest precedence** among binding rules

### What Happens

1. New empty object created
2. `this` bound to new object
3. Function body executes
4. New object returned (unless object is returned)

### When to Use

- Creating multiple similar objects
- Object-oriented patterns
- When you need prototype inheritance
- When you need `instanceof` to work

### Common Mistakes

- Forgetting `new` (pollutes global scope)
- Returning primitives (ignored, but confusing)
- Using arrow functions as constructors (not allowed)

---

> ðŸ“– **Related Topics:**
>
> - [2. Understanding this Binding.md](./2.%20Understanding%20this%20Binding.md) - Overview
> - [8. this Binding Precedence.md](./8.%20this%20Binding%20Precedence.md) - new has highest precedence
> - [10. this in Classes.md](./10.%20this%20in%20Classes.md) - new binding in classes
> - [1. Function Invocation.md](./1.%20Function%20Invocation.md) - Constructor invocation
