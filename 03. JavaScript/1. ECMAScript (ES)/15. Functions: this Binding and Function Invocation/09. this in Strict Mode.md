# this in Strict Mode

Strict mode changes how `this` behaves, particularly for **default binding**. Understanding these differences is crucial for avoiding bugs and writing robust code.

---

## Key Difference

### Non-Strict Mode

In non-strict mode, when default binding applies, `this` refers to the **global object**:

- Browser: `this` = `window`
- Node.js: `this` = `global`

### Strict Mode

In strict mode, when default binding applies, `this` is `undefined`:

- Browser: `this` = `undefined`
- Node.js: `this` = `undefined`

---

## Basic Example

### Non-Strict Mode

```javascript
function showThis() {
  console.log(this);
}

showThis(); // window (browser) or global (Node.js)
```

### Strict Mode

```javascript
"use strict";

function showThis() {
  console.log(this);
}

showThis(); // undefined
```

---

## Enabling Strict Mode

### Global Strict Mode

```javascript
"use strict";

function test() {
  console.log(this); // undefined
}

test();
```

### Function-Level Strict Mode

```javascript
function strictFunction() {
  "use strict";
  console.log(this); // undefined
}

function normalFunction() {
  console.log(this); // window/global (non-strict)
}

strictFunction(); // undefined
normalFunction(); // window/global
```

### Module-Level Strict Mode

ES6 modules are **automatically in strict mode**:

```javascript
// module.js
function test() {
  console.log(this); // undefined (strict by default)
}

test();
```

---

## Impact on Different Binding Types

### 1. Default Binding

**Non-Strict:**

```javascript
function test() {
  console.log(this);
}

test(); // window/global
```

**Strict:**

```javascript
"use strict";

function test() {
  console.log(this);
}

test(); // undefined
```

### 2. Implicit Binding (Unaffected)

Strict mode **does not affect** implicit binding:

```javascript
"use strict";

const obj = {
  name: "Object",
  method: function () {
    console.log(this.name); // "Object" (still works)
  },
};

obj.method(); // "Object"
```

### 3. Explicit Binding (Mostly Unaffected)

Strict mode **mostly doesn't affect** explicit binding, except when `null`/`undefined` is passed:

**Non-Strict:**

```javascript
function test() {
  console.log(this);
}

test.call(null); // window/global
test.call(undefined); // window/global
```

**Strict:**

```javascript
"use strict";

function test() {
  console.log(this);
}

test.call(null); // null
test.call(undefined); // undefined
```

### 4. new Binding (Unaffected)

Strict mode **does not affect** `new` binding:

```javascript
"use strict";

function Person(name) {
  this.name = name;
}

const person = new Person("John");
console.log(person.name); // "John" (still works)
```

### 5. Arrow Functions (Unaffected)

Strict mode **does not affect** arrow functions (they use lexical binding):

```javascript
"use strict";

const obj = {
  name: "Object",
  method: function () {
    const arrow = () => {
      console.log(this.name); // "Object" (lexical, not affected)
    };
    arrow();
  },
};

obj.method(); // "Object"
```

---

## Common Scenarios

### Scenario 1: Accidental Global Binding

**Non-Strict (Problematic):**

```javascript
function Person(name) {
  this.name = name; // Accidentally creates global variable
}

Person("John"); // Forgot 'new'
console.log(window.name); // "John" (pollutes global)
```

**Strict (Prevents Bug):**

```javascript
"use strict";

function Person(name) {
  this.name = name; // Error: Cannot set property 'name' of undefined
}

Person("John"); // TypeError (catches the bug)
```

### Scenario 2: Detached Methods

**Non-Strict:**

```javascript
const obj = {
  name: "Object",
  method: function () {
    console.log(this.name);
  },
};

const method = obj.method;
method(); // undefined (but no error, just undefined)
```

**Strict:**

```javascript
"use strict";

const obj = {
  name: "Object",
  method: function () {
    console.log(this.name); // Error: Cannot read property 'name' of undefined
  },
};

const method = obj.method;
method(); // TypeError (fails fast, easier to debug)
```

### Scenario 3: Callbacks

**Non-Strict:**

```javascript
const obj = {
  name: "Object",
  process: function () {
    [1, 2, 3].forEach(function (item) {
      console.log(this.name); // undefined (but no error)
    });
  },
};

obj.process();
```

**Strict:**

```javascript
"use strict";

const obj = {
  name: "Object",
  process: function () {
    [1, 2, 3].forEach(function (item) {
      console.log(this.name); // TypeError: Cannot read property 'name' of undefined
    });
  },
};

obj.process(); // Fails fast, easier to catch bug
```

---

## Benefits of Strict Mode for `this`

### 1. Prevents Accidental Global Pollution

```javascript
"use strict";

function Test() {
  this.value = 42; // Error if called without 'new'
}

Test(); // TypeError (prevents creating window.value)
```

### 2. Fails Fast

```javascript
"use strict";

const obj = {
  method: function () {
    return this.name.toUpperCase(); // Error immediately if this is undefined
  },
};

const method = obj.method;
method(); // TypeError (clear error message)
```

### 3. Makes Bugs Obvious

```javascript
"use strict";

function processData() {
  // If this is undefined, errors are immediate and clear
  this.data.forEach((item) => {
    // TypeError if this.data is undefined
  });
}
```

---

## Mixed Strict and Non-Strict

### Calling Non-Strict from Strict

```javascript
"use strict";

function strictFn() {
  console.log(this); // undefined
}

function nonStrictFn() {
  console.log(this); // window/global
}

strictFn(); // undefined
nonStrictFn(); // window/global (non-strict function)
```

### Calling Strict from Non-Strict

```javascript
function outer() {
  function inner() {
    "use strict";
    console.log(this); // undefined (strict applies to inner)
  }
  inner();
}

outer(); // undefined
```

---

## Real-World Examples

### Example 1: Constructor Without new

**Non-Strict (Silent Bug):**

```javascript
function User(name) {
  this.name = name;
}

User("John"); // Creates window.name = "John" (bug!)
console.log(window.name); // "John"
```

**Strict (Catches Bug):**

```javascript
"use strict";

function User(name) {
  this.name = name; // Error: Cannot set property 'name' of undefined
}

User("John"); // TypeError (bug caught!)
```

### Example 2: Method Detachment

**Non-Strict:**

```javascript
const calculator = {
  value: 0,
  add: function (num) {
    this.value += num; // this = window, creates window.value
    return this.value;
  },
};

const add = calculator.add;
add(5); // 5 (but pollutes global)
console.log(window.value); // 5
```

**Strict:**

```javascript
"use strict";

const calculator = {
  value: 0,
  add: function (num) {
    this.value += num; // Error: Cannot set property 'value' of undefined
    return this.value;
  },
};

const add = calculator.add;
add(5); // TypeError (bug caught!)
```

---

## ES6 Modules and Strict Mode

ES6 modules are **automatically in strict mode**:

```javascript
// module.js (automatically strict)
function test() {
  console.log(this); // undefined
}

test();

export function exported() {
  console.log(this); // undefined
}
```

**No need to write `"use strict"` in modules** - it's automatic.

---

## Best Practices

### 1. Use Strict Mode

```javascript
"use strict";

// All code in this file is strict
```

### 2. Use ES6 Modules

```javascript
// Automatically strict, no need for "use strict"
export function myFunction() {
  console.log(this); // undefined (if default binding)
}
```

### 3. Be Explicit About `this`

```javascript
"use strict";

const obj = {
  name: "Object",
  method: function () {
    // Explicitly check or use arrow functions
    if (this === undefined) {
      throw new Error("Method must be called on object");
    }
    return this.name;
  },
};
```

### 4. Use Arrow Functions for Callbacks

```javascript
"use strict";

const obj = {
  name: "Object",
  process: function () {
    // Arrow function preserves this
    [1, 2, 3].forEach((item) => {
      console.log(this.name); // "Object" (works in strict mode)
    });
  },
};
```

---

## Summary

### Key Points

1. **Strict mode** changes default binding: `this` = `undefined` instead of `window`/`global`
2. **Other bindings** (implicit, explicit, new) are mostly unaffected
3. **Arrow functions** are unaffected (lexical binding)
4. **ES6 modules** are automatically strict
5. **Strict mode** helps catch bugs early

### Differences

| Binding Type             | Non-Strict        | Strict          |
| ------------------------ | ----------------- | --------------- |
| **Default**              | `window`/`global` | `undefined`     |
| **Implicit**             | Object            | Object (same)   |
| **Explicit (null)**      | `window`/`global` | `null`          |
| **Explicit (undefined)** | `window`/`global` | `undefined`     |
| **new**                  | Instance          | Instance (same) |
| **Arrow**                | Lexical           | Lexical (same)  |

### Benefits

- âœ… Prevents global pollution
- âœ… Fails fast (easier debugging)
- âœ… Makes bugs obvious
- âœ… Better error messages
- âœ… ES6 modules are strict by default

---

> ðŸ“– **Related Topics:**
>
> - [3. Default Binding.md](./3.%20Default%20Binding.md) - How strict mode affects default binding
> - [2. Understanding this Binding.md](./2.%20Understanding%20this%20Binding.md) - Overview
> - [9. Strict Mode](../9.%20Strict%20Mode/) - Complete strict mode guide
