# Types of Execution Contexts

## 1. Global Execution Context (GEC)

- The global execution context refers to the environment where the JavaScript code starts executing when the program begins.
- This is the first context created when a JavaScript program runs.
- It is pushed onto the call stack when execution begins (Javascript engine runs).
- It's not a "function" in itself, but rather the environment where all top-level code (outside of functions) is executed.
- It includes `global variables`, `function definitions`, `this`, in the global scope.
- Global context is stored in memory, but when the JavaScript engine runs the code, the global execution context is pushed onto the call stack.
- Once the code finishes executing, the global execution context is popped off the stack.

- It gets Created when the JavaScript engine starts executing code.
- Created when the JavaScript engine starts executing a script.
- It creates a global scope, attaches the global object (like window in browsers or global in Node.js), and initializes variables declared outside any function.
- `this` in GEC:

  - In browsers, `this` refers to the `window` object.
  - In nodejs `this` refers to the `global` object.
  - In `strict mode` ('use strict'),`this` is `undefined`.

- Phases of Global Execution Context
  - **Creation Phase**:
    - The global object is created (`window` or `global`).
    - `this` is assigned to the global object.
    - Global variables and functions are stored in memory.
  - **Execution Phase**:
    - Code is executed line by line.
    - Variables are assigned their values, and functions are invoked.

**Global Variables**

1. A global variable is one that is declared in the GEC and accessible everywhere.
   Both var, let, and const behave this way.

2. The difference lies in how the variable interacts with the global object:
   var attaches itself to the global object.

3. let and const do not attach themselves to the global object, making them safer and avoiding potential naming conflicts.

   Eg: When we declare a variable using var keyword in the `GEC` then the variable becomes property of the `window` object in BRE and `global` object in NRE

## 2. Module Execution Context

Introduced with ES Modules (ES6 and later).

- Created when a module (e.g., a file with import/export) is evaluated, typically when itâ€™s first imported.
- Each module gets its own execution context, which handles the moduleâ€™s top-level declarations and exports.
- Unlike the GEC, a module execution context is specific to the module and doesnâ€™t pollute the global scope.
- A module is evaluated once per program, and its exports are cached for subsequent imports.
- Example: In utils.js with export { A }, a module execution context is created when utils.js is imported.

## 3. Function Execution Context (FEC)

- Each time a function is called, a new FEC is created. The FEC includes the functionâ€™s local variables, parameters, and where the function was called from (the call site)
- When a function is invoked, a new execution context is created for that function. This includes the function's arguments, local variables, and the function's scope chain.
- However, the function definition itself is not stored in the FEC. Instead, the FEC contains the execution details for the function's invocation (local variables, scope, etc.).
- The function definition (the code block) is still stored in memory in the scope where the function was defined, which could be:

  1. Global scope if defined globally
  2. Enclosing function scope if defined inside another function.

- If you have multiple nested functions (for example, a function defined inside another function), the function definitions are still stored in the outer (enclosing) scope (the FEC of outer).

- In this case:

  ```JavaScript
  function outer() {
    function inner() {
      console.log("Inside inner function");
    }
    inner();  // Call to inner function
  }

  outer();  // Call to outer function

  ```

  - The inner function definition is stored in the memory of the outer function's scope (the FEC of outer).

  - When outer is called, its FEC is pushed to the call stack, and when inner is called inside outer, the FEC of inner is created and pushed to the call stack.

  - However, the function definition of inner (i.e., function inner() { console.log("Inside inner function"); }) still resides in the scope of the outer function, not in the FEC of inner.

- Created whenever a function is invoked (including arrow functions).

**Note on Arrow Functions:** Arrow functions DO create their own execution context. What they don't create is their own:

- `this` binding (inherited from enclosing lexical scope)
- `arguments` object
- `super` binding
- `new.target`
- Each function call has its own execution context.
- FEC Consists of:

  - A local scope for variables defined within the function.
  - The arguments object for accessing passed arguments.
  - The this keyword (depends on how the function is invoked).
  - Phases of Function Execution Context
    - **Creation Phase**:
      - The function's arguments are stored.
      - Local variables are initialized (they are stored in memory but not yet assigned).
      - The `scope chain` and `this` keyword are set.
    - **Execution Phase**:
      - The function's code is executed.
      - Variables are assigned their values, and the function's logic is executed.

  **arguments keyword**

  - When a global execution context is created we get "this" keyword but unlike the global execution context that gave us a global object that equals to this instead, with a function invocation, we get something called arguments, and that's another keyword.

  - arguments is only available to us when we create a new execution context.

### ðŸ”¥ Critical Concept: Each Function CALL Creates an INDEPENDENT Execution Context (Even for the same function definition/declaration)

### Same function definition â‰  Same execution context

Every time you CALL a function (even the same function), JavaScript creates:

- A **new** execution context
- A **new** variable environment
- **New** local variables (completely isolated from other calls)

```javascript
function createCounter() {
  let count = 0; // â† This variable is created FRESH on every call
  return {
    increment: () => count++,
    getCount: () => count,
  };
}

const counter1 = createCounter(); // Call 1: New EC, new 'count' (count = 0)
const counter2 = createCounter(); // Call 2: New EC, new 'count' (count = 0)

counter1.increment(); // counter1's count: 0 â†’ 1
counter1.increment(); // counter1's count: 1 â†’ 2
counter2.increment(); // counter2's count: 0 â†’ 1

console.log(counter1.getCount() + counter2.getCount()); // 2 + 1 = 3
```

**Visual Representation:**

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  createCounter() - Call 1       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚ count = 0 â†’ 1 â†’ 2   â”‚ â† EC1  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚         â†‘                       â”‚
â”‚    counter1 methods             â”‚
â”‚    reference this count         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  createCounter() - Call 2       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚ count = 0 â†’ 1       â”‚ â† EC2  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚         â†‘                       â”‚
â”‚    counter2 methods             â”‚
â”‚    reference this count         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

They are COMPLETELY isolated!
```

**Key Insight:**

- Function **definition** = shared (same code)
- Function **invocation** = separate execution contexts with independent variables
- Closures capture their **specific** execution context's variable environment

**When DO Variables Get Shared?**

Only when they're defined in a **common outer scope**:

```javascript
let sharedCount = 0; // â† Outside the function (shared scope)

function createCounter() {
  return {
    increment: () => sharedCount++,
    getCount: () => sharedCount,
  };
}

const counter1 = createCounter();
const counter2 = createCounter();

counter1.increment(); // sharedCount = 1
counter2.increment(); // sharedCount = 2
console.log(counter1.getCount()); // 2 (shared!)
console.log(counter2.getCount()); // 2 (shared!)
```

**Interview-Ready Statement:**

> "A function definition is shared, but each function invocation creates a new execution context with its own independent variable environment. Closures capture their specific scope instance, so separate calls do not share state unless the state comes from a shared outer scope."

### FEC and Call Stack

- When a function is invoked, its **Execution Context** is pushed onto the call stack.
- Once the function finishes execution, its **Execution Context** is popped off the stack, and the execution continues in the context below it.

## 4. Eval Execution Context (though rarely used)

- Created when the eval() function is executed.
- Executes code within a string.
