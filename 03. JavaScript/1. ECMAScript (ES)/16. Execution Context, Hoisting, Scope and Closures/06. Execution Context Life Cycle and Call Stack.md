# Execution Context Life Cycle and Call Stack

## Life Cycle of an Execution Context

Each EC has two stages/phases:

1. Creation/Memory Phase
2. Execution Phase

## 1. Creation/Memory Phase (Hoisting Occurs here)

- **All three components** (Variable Environment, Lexical Environment, and this Binding) are **created** during this phase.
- Sets up the memory for variables and functions `(Hoisting occurs here)`.
- **Hoisting** occurs for both `GEC` and `FEC`.

> ğŸ“– **For detailed information about what each component stores and how they're initialized, see [03. Components of Execution Context](./03.%20Components%20of%20Execution%20Context.md).**

A new execution context gets created whenever:

1. The JavaScript engine starts running (`Global Execution Context`)
2. A module is imported (`Module Execution Context`)
3. A function (irrespective of same or different functions or arrow functions) is invoked (`Function Execution Context`)
4. `eval()` is executed (`Eval Execution Context`)

**Summary of what happens:**

- **Variable Environment**: Created; `var` declarations initialized to `undefined`, function declarations fully initialized.
- **Lexical Environment**: Created; `let`/`const` declarations allocated but not initialized (TDZ), scope chain established.
- **this Binding**: Created and its value determined based on context type.

## 2. Execution Phase

- Executes the code line by line.
- Assigns values to variables and executes functions.
- **Important:** The three components were already **created** in the Creation Phase. This phase initializes TDZ variables, updates values, and executes code.

**What happens:**

1. **Variable Assignment**:

   - Variables in Variable Environment are assigned their actual values (from `undefined` to actual value).
   - Variables in Lexical Environment are initialized with their actual values (exiting TDZ).
   - Functions are executed as they are invoked.

2. **Code Execution**:
   - The Thread of Execution processes statements one by one.
   - If a function is called, a new execution context is created for it (with all three components created in its Creation Phase) and pushed onto the call stack.

## Destruction (Not part of the EC lifecycle)

Once the execution of the context is complete, it is destroyed and popped from the call stack.

Key Steps:

1. `Context Removal from Call Stack`:
   The execution context is popped off the call stack.

2. `Memory Cleanup`:
   The JavaScript engine cleans up memory for variables and functions declared in the execution context (unless they are referenced by closures).

Example During Destruction Phase:
After the function foo has executed completely, its execution context is removed from the call stack.

## Example of EC Life Cycle

**Example 1:**

```js
let a = 5;
var b = 10;
```

Memory Phase

```sql
Lexical Environment:
   a â†’ TDZ

Variable Environment:
   b â†’ undefined

```

Execution phase:

```sql
a â†’ 5
b â†’ 10

```

## Order of the EC on Call Stack (Global on Bottom, Eval on Top)

Execution contexts enter the call stack only when functions are invoked.
In nested calls, the deepest (most nested) function is pushed last onto the stack but completes and returns first â€” this follows FILO/LIFO (First In Last Out / Last In First Out) stack behavior.

The call stack grows when functions are invoked and shrinks when they return.
So nested execution contexts are pushed and later popped before outer calls continue.
The JavaScript stack collapses and rebuilds, it doesnâ€™t just keep growing.

**Example 1:**

```js
function a() {
  function b() {
    function c() {
      eval("console.log('Hello')");
    }
    c();
  }
  b();
}
a();
```

Execution context order when above code executes:

1. Global EC created
2. a() called â†’ FEC(a) created
3. b() called â†’ FEC(b) created
4. c() called â†’ FEC(c) created
5. eval() called â†’ Eval EC created
6. Eval EC completes â†’ popped
7. FEC(c) completes â†’ popped
8. FEC(b) completes â†’ popped
9. FEC(a) completes â†’ popped

Back to Global EC

The JavaScript call stack builds upward starting from the Global Execution Context at the bottom. Module Execution Contexts are created when modules are imported/evaluated (typically during initialization). Function Execution Contexts (including nested ones) are pushed as functions are invoked, and Eval Execution Contexts are pushed when `eval()` executes. All contexts are managed in LIFO (Last In First Out) order, meaning the most recently pushed context executes first and is popped first.

**Example 2:**

```js
function A() {
  function A1() {
    function A2() {}
    A2();
  }
  A1();
}

function B() {}

function C() {
  function C1() {}
  C1();
}

A();
B();
C();
```

Call Stack: GC â†’ A â†’ A1 â†’ A2 â†’ B â†’ C â†’ C1 âŒ This is incorrect.

Real runtime order is:
Push into stack (call time)

âœ” Global EC
â†’ call A() â†’ push A EC
â†’ call A1() â†’ push A1 EC
â†’ call A2() â†’ push A2 EC

Pop (return time)

â† return A2() â†’ pop
â† return A1() â†’ pop
â† return A() â†’ pop

Continue

â†’ call B() â†’ push B EC
â† return B() â†’ pop

â†’ call C() â†’ push C EC
â†’ call C1() â†’ push C1 EC
â† return C1() â†’ pop
â† return C() â†’ pop

Call Stack:

```sql
GC
â†’ A
â†’ A1
â†’ A2
â† A2 returned
â† A1 returned
â† A returned
â†’ B
â† B returned
â†’ C
â†’ C1
â† C1 returned
â† C returned
```
