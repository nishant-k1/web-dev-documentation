# Closure vs Lexical Scope

> üìñ **Parent Topic:** [05. Lexical Scope](./05.%20Lexical%20Scope.md)

## LEXICAL SCOPE (always happens)

Whenever you write:

```js
function outer() {
  let x = 10;

  function inner() {
    console.log(x);
  }
}
```

The inner function can see x because of lexical scoping.

‚û°Ô∏è This access exists ONLY while the outer function is running.
‚û°Ô∏è This is NOT closure yet.
‚û°Ô∏è This is just JavaScript scope rules.

Eg:
Case 1: No closure (just lexical scope)

```js
function outer() {
  let x = 10;

  function inner() {
    console.log(x);
  }

  inner(); // Called before outer ends
}
```

Here:

inner is defined ‚Üí JS prepares closure blueprint
inner is called immediately ‚Üí sees x via lexical scope
outer finishes ‚Üí inner no longer matters

‚û°Ô∏è No closure persists
‚û°Ô∏è NOT a closure use case
‚û°Ô∏è Just lexical scope

Case 2: Closure truly happens

```js
function outer() {
  let x = 10;

  return function inner() {
    console.log(x);
  };
}

const fn = outer();
fn(); // outer is finished, but still prints x
```

Now:

inner OUTLIVES outer
so x must remain alive
JavaScript creates a CLOSURE

Case 3: Closure without returning

```js
function outer() {
  let x = 10;

  setTimeout(function inner() {
    console.log(x);
  }, 1000);
}
```

Here‚Äôs what happens:

- inner is defined ‚Üí closure blueprint created
- inner is saved by setTimeout, NOT destroyed
- outer exits
- timeout fires after 1 second
- inner STILL needs access to x
- therefore JS creates & keeps a closure

This is a closure EVEN THOUGH inner is not returned.

Because:

‚û°Ô∏è The inner function survives
‚û°Ô∏è It is executed after outer has returned
‚û°Ô∏è Therefore closure persists outer variables

## CLOSURE (happens only if inner function OUTLIVES outer function)

A closure is created when the inner function survives after the outer function returns.
Closure = inner function + preserved outer variables after the outer function is gone
This ONLY happens when the inner function is:

- `returned`
- `or stored`
- `or passed elsewhere`
- `or scheduled for later (callback)`
- `or attached as an event handler`
- `or saved in a ref`
- `or saved in a module`
- `or used in async logic`

In these cases, the outer function has finished,
but the inner function is still alive ‚Üí closure.

THE KEY DISTINCTION

‚úîÔ∏è Lexical scope ‚Üí inner function can access outer variables WHILE outer is still running
‚úîÔ∏è Closure ‚Üí inner function can access outer variables EVEN AFTER outer has finished

Every inner function has the ability to form a closure.

(because closure blueprint is created at definition time)

But an actual closure only exists if the inner function outlives the outer one.

Closure is NOT about returning.
Closure is about survival.

## Relationship between Closures and Lexical Scoping

- lexical scope and closures are closely related concepts in JavaScript. However, they are not the same. Closures depend on lexical scope.
- Without lexical scope, closures wouldn‚Äôt exist. Here‚Äôs how they interact.
- Lexical scope determines what variables a function can access based on where it was declared.

  1. **Lexical Scope**

     - It is based on where the function is declared, not where it is executed.
     - The scope of a function is determined at the time of its declaration.
     - It establishes the "rules" for what variables the function has access to.
     - Lexical scope does not require the function to be executed; it‚Äôs a static property.

     ```Javascript
     // Here, inner can access outerVar because of lexical scoping.
     // Even if inner is executed outside outer, it remembers the scope in which it was defined.

     function outer() {
       let outerVar = "I'm from outer!";

       function inner() {
         console.log(outerVar); // Lexical scoping allows access to `outerVar`
       }

       return inner;
     }

     const innerFunc = outer();
     innerFunc(); // Output: "I'm from outer!"
     ```

  2. **Closures**

     - A closure captures the lexical scope at runtime and keeps it alive.
     - It allows inner functions to maintain access to variables from their parent scope even after the parent function has executed.

     ```Javascript
       // The returned function increment forms a closure over the counter variable.
       // Even though the outer function has finished execution, its variables are kept alive because of the closure.
     function outer() {
     let counter = 0;

     return function increment() {
       counter++; // Closure allows access to `counter`
       console.log(counter);
     };
     }

     const incrementFunc = outer();
     incrementFunc(); // Output: 1
     incrementFunc(); // Output: 2
     ```

## Misconception: Closure = Lexical Scope

### Why it feels similar

- Lexical scope enables closures.
- The variables accessible through a closure are determined by lexical scope.

### Why it‚Äôs different

- Lexical scope is static and theoretical.
- Closures are dynamic and only come into play when functions are executed and variables are retained.

### Common Questions and Clarifications

1. Does lexical scope always create a closure?
   No, a closure only happens when a function "remembers" its outer scope after the outer function has finished execution.

2. Can closures exist without lexical scope?
   No, closures rely on lexical scope to determine what variables they can "remember."

3. Do closures always lead to memory leaks?
   Not necessarily. Closures only lead to memory leaks if they unnecessarily retain references to large objects or unneeded variables.

### Summary

1. `Lexical Scope`: Determines the variables a function can access based on its location in the code.
2. `Closure`: A function that "remembers" variables from its lexical scope even after the outer function has executed.
3. `Key Insight`: Lexical scope is the "rulebook," while closures are the "mechanism" that puts the rules into practice.
