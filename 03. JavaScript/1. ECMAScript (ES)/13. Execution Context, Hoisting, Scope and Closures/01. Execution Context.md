# Execution Context = an internal record (object-like structure)

- An Execution Context is a container that holds information about the environment in which the code is executed.
- An execution context in JavaScript represents the environment in which JavaScript code is evaluated and executed.
- Execution Contexts are created by the engine in memory first, then referenced in the call stack.
  When execution completes, the reference is popped ‚Äî and the EC is discarded.

- **Note:** Arrow functions DO create their own execution context. What they don't create is their own `this` binding, `arguments` object, `super`, or `new.target`. They inherit `this` from their enclosing lexical scope.

## Types of Execution Contexts (4 Types)

1. **Global Execution Context (GEC):** For the main script.

   - Created when the JavaScript engine starts running
   - Always present at the bottom of the call stack
   - In the global execution context, `this` refers to the global object (`global` in Node.js or `window` in Browser JavaScript Runtime Environment)

2. **Module Execution Context (MEC):** For each ES Module when evaluated.

   - Created when a module is imported

3. **Function Execution Context (FEC):** For each function call.

   - Created whenever a function is invoked

4. **Eval Execution Context (EEC):** For eval code (rarely used).
   - Created when `eval()` is executed

## Components of Execution Context

Each Execution Context contains 3 important components:

1. **Lexical Environment**
2. **Variable Environment**
3. **This Binding**

The JS engine creates a structured "record":

```js
ExecutionContext = {
  LexicalEnvironment: { ... },
  VariableEnvironment: { ... },
  ThisBinding: value
}
```

üëâ This is NOT created as a JS object using `{}`  
üëâ But engine stores it in a similar form internally

So conceptually, YES ‚Äî it is an object. But why do we say "object-like" instead of "object"?

- ‚ùå You can't log it
- ‚ùå You can't reference it
- ‚ùå You can't read or modify its properties
- It's completely internal to the JS engine.
- ‚úîÔ∏è But the engine implements it like a structured record with fields

```js
console.log(executionContext); // impossible
```

## Life Cycle of Execution Context

```sql
1. Push EC (Creation)
2. Run EC (Execution)
Pop EC (Removal) // Not counted as stage/phase of EC
```

Each Execution Context has 2 stages/phases followed by pop/destruction/removal from the call stack

1. Creation/Memory Phase
2. Execution Phase

EC Destruction

**Execution Context does get destroyed ‚Äî but it isn‚Äôt considered a phase. Once execution finishes, the context is popped from the stack. Only creation & execution are meaningful phases.**

## Call Stack and Execution Context (Both are abstract concepts in Js)

- Like the execution context, the call stack in JavaScript is also an abstract concept.
- The call stack is a conceptual model used by the JavaScript engine to manage the execution of function calls.
- You cannot directly see or manipulate the call stack in your code, but understanding how it works is crucial to understanding how JavaScript executes code.

- The JavaScript engine maintains a **call stack**, which is a stack of `execution contexts`.
- The most recently created execution context is placed on top of the stack: **LIFO / FILO**:
- The Global Execution Context is always present at the bottom of the call stack.

## Sequential Execution within Execution Context

- `Within a single execution context, code is executed sequentially`, following the order in which it appears in the code. This means that statements within the same function are executed in the order they are written, from top to bottom. There's no reordering based on LIFO/FILO principles within the same execution context.
- The LIFO/FILO principle applies at the level of the call stack, where execution contexts are pushed and popped as functions are called and return. But within each individual execution context, the code executes in a straightforward, sequential manner.

## Abstract Nature of Execution Context and Call Stack

### What Does "Abstract" Mean?

- Abstract does not mean "not real" or "not important."
- Abstract just means you can't directly access it in your code, but the JavaScript engine uses it internally to execute your program.
- In general, "abstract" means something that is not directly tangible or visible but is conceptual or theoretical. It exists in a logical or conceptual sense rather than as a physical or directly observable thing.
- Think of "abstract" as "you can understand it, but you can't touch or see it directly."
- It's like the idea of "time"‚Äîyou can measure and experience it, but you can't physically hold it.

### How is Execution Context and Call Stack Abstract in JavaScript?

- The execution context is a logical construct created by the JavaScript engine every time a function or global code is executed.
- The execution context is abstract because it's an internal mechanism of the JavaScript engine.
- You can't see or directly interact with it in your code, but it determines how the code runs (e.g., resolving `this`, variables, and scope).
- It is not something you can see or directly interact with in your code, like an object or a variable.
- However, it exists conceptually and plays a crucial role in determining:

  - How variables are resolved.
  - What the value of `this` is.
  - The function's environment.

- Similarly for the Call Stack you cannot directly see or manipulate the call stack in your code, but understanding how it works is crucial to understanding how JavaScript executes code.

### Is the Execution Context an Object?

- No, the execution context itself is not an object you can directly access.
- However:
  - The `this` value, which is part of the execution context, typically refers to an object.
  - When a function executes, the `this` value is determined and becomes a part of the execution context.
- In simpler terms:
  - The execution context is not an object.
  - But it includes information (like the value of `this`) that often refers to an object.

### Relationship Between Execution Context and Object

While the execution context is not itself an object, it has a `this` binding that refers to an object in most cases:

- In global execution: `this` refers to the global object.
- In a method: `this` refers to the object calling the method.
- In explicitly bound functions: `this` refers to the bound object.

- The execution context is a conceptual environment, not an object, but it includes:

  1. `this`, which typically points to an object.
  2. The variable environment and lexical scope.

- So while the execution context itself is abstract, the `this` inside it often refers to an object, which can sometimes make it feel like the execution context is tied to that object.

- Understanding execution context is fundamental to grasping concepts like scope, closures, and the `this` keyword.
