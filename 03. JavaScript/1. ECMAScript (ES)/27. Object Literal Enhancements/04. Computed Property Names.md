# Computed Property Names

Computed property names allow you to dynamically determine the name of a property on an object using an expression.

---

## Syntax

In object literals, computed property names allow you to use expressions (like variables or function calls) as keys:

```javascript
const obj = {
  [expression]: value, // Here, expression is an expression that evaluates to a string, which becomes the property name of the object. value is the value assigned to that property.
};

const key = "name";
const obj = {
  [key]: "Nishant",
};
console.log(obj); // { name: "Nishant" }
```

---

## Real-World Uses

- Dynamically generate object keys (e.g. Redux actions, dynamic form states)
- Define properties based on function parameters
- Meta programming (dynamic method names, computed keys)

### In Class Definitions

In class definitions, you can use computed property syntax to name methods dynamically:

```js
class Test {
  [dynamicMethodName]() {}
}
```

---

## Key Points

- Computed property names provide flexibility in creating dynamic objects.
- The expression used for the property name must evaluate to a string.
- Computed property names can be used with both object literals and the Object.defineProperty method.
- They are often used in conjunction with other ES6 features like destructuring and templates.

---

## Examples

### Basic Usage

```javascript
const prefix = "user";
const user = {
  [`${prefix}Id`]: 123,
  [`${prefix}Name`]: "John",
};
// { userId: 123, userName: "John" }
```

### Dynamic Keys from Variables

```javascript
const key1 = "firstName";
const key2 = "lastName";

const person = {
  [key1]: "John",
  [key2]: "Doe",
};
// { firstName: "John", lastName: "Doe" }
```

### Computed Method Names

```javascript
const methodName = "greet";

const obj = {
  [`${methodName}User`]() {
    return "Hello!";
  },
};

obj.greetUser(); // "Hello!"
```

### Redux Actions

```javascript
const createAction = (type) => (payload) => ({
  type,
  [type.toLowerCase()]: payload,
});
```

---

## Related Topics

- [01. Object Literal Enhancements Overview](./01.%20Object%20Literal%20Enhancements%20Overview.md)
- [02. Property Shorthand](./02.%20Property%20Shorthand.md)
- [03. Method Shorthand](./03.%20Method%20Shorthand.md)

---

## Summary

**What Changed:**

- **Before ES6:** You could not directly use a variable as a key inside an object literal. You had to define the object first and then assign the variable as a key.
- **After ES6:** Using computed property names, you can directly use a variable (or any expression) as an object key inside the object literal itself.

Now, object keys can be dynamic just like values!
