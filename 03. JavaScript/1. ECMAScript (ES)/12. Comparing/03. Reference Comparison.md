# Reference Comparison

Reference comparison checks if two non-primitive values (objects, arrays, functions) point to the same memory location.

## How Reference Comparison Works

- Compares references, not the actual content.
- Two non-primitives are considered equal only if they point to the same memory location.
- This is the default behavior when using `===` or `==` with objects/arrays.

## Direct Equality (`===`)

```js
let obj1 = { name: "Nishant" };
let obj2 = { name: "Nishant" };
console.log(obj1 === obj2); // false (different references)

let obj3 = obj1;
console.log(obj1 === obj3); // true (same reference)
```

## Object.is()

- Mostly behaves like `===`, but handles some edge cases.
- For objects, behaves the same as `===` (compares references).
- Useful for primitive edge cases like `NaN` and `+0/-0`.

```js
// For objects - same as ===
let obj1 = { x: 1 };
let obj2 = { x: 1 };
Object.is(obj1, obj2); // false (different references)

let obj3 = obj1;
Object.is(obj1, obj3); // true (same reference)

// Edge cases for primitives
Object.is(NaN, NaN); // true
NaN === NaN; // false

Object.is(+0, -0); // false
+0 === -0; // true
```

## Key Characteristics

1. **Same content, different references = not equal**
   ```js
   let arr1 = [1, 2, 3];
   let arr2 = [1, 2, 3];
   arr1 === arr2; // false (different references)
   ```

2. **Same reference = equal**
   ```js
   let arr1 = [1, 2, 3];
   let arr2 = arr1;
   arr1 === arr2; // true (same reference)
   ```

3. **If reference equal, automatically shallow and deep equal**
   - If `obj1 === obj2` (same reference), they are automatically:
     - Shallow equal
     - Deep equal

## Use Cases

- **React state comparison** - React uses reference comparison to determine if state changed
- **Object identity checks** - Verifying if two variables point to the same object
- **Performance optimization** - Faster than content comparison

## Important Notes

- Reference comparison does not check content - only memory location
- Two objects with identical properties are not equal if they're different objects
- An object's reference hasn't changed if you haven't assigned it a new object (e.g., `obj = {...}`)
