# Async Operations

- Operations in JavaScript that take time to complete and don't block the execution of the next statements.
- You don't get the result immediately but it doesn't cause any blockage either.
- So you need a way to be notified when the result is ready â€” this is handled using callbacks or promises.
- Callbacks/promises are used to handle their result, not to make them async.
- time consuming WebAPIs are inherently async and can be handled via callback or promises
- You can't magically make a sync operation truly async, but you can simulate async behavior using timers, Web Workers, etc.

## Callback

Callback: A function passed as an argument to handle the result once the async operation completes.

## Promise

Promise: An object representing the eventual result of an async operation, allowing .then() and .catch() chaining.

## Purpose of a Callback or Promise

1. ðŸ” A callback or .then() in a promise is used to handle the result of an async operation when it finishes.
2. They are not responsible for making the operation async â€” they're just notification handlers.

## WebAPIs Operations

There can be both synchronous and asynchronous time-taking operations in JavaScript.
However, Web APIs are almost always asynchronous if the operation is time-consuming.
There are very few or no Web APIs that are both synchronous and time-taking, because that would block the main thread and degrade user experience.

## Async WebAPIs

**Async Web APIs are not asynchronous by themselves â€” they are made to behave asynchronously through the event loop and task queue system.**

Web APIs are async because of the Event Loop â€” not because they are inherently special.

Web APIs (like fetch, setTimeout) are inherently async, built that way by design.

Inherent Asynchrony: Web APIs are implemented in the browser's or Node.js's C++ codebase, outside the JavaScript engine. They handle operations (e.g., timers, network requests) non-blocking, allowing the JavaScript engine to execute other code.

Design: These APIs offload work to the runtime environment (e.g., browser's timer or network modules). On completion, callbacks or promises are scheduled via the event loop (task queue for callbacks, microtask queue for promises).

Asynchrony is a feature of the Web API's implementation, not created by JavaScript, callbacks, or promises. Callbacks/promises are interfaces for handling results.

Once a Web API (like setTimeout, fetch, or FileReader) completes its async operation, it does not immediately execute the callback. Instead:

ðŸŽ¯ It pushes the callback or .then() function to the appropriate queue â€” either the macrotask queue or microtask queue â€” depending on the API used.

## Async Web APIs fall into two categories based on how you handle them

1. Callback-based Async Web APIs:

   1. These expect you to pass a callback function that will run when the operation completes.
   2. These do not return promises by default.

   ```js
   setTimeout(() => {
     console.log("Runs after delay"); // callback
   }, 1000);

   navigator.geolocation.getCurrentPosition(
     (position) => console.log(position), // success callback
     (error) => console.error(error) // error callback
   );
   ```

2. Promise-based Async Web APIs

   1. These return a Promise, so you can use .then(), .catch() or await.

   ```js
   fetch("https://api.example.com/data")
     .then((res) => res.json())
     .then((data) => console.log(data));

   const res = await fetch("https://api.example.com/data");
   const data = await res.json();
   ```

## sync time-taking operations in js engine

There can be sync time-taking operations in JS

- Loops
- JSON parsing
- Math calculations

These are JS engine operations, not Web APIs.

## There can be async time-taking WebAPIs operations but in general no sync time taking WebAPIs

- fetch
- setTimeout
- readFile (in Node.js)
- navigator.geolocation.getCurrentPosition

These use Web APIs (in browser) or libuv (in Node.js)

## There can be execeptional discouraged sync time-taking WebAPIs operations

Exception (rare & risky):
Some synchronous Web APIs do exist, but they're usually quick or discouraged if time-consuming.

Examples:

localStorage.getItem() â€” synchronous (can be slow if misused)

alert() â€” synchronous and blocking UI (not time-taking computationally)

XMLHttpRequest.open(..., false) â€” synchronous XHR â€” deprecated, strongly discouraged

## Conclusion

There are both synchronous and asynchronous time-taking operations in JavaScript.
But Web APIs that are time-taking are designed to be asynchronous, to avoid blocking the main thread.
Synchronous & time-consuming Web APIs are either deprecated or discouraged.


