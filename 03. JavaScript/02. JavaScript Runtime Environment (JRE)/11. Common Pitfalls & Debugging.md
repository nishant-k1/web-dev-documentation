# Common Pitfalls & Debugging

## Overview

This guide consolidates common pitfalls, misconceptions, and debugging techniques for JavaScript Runtime Environment concepts. Understanding these helps avoid bugs and debug issues effectively.

## Common Pitfalls

### 1. Event Loop Pitfalls

#### Microtask Starvation

**Problem:** Infinite microtask loops prevent macrotasks from executing.

```javascript
// ❌ Infinite microtasks block rendering
function infiniteMicrotasks() {
  Promise.resolve().then(infiniteMicrotasks);
}
infiniteMicrotasks(); // UI freezes!

// ✅ Limit microtask chains
let count = 0;
function limitedMicrotasks() {
  if (count++ > 100) return;
  Promise.resolve().then(limitedMicrotasks);
}
```

**Symptoms:**

- UI becomes unresponsive
- setTimeout callbacks never execute
- Event handlers don't fire

**Debugging:**

- Use Performance tab to see microtask queue
- Check for recursive Promise chains
- Monitor task execution timeline

#### Long Macrotasks Blocking UI

**Problem:** Long-running synchronous code blocks the event loop.

```javascript
// ❌ Blocks UI for seconds
function processLargeDataset(data) {
  for (let item of data) {
    expensiveOperation(item); // Blocks!
  }
}

// ✅ Break into chunks
function processLargeDatasetAsync(data) {
  let index = 0;
  function processChunk() {
    const chunk = data.slice(index, index + 100);
    chunk.forEach(expensiveOperation);
    index += 100;
    if (index < data.length) {
      setTimeout(processChunk, 0);
    }
  }
  processChunk();
}
```

**Symptoms:**

- UI freezes
- Animations stutter
- Input lag

**Debugging:**

- Use Performance tab to identify long tasks
- Look for tasks > 50ms
- Break up into smaller chunks

#### Misunderstanding setTimeout(0)

**Problem:** Expecting `setTimeout(fn, 0)` to run immediately.

```javascript
console.log("1");
setTimeout(() => console.log("2"), 0);
Promise.resolve().then(() => console.log("3"));
console.log("4");
// Output: 1, 4, 3, 2 (not 1, 2, 4, 3!)
```

**Reality:** `setTimeout(0)` queues a macrotask, which runs after:

1. All current synchronous code
2. All microtasks (Promises)

**Debugging:**

- Understand execution order: sync → microtasks → macrotasks
- Use `queueMicrotask()` for immediate microtask scheduling

### 2. Memory Management Pitfalls

#### Memory Leaks from Event Listeners

**Problem:** Forgetting to remove event listeners.

```javascript
// ❌ Memory leak
function setupListener() {
  const button = document.getElementById("button");
  button.addEventListener("click", () => {
    console.log("clicked");
  });
  // Listener never removed!
}

// ✅ Clean up
function setupListener() {
  const button = document.getElementById("button");
  const handler = () => console.log("clicked");
  button.addEventListener("click", handler);

  // Clean up when done
  return () => button.removeEventListener("click", handler);
}
```

**Symptoms:**

- Memory usage grows over time
- Multiple handlers fire (if added multiple times)
- Objects not garbage collected

**Debugging:**

- Use Memory tab → Heap Snapshot
- Look for detached DOM nodes
- Check event listener count

#### Global Variable Leaks

**Problem:** Implicit global variables persist for program lifetime.

```javascript
// ❌ Implicit global
function processData() {
  tempData = fetchData(); // Missing var/let/const!
  process(tempData);
}
// tempData persists forever

// ✅ Local variable
function processData() {
  const tempData = fetchData();
  process(tempData);
  // tempData GC'd when function returns
}
```

**Debugging:**

- Use strict mode: `'use strict'` prevents implicit globals
- Check `window` object for unexpected properties
- Use Memory tab to find global references

#### Uncleared Timers

**Problem:** Timers keep callbacks in memory.

```javascript
// ❌ Timer never cleared
function startTimer() {
  setInterval(() => {
    console.log("tick");
  }, 1000);
  // Timer runs forever!
}

// ✅ Clear timer
function startTimer() {
  const timerId = setInterval(() => {
    console.log("tick");
  }, 1000);

  // Clear when done
  return () => clearInterval(timerId);
}
```

**Debugging:**

- Use Performance tab → Memory → check timer count
- Monitor memory growth over time
- Clear timers in cleanup functions

### 3. Call Stack Pitfalls

#### Stack Overflow from Deep Recursion

**Problem:** Recursive functions exceed stack limit.

```javascript
// ❌ Can overflow
function factorial(n) {
  if (n === 0) return 1;
  return n * factorial(n - 1);
}
factorial(100000); // Stack overflow!

// ✅ Use iteration
function factorialIterative(n) {
  let result = 1;
  for (let i = 1; i <= n; i++) {
    result *= i;
  }
  return result;
}
```

**Debugging:**

- Check stack trace for repeated function calls
- Use DevTools Call Stack panel
- Add depth tracking to recursive functions

### 4. Garbage Collection Pitfalls

#### Assuming Circular References Cause Leaks

**Problem:** Worrying about circular references unnecessarily.

```javascript
// ✅ Modern GC handles this correctly
let objA = { ref: null };
let objB = { ref: null };
objA.ref = objB;
objB.ref = objA;

objA = null;
objB = null;
// Both GC'd - no leak!
```

**Reality:** Mark-and-sweep algorithm handles circular references correctly.

**Debugging:**

- Don't worry about circular references if objects are unreachable
- Focus on reachable references (event listeners, timers, globals)

## Common Misconceptions

### ❌ "Event loop runs the code"

**Reality:** The JavaScript engine (call stack) runs the code. The event loop only **coordinates** when code should run.

### ❌ "Promises run synchronously"

**Reality:** The promise executor runs synchronously, but `.then()` callbacks are microtasks that run asynchronously.

```javascript
console.log("1");
Promise.resolve().then(() => console.log("2"));
console.log("3");
// Output: 1, 3, 2
```

### ❌ "setTimeout with 0ms runs immediately"

**Reality:** It queues a macrotask, which runs after all synchronous code and all microtasks.

### ❌ "Garbage collection is instant"

**Reality:** GC can cause pauses (stop-the-world events) that block execution.

### ❌ "Stack and heap are the same"

**Reality:**

- **Stack**: Fast, limited size, managed automatically, stores primitives and references
- **Heap**: Slower, larger, managed by GC, stores objects and complex data

## Debugging Techniques

### 1. Chrome DevTools - Performance Tab

**Purpose:** Identify performance bottlenecks and long tasks.

**Steps:**

1. Open DevTools (F12)
2. Go to **Performance** tab
3. Click **Record** (circle icon)
4. Perform actions
5. Stop recording
6. Analyze:
   - Long tasks (> 50ms)
   - GC events
   - Frame rate
   - Task breakdown

**What to Look For:**

- Red bars (long tasks)
- Yellow bars (GC pauses)
- Low frame rate
- Task execution timeline

### 2. Chrome DevTools - Memory Tab

**Purpose:** Identify memory leaks and memory usage.

**Heap Snapshot:**

1. Go to **Memory** tab
2. Select **Heap Snapshot**
3. Click **Take snapshot**
4. Perform actions
5. Take another snapshot
6. Compare snapshots
7. Look for:
   - Growing object counts
   - Detached DOM nodes
   - Retained size

**Allocation Timeline:**

1. Select **Allocation timeline**
2. Click **Start**
3. Perform actions
4. Stop
5. Analyze memory allocation over time

**What to Look For:**

- Steadily growing memory
- Detached nodes
- Large retained sizes
- Objects that should be GC'd

### 3. Chrome DevTools - Sources Tab

**Purpose:** Debug call stack and execution flow.

**Call Stack Panel:**

1. Set breakpoints in code
2. When paused, view **Call Stack** panel
3. See:
   - Current function
   - Calling functions
   - Stack depth
   - Variable values

**Debugging Stack Overflow:**

- Check stack depth
- Look for repeated function calls
- Identify infinite recursion

### 4. Console Debugging

**Logging:**

```javascript
// Track execution order
console.log("1. Start");
Promise.resolve().then(() => console.log("2. Microtask"));
setTimeout(() => console.log("3. Macrotask"), 0);
console.log("4. End");
// Output: 1, 4, 2, 3
```

**Performance Markers:**

```javascript
performance.mark("start");
// Your code
performance.mark("end");
performance.measure("duration", "start", "end");
console.log(performance.getEntriesByName("duration"));
```

**Memory Tracking:**

```javascript
if (performance.memory) {
  console.log({
    used: (performance.memory.usedJSHeapSize / 1048576).toFixed(2) + " MB",
    total: (performance.memory.totalJSHeapSize / 1048576).toFixed(2) + " MB",
  });
}
```

### 5. Node.js Debugging

**Inspect Mode:**

```bash
node --inspect script.js
# Opens Chrome DevTools for Node.js
```

**GC Tracking:**

```bash
node --expose-gc --trace-gc script.js
# Logs GC events
```

**Memory Profiling:**

```javascript
const v8 = require("v8");
const heapStats = v8.getHeapStatistics();
console.log(heapStats);
```

### 6. Error Handling

**Catch Stack Overflow:**

```javascript
try {
  recursiveFunction(100000);
} catch (error) {
  if (error.message.includes("Maximum call stack")) {
    console.error("Stack overflow detected!");
    // Handle gracefully
  }
}
```

**Monitor Memory:**

```javascript
function checkMemory() {
  if (performance.memory) {
    const used = performance.memory.usedJSHeapSize;
    const limit = performance.memory.jsHeapSizeLimit;
    if (used > limit * 0.9) {
      console.warn("Memory usage high!");
    }
  }
}
setInterval(checkMemory, 5000);
```

## Best Practices for Debugging

1. **Reproduce the Issue**: Create minimal test case
2. **Use DevTools**: Performance, Memory, Sources tabs
3. **Add Logging**: Track execution flow and memory
4. **Profile First**: Measure before optimizing
5. **Check Stack Traces**: Understand call chains
6. **Monitor Memory**: Watch for leaks over time
7. **Test Edge Cases**: Large inputs, long-running operations

## Common Interview Questions

### Q: How do you debug a memory leak?

**A:**

1. Use Chrome DevTools Memory tab
2. Take heap snapshots before/after actions
3. Compare snapshots to find growing objects
4. Look for detached DOM nodes
5. Check for uncleared event listeners/timers
6. Monitor memory usage over time

### Q: How do you identify performance bottlenecks?

**A:**

1. Use Performance tab to record
2. Look for long tasks (> 50ms)
3. Identify GC pauses
4. Check frame rate
5. Analyze task breakdown
6. Profile specific functions

### Q: What causes UI freezing?

**A:**

- Long-running synchronous code
- Infinite microtask loops
- Heavy GC pauses
- Blocking operations on main thread

**Solution:**

- Break work into chunks
- Use Web Workers
- Optimize GC pressure
- Use requestAnimationFrame for UI

### Q: How do you debug stack overflow?

**A:**

1. Check stack trace for repeated calls
2. Use DevTools Call Stack panel
3. Add depth tracking to recursive functions
4. Convert recursion to iteration
5. Check for missing base cases

## Related Topics

- [07. Event Loop.md](./07.%20Event%20Loop.md) - Event loop details
- [06. Memory Leaks.md](./06.%20Memory%20Leaks.md) - Memory leak prevention
- [08. Stack Overflow.md](./08.%20Stack%20Overflow.md) - Stack overflow debugging
- [12. Memory Profiling Guide.md](./12.%20Memory%20Profiling%20Guide.md) - Profiling techniques
- [10. Performance Optimization.md](./10.%20Performance%20Optimization.md) - Optimization strategies

