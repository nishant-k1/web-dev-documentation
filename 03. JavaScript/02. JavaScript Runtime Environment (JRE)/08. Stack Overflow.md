# Stack Overflow

## What is Stack Overflow?

A **stack overflow** occurs when the call stack exceeds its maximum size due to too many nested function calls being pushed onto the stack without returning. This is a critical runtime error that can crash your application.

## Understanding the Call Stack

- The call stack is a data structure that stores **Execution Contexts** (stack frames)
- Each function call creates a new execution context that is pushed onto the stack
- When a function completes, its execution context is popped from the stack
- The stack operates on **LIFO** (Last In, First Out) principle
- The stack has a **limited size** (typically around 10,000-50,000 frames, depending on the engine and environment)

## Causes of Stack Overflow

### 1. Infinite Recursion (Most Common)

When a function calls itself indefinitely without a base case to stop:

```javascript
function overflow() {
  overflow(); // Infinite recursion - no base case
}
overflow(); // Error: Maximum call stack size exceeded
```

### 2. Deep Recursion

Even with a base case, very deep recursion can cause overflow:

```javascript
function factorial(n) {
  if (n === 0) return 1; // Base case exists
  return n * factorial(n - 1);
}

factorial(100000); // May cause stack overflow for very large numbers
```

### 3. Mutual Recursion

Two or more functions calling each other in a cycle:

```javascript
function functionA() {
  functionB(); // Calls functionB
}

function functionB() {
  functionA(); // Calls functionA back
}

functionA(); // Infinite cycle → Stack overflow
```

### 4. Recursive Data Structures

Deeply nested objects or arrays processed recursively:

```javascript
function processNested(obj) {
  if (typeof obj !== "object") return;
  for (let key in obj) {
    processNested(obj[key]); // Deep nesting can overflow
  }
}

const deeplyNested = {
  a: {
    b: {
      c: {
        /* ... thousands of levels */
      },
    },
  },
};
processNested(deeplyNested); // Potential overflow
```

## Error Message

When stack overflow occurs, JavaScript throws:

```
RangeError: Maximum call stack size exceeded
```

or

```
Uncaught RangeError: Maximum call stack size exceeded
```

## Prevention Strategies

### 1. Use Iteration Instead of Recursion

Convert recursive functions to iterative solutions:

```javascript
// ❌ Recursive (can overflow)
function factorialRecursive(n) {
  if (n === 0) return 1;
  return n * factorialRecursive(n - 1);
}

// ✅ Iterative (safe)
function factorialIterative(n) {
  let result = 1;
  for (let i = 1; i <= n; i++) {
    result *= i;
  }
  return result;
}
```

### 2. Tail Call Optimization (TCO)

Use tail recursion where the recursive call is the last operation:

```javascript
// ❌ Not tail-recursive (accumulates stack frames)
function sum(n) {
  if (n === 0) return 0;
  return n + sum(n - 1); // Addition happens after recursion
}

// ✅ Tail-recursive (can be optimized by engine)
function sumTail(n, acc = 0) {
  if (n === 0) return acc;
  return sumTail(n - 1, acc + n); // Recursion is last operation
}
```

**Note:** While ES6 specifies TCO, most JavaScript engines (including V8) don't implement it. Use iteration for guaranteed safety.

### 3. Implement Base Cases Correctly

Always ensure recursive functions have proper base cases:

```javascript
// ❌ Missing or incorrect base case
function countdown(n) {
  console.log(n);
  countdown(n - 1); // No base case!
}

// ✅ Proper base case
function countdown(n) {
  if (n <= 0) return; // Base case
  console.log(n);
  countdown(n - 1);
}
```

### 4. Limit Recursion Depth

Add depth tracking to prevent excessive recursion:

```javascript
function processTree(node, depth = 0, maxDepth = 1000) {
  if (depth > maxDepth) {
    throw new Error("Maximum recursion depth exceeded");
  }
  // Process node
  if (node.children) {
    node.children.forEach((child) => {
      processTree(child, depth + 1, maxDepth);
    });
  }
}
```

### 5. Use Stack Data Structure

For complex recursive problems, use an explicit stack:

```javascript
// Recursive approach (can overflow)
function traverseTreeRecursive(node) {
  console.log(node.value);
  if (node.left) traverseTreeRecursive(node.left);
  if (node.right) traverseTreeRecursive(node.right);
}

// Iterative approach with explicit stack (safe)
function traverseTreeIterative(root) {
  const stack = [root];
  while (stack.length > 0) {
    const node = stack.pop();
    console.log(node.value);
    if (node.right) stack.push(node.right);
    if (node.left) stack.push(node.left);
  }
}
```

### 6. Break Up Large Operations

Split large recursive operations into smaller chunks:

```javascript
// Process large dataset in chunks
function processLargeArray(arr, chunkSize = 1000) {
  for (let i = 0; i < arr.length; i += chunkSize) {
    const chunk = arr.slice(i, i + chunkSize);
    processChunk(chunk); // Non-recursive processing
  }
}
```

## Debugging Stack Overflow

### 1. Browser DevTools - Call Stack Inspection

**Chrome DevTools:**

1. Open DevTools (F12)
2. Go to **Sources** tab
3. Set breakpoints in your recursive function
4. Use **Call Stack** panel to see:
   - Current function
   - All calling functions
   - Stack depth

**Example:**

```javascript
function recursiveFunction(n) {
  debugger; // Breakpoint here
  if (n === 0) return;
  return recursiveFunction(n - 1);
}
```

### 2. Stack Trace Analysis

When overflow occurs, the stack trace shows the call chain:

```
RangeError: Maximum call stack size exceeded
    at recursiveFunction (script.js:5:15)
    at recursiveFunction (script.js:5:15)
    at recursiveFunction (script.js:5:15)
    ... (repeated many times)
```

**What to look for:**

- Repeated function calls (indicates infinite recursion)
- Deep nesting (indicates very deep recursion)
- Missing base case (no termination condition visible)

### 3. Add Logging to Track Depth

```javascript
function recursiveFunction(n, depth = 0) {
  console.log(`Depth: ${depth}, n: ${n}`);
  if (depth > 100) {
    console.error("Approaching stack limit!");
    return;
  }
  if (n === 0) return;
  return recursiveFunction(n - 1, depth + 1);
}
```

### 4. Use Error Boundaries (React)

In React applications, use Error Boundaries to catch stack overflows:

```javascript
class ErrorBoundary extends React.Component {
  componentDidCatch(error, errorInfo) {
    if (error.message.includes("Maximum call stack")) {
      console.error("Stack overflow detected!");
      // Handle gracefully
    }
  }
  // ... rest of error boundary
}
```

## Common Interview Questions

### Q: What causes stack overflow in JavaScript?

**A:** Stack overflow occurs when:

1. Infinite recursion (no base case)
2. Very deep recursion (exceeds stack limit)
3. Mutual recursion (functions calling each other)
4. Deeply nested function calls

### Q: How do you prevent stack overflow?

**A:**

1. Use iteration instead of recursion
2. Implement proper base cases
3. Limit recursion depth
4. Use tail recursion (though not optimized in most engines)
5. Break up large operations into chunks

### Q: What's the difference between stack overflow and heap overflow?

**A:**

- **Stack Overflow**: Too many function calls (call stack exceeds limit)
- **Heap Overflow**: Too much memory allocated (heap memory exhausted)
- Stack overflow is about **depth** (function nesting)
- Heap overflow is about **size** (memory allocation)

### Q: Can you convert this recursive function to prevent stack overflow?

```javascript
function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}
```

**A:**

```javascript
// Iterative solution (safe)
function fibonacciIterative(n) {
  if (n <= 1) return n;
  let a = 0,
    b = 1;
  for (let i = 2; i <= n; i++) {
    [a, b] = [b, a + b];
  }
  return b;
}

// Memoized recursive (prevents redundant calls)
function fibonacciMemoized(n, memo = {}) {
  if (n in memo) return memo[n];
  if (n <= 1) return n;
  memo[n] = fibonacciMemoized(n - 1, memo) + fibonacciMemoized(n - 2, memo);
  return memo[n];
}
```

## Best Practices

1. **Prefer Iteration**: Use loops instead of recursion when possible
2. **Validate Input**: Check input size before recursive operations
3. **Set Limits**: Implement maximum depth limits for recursive functions
4. **Monitor Stack**: Use DevTools to monitor stack depth during development
5. **Test Edge Cases**: Test with large inputs to catch potential overflows
6. **Use Memoization**: Cache results to avoid redundant recursive calls
7. **Consider Web Workers**: Offload heavy recursive operations to workers

## Related Topics

- [02. Javascript Engine.md](./02.%20Javascript%20Engine.md) - Call Stack details
- [11. Common Pitfalls & Debugging.md](./11.%20Common%20Pitfalls%20%26%20Debugging.md) - Debugging techniques
- [10. Performance Optimization.md](./10.%20Performance%20Optimization.md) - Optimization strategies






