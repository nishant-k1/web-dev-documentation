# Performance Optimization

## Overview

Performance optimization in JavaScript Runtime Environment involves optimizing memory usage, event loop efficiency, garbage collection, and overall runtime performance. This guide consolidates best practices from across the JRE components.

## Memory Optimization

### 1. Reduce Object Creation

**Problem:** Creating many objects increases GC pressure and pauses.

```javascript
// ❌ Creates new object every iteration
for (let i = 0; i < 1000; i++) {
  process({ id: i, data: "test" });
}

// ✅ Reuse object
const obj = {};
for (let i = 0; i < 1000; i++) {
  obj.id = i;
  obj.data = "test";
  process(obj);
}
```

### 2. Use Object Pools

Reuse objects instead of creating new ones:

```javascript
class ObjectPool {
  constructor(createFn, resetFn) {
    this.createFn = createFn;
    this.resetFn = resetFn;
    this.pool = [];
  }

  acquire() {
    return this.pool.pop() || this.createFn();
  }

  release(obj) {
    this.resetFn(obj);
    this.pool.push(obj);
  }
}

// Usage
const pool = new ObjectPool(
  () => ({ x: 0, y: 0 }),
  (obj) => {
    obj.x = 0;
    obj.y = 0;
  }
);

const obj = pool.acquire();
// Use object
pool.release(obj);
```

### 3. Avoid Large Allocations

Break large operations into smaller chunks:

```javascript
// ❌ Large allocation
const hugeArray = new Array(1000000).fill(0);

// ✅ Process in chunks
function processInChunks(data, chunkSize = 1000) {
  for (let i = 0; i < data.length; i += chunkSize) {
    const chunk = data.slice(i, i + chunkSize);
    processChunk(chunk);
  }
}
```

### 4. Clean Up References

Explicitly nullify references when done:

```javascript
function processLargeData() {
  const largeData = fetchLargeData();
  processData(largeData);
  largeData = null; // Help GC by removing reference
}
```

### 5. Use WeakMap and WeakSet

For temporary associations that shouldn't prevent GC:

```javascript
// ✅ WeakMap - doesn't prevent GC of keys
const cache = new WeakMap();
function getCachedValue(obj) {
  if (!cache.has(obj)) {
    cache.set(obj, computeExpensiveValue(obj));
  }
  return cache.get(obj);
}

// When obj is GC'd, cache entry is automatically removed
```

### 6. Avoid Memory Leaks

**Common Leaks:**

- Global variables
- Uncleared event listeners
- Uncleared timers
- Detached DOM elements
- Circular references (though modern GC handles these)

```javascript
// ✅ Clean up event listeners
const button = document.getElementById("button");
const handler = () => console.log("clicked");
button.addEventListener("click", handler);

// Later, when done:
button.removeEventListener("click", handler);
button = null;

// ✅ Clear timers
const timer = setInterval(() => {}, 1000);
// Later:
clearInterval(timer);
```

## Event Loop Optimization

### 1. Keep Tasks Small and Fast

Break long-running operations into smaller chunks:

```javascript
// ❌ Long-running task blocks event loop
function processLargeDataset(data) {
  for (let item of data) {
    expensiveOperation(item); // Blocks for seconds
  }
}

// ✅ Break into chunks using setTimeout
function processLargeDatasetAsync(data) {
  let index = 0;
  function processChunk() {
    const chunkSize = 100;
    const end = Math.min(index + chunkSize, data.length);

    for (let i = index; i < end; i++) {
      expensiveOperation(data[i]);
    }

    index = end;
    if (index < data.length) {
      setTimeout(processChunk, 0); // Yield to event loop
    }
  }
  processChunk();
}
```

### 2. Use requestAnimationFrame for UI Updates

For smooth animations and UI updates:

```javascript
// ✅ Smooth animation
function animate() {
  updateUI();
  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);

// ❌ Using setTimeout for animations
function animate() {
  updateUI();
  setTimeout(animate, 16); // Less smooth
}
```

### 3. Avoid Microtask Starvation

Prevent infinite microtask loops:

```javascript
// ❌ Infinite microtasks block macrotasks
function infiniteMicrotasks() {
  Promise.resolve().then(infiniteMicrotasks);
}
infiniteMicrotasks(); // Blocks rendering!

// ✅ Limit microtask chains
function limitedMicrotasks(count = 0) {
  if (count > 100) return; // Limit
  Promise.resolve().then(() => {
    limitedMicrotasks(count + 1);
  });
}
```

### 4. Use Web Workers for Heavy Computation

Offload CPU-intensive work to workers:

```javascript
// Main thread
const worker = new Worker("worker.js");
worker.postMessage({ data: largeDataset });
worker.onmessage = (e) => {
  console.log("Result:", e.data);
};

// worker.js
self.onmessage = (e) => {
  const result = expensiveComputation(e.data.data);
  self.postMessage(result);
};
```

### 5. Debounce and Throttle

Limit function execution frequency:

```javascript
// Debounce - execute after delay
function debounce(func, delay) {
  let timeoutId;
  return function (...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => func.apply(this, args), delay);
  };
}

// Throttle - execute at most once per interval
function throttle(func, interval) {
  let lastCall = 0;
  return function (...args) {
    const now = Date.now();
    if (now - lastCall >= interval) {
      lastCall = now;
      return func.apply(this, args);
    }
  };
}

// Usage
const debouncedSearch = debounce(searchFunction, 300);
const throttledScroll = throttle(handleScroll, 100);
```

## Garbage Collection Optimization

### 1. Minimize GC Pressure

Reduce object creation and allocation:

```javascript
// ✅ Pre-allocate arrays
const results = new Array(1000); // Pre-allocated
for (let i = 0; i < 1000; i++) {
  results[i] = compute(i);
}

// ❌ Growing array
const results = [];
for (let i = 0; i < 1000; i++) {
  results.push(compute(i)); // Multiple reallocations
}
```

### 2. Use Typed Arrays for Numeric Data

More memory-efficient for numeric operations:

```javascript
// ✅ Typed array (more efficient)
const numbers = new Float64Array(1000);

// ❌ Regular array (less efficient for numbers)
const numbers = new Array(1000);
```

### 3. Batch Operations

Group operations to reduce GC frequency:

```javascript
// ❌ Multiple small allocations
for (let i = 0; i < 1000; i++) {
  createObject(i); // 1000 allocations
}

// ✅ Batch allocation
const objects = Array.from({ length: 1000 }, (_, i) => createObject(i));
```

## Call Stack Optimization

### 1. Avoid Deep Recursion

Use iteration instead:

```javascript
// ❌ Deep recursion
function factorial(n) {
  if (n === 0) return 1;
  return n * factorial(n - 1);
}

// ✅ Iteration
function factorialIterative(n) {
  let result = 1;
  for (let i = 1; i <= n; i++) {
    result *= i;
  }
  return result;
}
```

### 2. Use Tail Recursion (When Supported)

Some engines optimize tail calls:

```javascript
// Tail-recursive (can be optimized)
function sumTail(n, acc = 0) {
  if (n === 0) return acc;
  return sumTail(n - 1, acc + n);
}
```

## Profiling and Measurement

### 1. Use Performance API

Measure execution time:

```javascript
// Mark start
performance.mark("operation-start");

// Your operation
expensiveOperation();

// Mark end and measure
performance.mark("operation-end");
performance.measure("operation", "operation-start", "operation-end");

// Get measurement
const measure = performance.getEntriesByName("operation")[0];
console.log(`Duration: ${measure.duration}ms`);
```

### 2. Monitor Memory Usage

```javascript
// Check memory usage (if available)
if (performance.memory) {
  console.log({
    used: performance.memory.usedJSHeapSize,
    total: performance.memory.totalJSHeapSize,
    limit: performance.memory.jsHeapSizeLimit,
  });
}
```

### 3. Use Chrome DevTools

- **Performance Tab**: Record and analyze performance
- **Memory Tab**: Take heap snapshots
- **Coverage Tab**: Find unused code
- **Lighthouse**: Performance audits

## Best Practices Summary

### Memory

- ✅ Minimize object creation
- ✅ Use object pools for frequently created objects
- ✅ Clean up references (event listeners, timers)
- ✅ Use WeakMap/WeakSet for temporary associations
- ✅ Avoid global variables
- ✅ Process large data in chunks

### Event Loop

- ✅ Keep tasks small (< 50ms)
- ✅ Use requestAnimationFrame for UI updates
- ✅ Offload heavy work to Web Workers
- ✅ Debounce/throttle frequent operations
- ✅ Avoid microtask starvation

### Garbage Collection

- ✅ Reduce allocations
- ✅ Reuse objects
- ✅ Batch operations
- ✅ Use typed arrays for numeric data

### Call Stack

- ✅ Prefer iteration over recursion
- ✅ Limit recursion depth
- ✅ Use explicit stacks for complex algorithms

## Common Interview Questions

### Q: How do you optimize JavaScript performance?

**A:** Focus on:

1. **Memory**: Reduce allocations, reuse objects, clean up references
2. **Event Loop**: Keep tasks small, use workers for heavy work
3. **GC**: Minimize pressure, batch operations
4. **Profiling**: Measure first, optimize bottlenecks

### Q: What causes performance issues in JavaScript?

**A:**

- Long-running tasks blocking event loop
- Memory leaks causing GC pressure
- Excessive object creation
- Deep recursion causing stack issues
- Synchronous operations blocking UI

### Q: How do you handle long-running operations?

**A:**

1. Break into chunks with `setTimeout` or `requestIdleCallback`
2. Use Web Workers for CPU-intensive work
3. Use `requestAnimationFrame` for UI updates
4. Debounce/throttle frequent operations

### Q: What's the difference between debounce and throttle?

**A:**

- **Debounce**: Execute after delay when calls stop (e.g., search input)
- **Throttle**: Execute at most once per interval (e.g., scroll handler)

## Related Topics

- [07. Event Loop.md](./07.%20Event%20Loop.md) - Event loop details
- [09. Garbage Collection.md](./09.%20Garbage%20Collection.md) - GC optimization
- [06. Memory Leaks.md](./06.%20Memory%20Leaks.md) - Memory leak prevention
- [12. Memory Profiling Guide.md](./12.%20Memory%20Profiling%20Guide.md) - Profiling techniques






