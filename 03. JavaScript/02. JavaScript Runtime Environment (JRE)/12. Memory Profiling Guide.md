# Memory Profiling Guide

## Overview

Memory profiling is essential for identifying memory leaks, optimizing memory usage, and understanding how your application uses memory. This guide provides comprehensive techniques for profiling memory in JavaScript applications.

## Why Profile Memory?

1. **Identify Memory Leaks**: Find objects that aren't being garbage collected
2. **Optimize Performance**: Reduce GC pressure and pauses
3. **Understand Usage**: See how memory is allocated and used
4. **Debug Issues**: Find memory-related bugs
5. **Plan Capacity**: Understand memory requirements

## Chrome DevTools - Memory Tab

### 1. Heap Snapshot

**Purpose:** Take a snapshot of the heap at a specific point in time.

**Steps:**

1. Open DevTools (F12)
2. Go to **Memory** tab
3. Select **Heap snapshot**
4. Click **Take snapshot** (or record button)
5. Wait for snapshot to complete
6. Analyze the results

**What You See:**

- **Constructor**: Type of object (Array, Object, Function, etc.)
- **Distance**: Distance from root (GC roots)
- **Objects Count**: Number of objects of this type
- **Shallow Size**: Size of objects themselves
- **Retained Size**: Size including referenced objects

**Analyzing Snapshots:**

**Find Memory Leaks:**

1. Take snapshot before action
2. Perform action (that might cause leak)
3. Take snapshot after action
4. Compare snapshots
5. Look for:
   - Growing object counts
   - Objects that should be GC'd
   - Unexpected retained sizes

**Example:**

```javascript
// Before snapshot
let data = [];

// Action
for (let i = 0; i < 1000; i++) {
  data.push({ id: i, value: new Array(1000) });
}

// After snapshot - compare to see if data is retained
```

**Key Metrics:**

- **Retained Size**: Most important - total memory that would be freed if object is deleted
- **Shallow Size**: Size of object itself
- **Distance**: How many references away from root

### 2. Allocation Timeline

**Purpose:** See memory allocation over time.

**Steps:**

1. Select **Allocation timeline**
2. Click **Start** (record button)
3. Perform actions in your app
4. Click **Stop**
5. Analyze the timeline

**What You See:**

- **Timeline**: Memory allocation over time
- **Bars**: Memory allocations at specific times
- **Colors**: Different object types
- **Height**: Amount of memory allocated

**Analyzing Timeline:**

**Find Memory Leaks:**

- Look for steadily growing memory
- Memory that doesn't drop after actions
- Unexpected spikes

**Find Allocation Patterns:**

- When memory is allocated
- What triggers allocations
- Allocation frequency

**Example Analysis:**

```
Time 0s: 10MB baseline
Time 5s: 50MB (user action)
Time 10s: 50MB (should drop but doesn't - leak!)
Time 15s: 60MB (growing - leak confirmed)
```

### 3. Allocation Sampling

**Purpose:** Profile memory allocation with minimal overhead.

**Steps:**

1. Select **Allocation sampling**
2. Click **Start**
3. Use your application
4. Click **Stop**
5. Analyze allocation profile

**What You See:**

- **Allocation sites**: Where memory is allocated
- **Stack traces**: Call stack when allocation occurred
- **Size**: Amount allocated at each site

**Use Cases:**

- Find where most memory is allocated
- Identify allocation hotspots
- Optimize frequent allocations

## Memory Profiling Techniques

### 1. Comparing Snapshots

**Technique:** Take multiple snapshots and compare.

**Steps:**

1. Take **Snapshot 1** (baseline)
2. Perform action
3. Take **Snapshot 2**
4. Select **Snapshot 2** → **Comparison** → **Snapshot 1**
5. Analyze differences

**What to Look For:**

- **# New**: New objects created
- **# Deleted**: Objects deleted (good!)
- **# Delta**: Net change
- **Size Delta**: Memory change

**Example:**

```
Constructor    | # New | # Deleted | # Delta | Size Delta
Array          | 1000  | 0         | +1000   | +4MB
Object         | 500   | 200       | +300    | +600KB
Function       | 10    | 0         | +10     | +50KB
```

**Red Flags:**

- Many new objects, few deleted
- Large size delta
- Objects that should be deleted but aren't

### 2. Finding Detached DOM Nodes

**Problem:** DOM nodes removed from DOM but still referenced in JavaScript.

**Steps:**

1. Take heap snapshot
2. Search for "Detached" in filter
3. Look for detached nodes
4. Check what's retaining them

**Example:**

```javascript
// Creates detached node
const div = document.createElement("div");
div.innerHTML = "Content";
// div is removed from DOM but still referenced
const reference = div; // Keeps it in memory
```

**Solution:**

```javascript
// Remove reference
reference = null;
// Now div can be GC'd
```

### 3. Identifying Retainers

**Purpose:** Find what's keeping objects in memory.

**Steps:**

1. Select object in heap snapshot
2. Look at **Retainers** panel (bottom)
3. See chain of references keeping object alive

**Example:**

```
Object (retained)
  └─ Array (retainer)
      └─ Function (retainer)
          └─ Window (root)
```

**Use Cases:**

- Find why objects aren't GC'd
- Identify unexpected references
- Debug memory leaks

### 4. Memory Timeline Analysis

**Technique:** Monitor memory over time.

**Steps:**

1. Use Allocation Timeline
2. Record for extended period
3. Perform various actions
4. Analyze patterns

**What to Look For:**

- **Steady Growth**: Memory leak
- **Sawtooth Pattern**: Normal (GC working)
- **Spikes**: Large allocations
- **Plateaus**: Memory not being freed

**Normal Pattern:**

```
Memory
  ↑
  |     /\
  |    /  \/\
  |   /      \/\
  |  /          \/\
  |_/______________\__> Time
```

**Leak Pattern:**

```
Memory
  ↑
  |    /
  |   /
  |  /
  | /
  |/________________> Time
```

## Performance API

### Memory Usage

```javascript
// Check memory usage (if available)
if (performance.memory) {
  const memory = performance.memory;
  console.log({
    used: (memory.usedJSHeapSize / 1048576).toFixed(2) + " MB",
    total: (memory.totalJSHeapSize / 1048576).toFixed(2) + " MB",
    limit: (memory.jsHeapSizeLimit / 1048576).toFixed(2) + " MB",
  });
}
```

### Memory Monitoring

```javascript
// Monitor memory over time
function monitorMemory() {
  if (performance.memory) {
    const used = performance.memory.usedJSHeapSize;
    const limit = performance.memory.jsHeapSizeLimit;
    const percentage = ((used / limit) * 100).toFixed(2);

    console.log(`Memory: ${percentage}% used`);

    if (percentage > 90) {
      console.warn("Memory usage critical!");
    }
  }
}

setInterval(monitorMemory, 5000);
```

## Node.js Memory Profiling

### Using --inspect

```bash
node --inspect script.js
# Opens Chrome DevTools for Node.js
# Use Memory tab as in browser
```

### Using --expose-gc

```bash
node --expose-gc script.js
```

```javascript
// Manual GC trigger (for testing)
if (global.gc) {
  global.gc();
  console.log("GC triggered");
}
```

### Using v8 Module

```javascript
const v8 = require("v8");

// Get heap statistics
const heapStats = v8.getHeapStatistics();
console.log({
  totalHeapSize: (heapStats.total_heap_size / 1048576).toFixed(2) + " MB",
  usedHeapSize: (heapStats.used_heap_size / 1048576).toFixed(2) + " MB",
  heapSizeLimit: (heapStats.heap_size_limit / 1048576).toFixed(2) + " MB",
});

// Get heap space statistics
const heapSpaceStats = v8.getHeapSpaceStatistics();
heapSpaceStats.forEach((space) => {
  console.log(
    `${space.space_name}: ${(space.space_used_size / 1048576).toFixed(2)} MB`
  );
});
```

### Using heapdump

```bash
npm install heapdump
```

```javascript
const heapdump = require("heapdump");

// Take heap dump
heapdump.writeSnapshot((err, filename) => {
  if (err) console.error(err);
  else console.log("Heap dump written to", filename);
});

// Can be analyzed in Chrome DevTools
```

## Common Memory Issues

### 1. Memory Leaks

**Symptoms:**

- Memory grows steadily
- Objects not being GC'd
- Performance degrades over time

**Debugging:**

1. Take heap snapshots over time
2. Compare snapshots
3. Find growing objects
4. Check retainers
5. Remove references

### 2. Excessive Allocations

**Symptoms:**

- Frequent GC pauses
- High memory churn
- Performance issues

**Debugging:**

1. Use Allocation Timeline
2. Find allocation hotspots
3. Reduce object creation
4. Reuse objects
5. Use object pools

### 3. Large Objects

**Symptoms:**

- Large retained sizes
- Slow GC
- High memory usage

**Debugging:**

1. Check heap snapshot for large objects
2. Find what's creating them
3. Break into smaller chunks
4. Process incrementally

## Best Practices

1. **Profile Regularly**: Don't wait for issues
2. **Take Baselines**: Know normal memory usage
3. **Compare Snapshots**: Find what's growing
4. **Monitor Over Time**: See patterns
5. **Test Real Scenarios**: Profile actual usage
6. **Clean Up**: Remove references when done
7. **Use Tools**: Leverage DevTools effectively

## Common Interview Questions

### Q: How do you profile memory in JavaScript?

**A:**

1. **Chrome DevTools Memory Tab**:

   - Heap Snapshot: Point-in-time analysis
   - Allocation Timeline: Memory over time
   - Allocation Sampling: Allocation hotspots

2. **Performance API**: Check `performance.memory`

3. **Node.js**: Use `--inspect`, `v8` module, or `heapdump`

### Q: How do you identify a memory leak?

**A:**

1. Take heap snapshots before/after actions
2. Compare snapshots - look for growing objects
3. Use allocation timeline - check for steady growth
4. Find retainers - see what's keeping objects alive
5. Look for detached DOM nodes
6. Monitor memory over extended period

### Q: What's the difference between shallow size and retained size?

**A:**

- **Shallow Size**: Size of the object itself
- **Retained Size**: Total memory that would be freed if object is deleted (includes all referenced objects)

Retained size is more important for memory optimization.

### Q: How do you debug memory issues in production?

**A:**

1. Use Performance API to monitor memory
2. Log memory usage periodically
3. Set up alerts for high memory usage
4. Use heapdump in Node.js to capture snapshots
5. Analyze snapshots offline in DevTools
6. Use APM tools for production monitoring

## Related Topics

- [06. Memory Leaks.md](./06.%20Memory%20Leaks.md) - Memory leak prevention
- [09. Garbage Collection.md](./09.%20Garbage%20Collection.md) - GC details
- [11. Common Pitfalls & Debugging.md](./11.%20Common%20Pitfalls%20%26%20Debugging.md) - Debugging techniques
- [10. Performance Optimization.md](./10.%20Performance%20Optimization.md) - Optimization strategies

