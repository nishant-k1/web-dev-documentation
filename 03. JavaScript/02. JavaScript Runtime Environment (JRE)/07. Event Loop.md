# Event Loop

## What is the Event Loop?

The **Event Loop** is the core mechanism that enables JavaScript's asynchronous, non-blocking behavior despite being single-threaded. It continuously monitors the call stack and task queues, coordinating the execution of synchronous and asynchronous code.

## How the Event Loop Works

The event loop follows a specific sequence to manage code execution:

### Basic Algorithm:

1. **Check the Call Stack**

   - If the call stack has functions, execute them (LIFO order)
   - Wait until the call stack is completely empty

2. **Process Microtask Queue** (High Priority)

   - When the call stack is empty, check the microtask queue
   - Execute **ALL** microtasks one by one until the queue is empty
   - After each microtask, check if new microtasks were added
   - Continue until no microtasks remain

3. **Process Macrotask Queue** (Low Priority)

   - Take **ONE** macrotask from the queue
   - Push it to the call stack and execute it
   - Return to step 1

4. **Repeat**
   - This cycle continues indefinitely as long as there are tasks to process

## Detailed Execution Flow

```
┌───────────────────────────┐
│   Start Event Loop        │
└───────────┬───────────────┘
            │
            ▼
    ┌───────────────┐
    │  Call Stack   │ ◄── Execute synchronous code
    │    Empty?     │
    └───────┬───────┘
            │ Yes
            ▼
    ┌─────────────────────┐
    │ Microtask Queue     │ ◄── Process ALL microtasks
    │ Has tasks?          │
    └─────────┬───────────┘
              │ All done
              ▼
    ┌─────────────────────┐
    │ Macrotask Queue     │ ◄── Process ONE macrotask
    │ Has tasks?          │
    └─────────┬───────────┘
              │
              ▼
         (Repeat)
```

## Example: Understanding Execution Order

```javascript
console.log("1"); // Synchronous - Call Stack

setTimeout(() => {
  console.log("2"); // Macrotask
}, 0);

Promise.resolve().then(() => {
  console.log("3"); // Microtask
});

console.log("4"); // Synchronous - Call Stack

// Output: 1, 4, 3, 2
```

### Execution Breakdown:

1. `console.log('1')` → Call Stack → Prints `1`
2. `setTimeout` → Sent to Web API → Callback queued in **Macrotask Queue**
3. `Promise.resolve().then()` → Callback queued in **Microtask Queue**
4. `console.log('4')` → Call Stack → Prints `4`
5. Call Stack is empty → Event Loop checks **Microtask Queue**
6. `console.log('3')` → Prints `3`
7. Microtask Queue empty → Event Loop checks **Macrotask Queue**
8. `console.log('2')` → Prints `2`

## Complex Example

```javascript
console.log("Start");

setTimeout(() => {
  console.log("Timeout 1");
}, 0);

Promise.resolve()
  .then(() => {
    console.log("Promise 1");
    return Promise.resolve();
  })
  .then(() => {
    console.log("Promise 2");
  });

setTimeout(() => {
  console.log("Timeout 2");
}, 0);

console.log("End");

// Output: Start, End, Promise 1, Promise 2, Timeout 1, Timeout 2
```

### Why This Order?

1. **Synchronous code first**: `Start`, `End`
2. **All microtasks**: `Promise 1`, `Promise 2` (even chained promises are processed before any macrotask)
3. **Macrotasks one by one**: `Timeout 1`, `Timeout 2`

## Key Characteristics

### 1. Single Job

- The event loop has **one job**: monitor the call stack and task queues
- It ensures tasks execute in the correct order

### 2. Non-blocking

- Asynchronous operations don't block the main thread
- Long-running tasks are offloaded to Web APIs or libuv

### 3. Microtask Priority

- **ALL** microtasks are processed before **ANY** macrotask
- This ensures promise resolutions happen quickly

### 4. Continuous Operation

- The event loop runs continuously as long as the program is running
- It never "sleeps" - always checking for work

## Microtasks vs Macrotasks (queues)

- **Microtasks** = high priority; **all** run before any macrotask. Sources: `Promise.then/catch/finally`, `async/await` continuation, `queueMicrotask`, `MutationObserver`/`IntersectionObserver`/`ResizeObserver`, `process.nextTick` (Node, even higher than microtasks). So both EcmaScript tasks (promise callbacks) and webAPIs like MutationObserver gets executed inside the Microtask.

- **Macrotasks** = lower priority; **one** per loop turn. Sources: `setTimeout/setInterval`, I/O, user events, `setImmediate` (Node), `requestAnimationFrame`, `requestIdleCallback`, `postMessage/MessageChannel`, workers/messages, WebSocket/SSE.

- Both queues are FIFO; event loop flow: empty stack → run **all** microtasks → run **one** macrotask → repeat.

### Quick example

```js
setTimeout(() => console.log("macro"), 0);
Promise.resolve().then(() => console.log("micro"));
// Output: micro, macro
```

### Pitfalls

- Microtask starvation: unbounded promise chains/recursive microtasks can prevent macrotasks/rendering.
- Long macrotasks block UI; break work into chunks or offload to workers.
- `setTimeout(fn, 0)` is never immediate—waits for stack + all microtasks.

## Event Loop in Different Environments

### Browser

- Works with Web APIs (setTimeout, fetch, DOM events)
- Coordinates with the rendering engine
- Manages UI updates and user interactions

### Node.js

- Works with libuv for I/O operations
- Different phases for different types of operations
- Includes additional queues (setImmediate, process.nextTick)

## Common Misconceptions

### ❌ "setTimeout with 0ms runs immediately"

**False**: It queues the callback in the macrotask queue, which runs after all current synchronous code and all microtasks.

### ❌ "Promises run synchronously"

**Partial**: The promise executor runs synchronously, but `.then()` callbacks are microtasks.

### ❌ "Event loop runs the code"

**False**: The JavaScript engine (call stack) runs the code. The event loop only **coordinates** when code should run.

## Performance Implications

### Microtask Starvation

If microtasks keep creating new microtasks, macrotasks will never execute:

```javascript
function infiniteMicrotasks() {
  Promise.resolve().then(infiniteMicrotasks);
}
infiniteMicrotasks(); // This will block macrotasks forever!
```

### Best Practices

- Keep individual tasks small and fast
- Avoid creating infinite microtask loops
- Use `requestAnimationFrame` for UI updates
- Break up long computations with `setTimeout` or Web Workers

## Debugging the Event Loop

### Browser DevTools

- Use the Performance tab to visualize task execution
- Check the call stack in the Sources tab
- Monitor long tasks that block the main thread

### Node.js

- Use `node --inspect` for debugging
- Check event loop lag with monitoring tools
- Use `perf_hooks` to measure performance

## Related Topics

- [02. Javascript Engine.md](./02.%20Javascript%20Engine.md) - Engine internals including Call Stack
- [01. JavaScript Runtime Environment.md](./01.%20JavaScript%20Runtime%20Environment.md) - Runtime Environment overview
- [14. Async Operations.md](./14.%20Async%20Operations.md) - Asynchronous operations

## Microtasks in the browser environment:

1. Promise callbacks (e.g., .then() and .catch() functions)
2. MutationObserver callbacks (when the DOM changes are observed)
3. IntersectionObserver callbacks (when elements intersect with a viewport)

## Macrotasks in the browser environment:

1. setTimeout and setInterval callbacks
2. Event callbacks (such as click, input, and other user interactions)
3. XMLHttpRequest callbacks (old-school AJAX requests)

“Certain DOM events, not all DOM events. What are those certain DOM events?”

Sure, let me clarify that. So most DOM events, like user interactions—clicks, keyboard events, things like that—do indeed go into the macrotask queue.

When I mentioned "certain DOM events," I just meant that all the typical user-driven DOM events—like clicks or input events—are macrotasks. It's really the user interaction events and timers that form the bulk of what we call macrotasks. So in short, all the common DOM events you deal with, like clicks and scrolls, are going to be macrotasks.
