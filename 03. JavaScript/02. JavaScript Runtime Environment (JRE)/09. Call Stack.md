# Call Stack

1. **Definition**

   - The call stack is the mechanism to manage call stacks.
   - The call stack is a stack data structure that stores `Execution Contexts`.
   - Each item in the stack is called an `Execution Context`, representing a function's execution.
   - On the bottom is always the `GEC` (Global Execution Context), followed by `FEC`, (Function Exectuon Contexts) as functions gets invocated.
   - The most recent `FEC`, is always on the top.
   - function calls themselves (the code) aren't stored in the stack or heap. The call stack stores the execution contexts created when a function is called.

2. **Role**

   - It stores the information about the active function calls in a program.
   - It tracks the order of function calls and their respective contexts.

3. **Process**

   - When a function is called, a stack frame (or Execution Context) for that function is pushed onto the call stack.

   - The stack frame contains information like the function's arguments, local variables, and the location (file name and line number) of the function call.

   - As functions are executed, the call stack grows with each new function call. When a function completes, its corresponding stack frame is popped off the stack, allowing the program to return to the previous `Execution Context`.

   - The call stack operates on a Last In, First Out (LIFO) basis, meaning the last `Execution Context` added is the first one to be removed.

   - Every time a function is called, a "stack frame" (or execution context) is pushed onto the call stack. This frame contains important details about that function, such as its `local variables`, the `arguments passed` to it, and `reference to the calling function` where it was called from.

   - The stack itself stores primitive data types (like numbers, strings, booleans, etc.) by value.

   - The "quick access" refers to how the call stack lets JavaScript quickly find the context of the function that's currently executing. Since it's a stack, JavaScript always knows where the most recent function call (the "top" of the stack) is.

   - As the call stack operates on a Last In, First Out (LIFO) basis, the most recent function is at the top, so it can be quickly accessed for execution or when it's time to pop it off the stack after it finishes.

   - `Call history` means the stack keeps track of all previous function calls, letting the program return to the previous function context when the current function finishes.

   - The stack memory is managed automatically by the JavaScript engine's execution context mechanism and doesn't need garbage collection.

4. **Call Stack Overflow**

   - A call stack overflow occurs when there are too many nested function calls, causing the stack to exceed its limit
   - **Recursion:** If a function keeps calling itself indefinitely without a base case to stop, the stack will keep growing until it overflows.
   - The browser prevents crashes by throwing an error: "Maximum call stack size exceeded"

   ```javascript
   function overflow() {
     overflow(); // Infinite recursion
   }
   overflow(); // Error: Maximum call stack size exceeded
   ```

5. **Call Stack and Asynchronous Code**

   - JavaScript is single-threaded, but asynchronous code (like setTimeout, Promises, or AJAX calls) doesn't block the call stack. The asynchronous functions are placed in the Event Queue, and once the call stack is empty, the event loop picks them up and moves them onto the stack for execution.

   - This behavior makes JavaScript non-blocking, allowing asynchronous tasks to run while other code is being executed, giving the appearance of parallelism.

6. **Characteristics**:

   - **Fast access**: Allows quick access to the current function's context and its call history.
   - **Limited size**: Has a maximum size, leading to a "stack overflow" error if the call history is too deep, often due to improperly terminated recursive functions.

   Eg:

   ```Javascript
   function func1() {
     console.log("Inside func1");
     func2();
   }

   function func2() {
     console.log("Inside func2");
     func3();
   }

   function func3() {
     console.log("Inside func3");
   }

   func1();
   ```

## Synchronous Nature of the Call Stack

1. Javascript is single threader i.e. it has only one call stack.

1. Only one set of instruction is executed at a time. It's not doing multiple things.

1. The best way to check that a language is single threaded is if it has only one call stack.

1. One call stack allows us to run code one at time. We're never running functions in parallel.

1. The stack keeps growing as we push new functions on the stack and then we pop them one at time.

1. Functions gets invoked in LIFO manner.

1. When the function is invoked it gets popped/removed from the call stack.

1. Becuase of single threaded javascript is synchronous i.e. one at a time in order. It appears that only one thing can happen at the time.

## Call Stack and Asynchronous Code

While JavaScript is single-threaded, it handles asynchronous code using the Event Loop, which works alongside the call stack. Here's an example:

````JavaScript
console.log("Start");

setTimeout(() => {
    console.log("Timeout");
}, 1000);

console.log("End");

// Output
// Start
// End
// Timeout
```

Call Stack Execution:
   1. console.log("Start") → Prints "Start".
   2. setTimeout() → Sends the callback to the Web API and immediately returns.
   3. console.log("End") → Prints "End".
   4. After 1000ms, the callback from the Web API is sent to the Message Queue.
   5. The Event Loop pushes the callback onto the stack when it is empty → Prints "Timeout".

---

## FAQs

1. **If stack stores only primitves and non primitives are stored in heap then how stack is storing active function calls?**

- The stack itself stores primitive data types (like numbers, strings, booleans, etc.) by value. However, when it comes to non-primitive data types (such as objects, arrays, functions, etc.), these are typically stored in the heap.

- Primitives: Directly in the stack.
- Non-primitives including Functions: Reference in the stack, but the actual object or array is in the heap
- The function definition itself is not directly stored in the execution context, only its reference is.

1. Primitive Data Types:

   - Primitives like numbers, strings, booleans, undefined, null, and symbols are stored by value on the stack.
   - This means that the actual value is directly placed in the stack frame for each function.

2. Non-Primitive Data Types:

   - Non-primitives like objects, arrays, and functions are stored in the heap.
   - What the stack stores in the execution context is a reference (a pointer) to the memory location in the heap where the actual object or array is stored. The stack frame holds this reference, and not the object itself.
   - In the below example:

     - num (a primitive) is stored directly in the stack.
     - person (an object) is stored as a reference in the stack, which points to the actual object in the heap.

     ```JavaScript
       function example() {
         let num = 10;               // Primitive (stored on the stack)
         let person = { name: "John" };  // Object (reference stored on the stack, actual object in heap)

         console.log(num);
         console.log(person.name);
       }
     ```

## Stackoverflow

- In JavaScript, a "stack overflow" occurs when the call stack exceeds its maximum size due to too many function calls being nested one inside another without returning. This situation usually leads to a runtime error.

- The call stack is a data structure used by the JavaScript engine to keep track of the sequence of active function calls during program execution.
- When a function is called, a new frame (also known as an activation record or stack frame) is added to the top of the call stack.

- If we keep calling function nested inside of each other it will cause stackoverflow because same function gets pushed on top of stack frame over and over again until browser crashes.

- To prevent the browser from crashing the browser gives an error after certain limit of function execution gets crossed. The error is maximum call size exceeded.

```javascript
function inception() {
  inception();
}
inception(); // returns Maximum call stack Size exceeded error.
````

## Call Stack and Execution Context

The Call Stack works closely with the Execution Context:

- Execution Context contains all the information needed to execute a function (variables, this binding, etc.).
- When a function is called, its execution context is created and pushed onto the call stack.
- The top of the stack is always the currently executing function.

## Call Stack Debugging

1. **Browser DevTools**:

   - Use the Sources tab to debug and view the call stack in real-time.
   - Set breakpoints to pause execution and examine the stack.

2. **Stack Traces**:
   When an error occurs, JavaScript provides a stack trace to help debug:

   ![alt text](image.png)
