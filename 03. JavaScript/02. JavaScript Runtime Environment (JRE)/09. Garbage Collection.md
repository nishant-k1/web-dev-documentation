# Garbage Collection

## What is Garbage Collection?

**Garbage Collection (GC)** is an automatic memory management mechanism in JavaScript that identifies and frees up memory that is no longer in use. It prevents memory leaks and ensures efficient memory usage in the heap.

## Key Concepts

- **Garbage Collection works on the heap**, not the stack
- Stack memory is managed automatically by the execution context mechanism
- Objects in the heap are garbage collected when they become **unreachable**
- GC runs automatically in the background
- GC can cause **performance pauses** (stop-the-world events)

## When Does Garbage Collection Run?

Garbage collection runs automatically when:

1. **Memory threshold reached**: When heap memory usage exceeds a certain threshold
2. **Periodic intervals**: At regular intervals to prevent memory buildup
3. **Idle time**: During idle periods when the JavaScript engine has free time
4. **Manual trigger**: Can be forced in some environments (not recommended)

**Note:** You cannot directly control when GC runs, but you can influence what gets collected.

## Garbage Collection Algorithms

### 1. Mark-and-Sweep Algorithm (Most Common)

The standard algorithm used by most JavaScript engines:

**Process:**

1. **Mark Phase**:

   - Start from **root objects** (global variables, currently executing functions)
   - Mark all objects reachable from roots
   - Recursively mark all objects referenced by marked objects

2. **Sweep Phase**:
   - Scan through all objects in the heap
   - Free memory for unmarked objects
   - Unmark all marked objects for next cycle

**Example:**

```javascript
let obj1 = { name: "John" }; // Root reference
let obj2 = { name: "Jane" };
obj1.ref = obj2; // obj2 is reachable via obj1

obj1 = null; // obj1 is no longer reachable
// obj2 is also unreachable now (only referenced by unreachable obj1)
// Both will be garbage collected
```

**Advantages:**

- Handles circular references correctly
- Simple to implement
- Effective for most cases

**Disadvantages:**

- Can cause **stop-the-world** pauses
- May fragment memory

### 2. Generational Garbage Collection

Modern engines (like V8) use generational GC:

**Concept:**

- Objects are divided into **generations** (young and old)
- Most objects die young (short-lived)
- Long-lived objects are promoted to old generation

**Process:**

1. **Young Generation (Nursery)**:

   - New objects allocated here
   - Frequent, fast collections
   - Uses **Scavenge algorithm** (copying collector)

2. **Old Generation**:
   - Objects that survive multiple young GC cycles
   - Less frequent, slower collections
   - Uses **Mark-and-Sweep** or **Mark-and-Compact**

**Benefits:**

- Faster overall performance
- Reduces pause times
- Optimized for typical object lifetimes

### 3. Incremental Garbage Collection

**Concept:**

- Breaks GC work into small chunks
- Interleaves GC with JavaScript execution
- Reduces pause times

**Process:**

- GC runs in small increments
- JavaScript execution continues between increments
- Longer total GC time, but shorter individual pauses

### 4. Mark-and-Compact

**Process:**

1. Mark reachable objects (same as mark-and-sweep)
2. Compact: Move all marked objects together
3. Update references to moved objects

**Benefits:**

- Reduces memory fragmentation
- Better memory locality
- More expensive than mark-and-sweep

## What Gets Garbage Collected?

### ✅ Objects That Are Collected

1. **Unreachable Objects**:

   ```javascript
   let obj = { data: "test" };
   obj = null; // Object becomes unreachable → GC'd
   ```

2. **Circular References (if both unreachable)**:

   ```javascript
   let objA = { ref: null };
   let objB = { ref: null };
   objA.ref = objB;
   objB.ref = objA;

   objA = null;
   objB = null; // Both GC'd (mark-and-sweep handles this)
   ```

3. **Closures with No External References**:
   ```javascript
   function outer() {
     let data = "secret";
     return function inner() {
       console.log(data);
     };
   }
   let fn = outer();
   fn = null; // Closure GC'd if no other references
   ```

### ❌ Objects That Are NOT Collected

1. **Reachable Objects**:

   ```javascript
   let obj = { data: "test" };
   // obj is still referenced → NOT GC'd
   ```

2. **Global Variables**:

   ```javascript
   window.myGlobal = { data: "test" };
   // Global variables persist for program lifetime
   ```

3. **Active Event Listeners**:

   ```javascript
   button.addEventListener("click", handler);
   // Handler keeps references alive → NOT GC'd
   ```

4. **Active Timers**:
   ```javascript
   let timer = setInterval(() => {}, 1000);
   // Timer keeps callback in memory → NOT GC'd
   ```

## Performance Impact

### GC Pauses

Garbage collection can cause **stop-the-world** pauses:

- **Young Generation GC**: Usually < 10ms (fast)
- **Old Generation GC**: Can be 50-100ms+ (slower)
- **Full GC**: Can be 100ms+ (slowest)

**Impact:**

- UI freezes during pauses
- Audio/video stuttering
- Input lag
- Frame drops in animations

### Optimization Strategies

1. **Reduce Object Creation**:

   ```javascript
   // ❌ Creates new object every iteration
   for (let i = 0; i < 1000; i++) {
     process({ data: i });
   }

   // ✅ Reuse object
   let obj = {};
   for (let i = 0; i < 1000; i++) {
     obj.data = i;
     process(obj);
   }
   ```

2. **Avoid Large Object Allocations**:

   ```javascript
   // ❌ Large allocation
   let hugeArray = new Array(1000000);

   // ✅ Process in chunks
   for (let i = 0; i < 1000; i++) {
     let chunk = new Array(1000);
     processChunk(chunk);
   }
   ```

3. **Nullify References Early**:

   ```javascript
   let largeData = fetchLargeData();
   processData(largeData);
   largeData = null; // Help GC by removing reference
   ```

4. **Use Object Pools**:

   ```javascript
   // Reuse objects instead of creating new ones
   const objectPool = [];
   function getObject() {
     return objectPool.pop() || {};
   }
   function releaseObject(obj) {
     objectPool.push(obj);
   }
   ```

5. **Avoid Memory Leaks**:
   - Clean up event listeners
   - Clear timers
   - Remove DOM references
   - Avoid global variables

## Monitoring Garbage Collection

### Chrome DevTools

1. **Performance Tab**:

   - Record performance
   - Look for GC events (marked in timeline)
   - Measure pause times

2. **Memory Tab**:

   - Take heap snapshots
   - Compare snapshots to see what's collected
   - Monitor heap size over time

3. **Console with Flags**:
   ```bash
   chrome --js-flags="--trace-gc"
   ```
   - Logs GC events to console

### Node.js

```javascript
// Enable GC tracking
node --expose-gc --trace-gc script.js

// Manual GC trigger (for testing only)
if (global.gc) {
  global.gc();
}
```

## Common Interview Questions

### Q: How does garbage collection work in JavaScript?

**A:** JavaScript uses automatic garbage collection, primarily the **mark-and-sweep** algorithm:

1. **Mark phase**: Starting from root objects, mark all reachable objects
2. **Sweep phase**: Free memory for unmarked (unreachable) objects
3. Modern engines use **generational GC** (young/old generations) for better performance

### Q: What is the difference between stack and heap memory management?

**A:**

- **Stack**: Managed automatically by execution context mechanism. When function returns, stack frame is popped immediately. No garbage collection needed.
- **Heap**: Managed by garbage collector. Objects remain until GC determines they're unreachable. GC runs automatically in background.

### Q: Can circular references cause memory leaks?

**A:** **No**, not in modern JavaScript. The mark-and-sweep algorithm handles circular references correctly. If both objects in a cycle are unreachable from roots, both will be garbage collected.

```javascript
let objA = { ref: null };
let objB = { ref: null };
objA.ref = objB;
objB.ref = objA;
objA = null;
objB = null; // Both GC'd - no leak
```

### Q: How can you optimize garbage collection performance?

**A:**

1. Reduce object creation (reuse objects)
2. Avoid large allocations (process in chunks)
3. Nullify references early
4. Use object pools
5. Prevent memory leaks
6. Minimize global variables

### Q: When does garbage collection run?

**A:** GC runs automatically when:

- Memory threshold is reached
- At periodic intervals
- During idle time
- You cannot directly control when it runs, but you can influence what gets collected

### Q: What causes long GC pauses?

**A:**

- Large heap size
- Many objects to mark/sweep
- Old generation collections (slower than young)
- Fragmented memory
- Full GC cycles

## Best Practices

1. **Minimize Object Creation**: Reuse objects when possible
2. **Clean Up References**: Set references to `null` when done
3. **Avoid Memory Leaks**: Remove event listeners, clear timers
4. **Monitor Performance**: Use DevTools to track GC pauses
5. **Profile Memory**: Take heap snapshots to identify issues
6. **Use WeakMap/WeakSet**: For temporary object associations
7. **Avoid Global Variables**: They persist for program lifetime

## Related Topics

- [02. Javascript Engine.md](./02.%20Javascript%20Engine.md) - Heap memory details
- [06. Memory Leaks.md](./06.%20Memory%20Leaks.md) - Memory leak prevention
- [12. Memory Profiling Guide.md](./12.%20Memory%20Profiling%20Guide.md) - Profiling techniques
- [10. Performance Optimization.md](./10.%20Performance%20Optimization.md) - Performance strategies






