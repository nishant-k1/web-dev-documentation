# Javascript / ECMAScript Engines

## A JavaScript engine

- Javascript engines are written/built using low level languages like C++. v8 engine is written with c++

- It is a software component that executes JavaScript code. It reads javascript code and runs javascript code. Javascript engine makes computer understand javascript. (In simple language, acts as a translator).

- The first JavaScript engines were mere interpreters, but all relevant modern engines use just-in-time compilation for improved performance

- JavaScript engines are typically developed by web browser vendors, and every major browser has one. In a browser, the JavaScript engine runs in concert with the rendering engine via the Document Object Model.

- The use of JavaScript engines is not limited to browsers. For example, the V8 engine is a core component of the Node.js and Deno runtime systems.

- Since ECMAScript is the standardized specification of JavaScript, ECMAScript engine is another name for these engines.

- We can create our own javascript engine by following the standard and norms of ECMAScript

- We will consider the V8 engine to study the internals of javascript/ECMAScript engine

## Just-in-time compilation engines

1. Spider Monkey (First Javascript Engine developed by Brenden Eich) - Mozilla, GNOME Shell - Firefox
2. V8 - Google, Nodejs, Deno runtime systems
3. Chakra - Edge (Internet Explorer) (now edge uses V8)
4. Javascript Core Webkit - Safari

## Runtime interpreter engines

1. Continuum
2. Futhark
3. InScript
4. JScript
5. Jint
6. Boa

## V8 engine components / ECMAScript engine components

Javascript Source Code
|
Parser
|
AST (Abstract Syntax Tree)
|
|
|
Interpreter ---> Bytecode ---> "machine reads it" ---> Heap - Callstack - Garbage Collector
|
Profiler
|
Compiler
|
|
|
Optimized Code ---> "machine reads it" ---> Heap - Callstack - Garbage Collector

## Things present inside ECMAScript engine

1. Parser

   The **Parser** is the first component in the JavaScript engine's code processing pipeline.

   **What is a Parser?**

   - The parser reads JavaScript source code and converts it into an **Abstract Syntax Tree (AST)**
   - It analyzes the syntax and structure of the code to understand what the code means
   - The AST is a tree-like representation that makes it easier for the interpreter to process the code
   - The parser is the **first step** in code execution
   - **Syntax errors are caught at this stage** - this is why you see syntax errors immediately when writing invalid code
   - Without a valid AST, the code cannot be executed

   **Process**

   1. **Lexical Analysis (Tokenization)**:

      - Breaks down the source code into tokens (keywords, identifiers, operators, etc.)
      - Example: `let x = 5;` → tokens: `let`, `x`, `=`, `5`, `;`

   2. **Syntax Analysis (Parsing)**:
      - Takes the tokens and builds an Abstract Syntax Tree (AST)
      - Validates the syntax according to JavaScript grammar rules
      - Reports syntax errors if the code is invalid

   **Output: Abstract Syntax Tree (AST)**

   - The AST is a tree-like structure that represents the code's structure
   - Each node in the tree represents a construct in the source code
   - The AST makes it easier for the interpreter to understand and process the code

   **Role in JavaScript Engine**

   ```
   JavaScript Source Code
       ↓
   Parser
       ↓
   AST (Abstract Syntax Tree)
       ↓
   Interpreter / Compiler
   ```

   **Example**

   **Source Code:**

   ```javascript
   let x = 5;
   ```

   **AST Representation (simplified):**

   ```
   VariableDeclaration
     ├─ kind: "let"
     ├─ declarations:
     │   └─ VariableDeclarator
     │       ├─ id: "x"
     │       └─ init: 5
   ```

   **Key Points**

   - ✅ First step in code processing
   - ✅ Converts code → AST
   - ✅ Catches syntax errors early
   - ✅ AST is easier for interpreter/compiler to process

2. Interpreter
   It converts the code line by line into Bytecode (Not as low level as machine code)

3. Profiler
   It monitors the interpreter and looks for the code which requires optimization and sends it to the compiler

4. Compiler
   It modifies the code that needs optimization in one go into Optimized Code

5. Heap

   **Definition**

   - The Heap is a region of memory in the JavaScript Engine used to store objects and other data structures that need dynamic memory allocation
   - It is simply a free store - a large memory space that the JavaScript engine provides for us
   - The V8 engine has a heap where it stores objects and data created during the execution of JavaScript code
   - Unlike the Call Stack, which deals with function calls and execution contexts, the heap is used for memory that doesn't follow a strict order or structure, like complex objects, arrays, and functions
   - Stores objects, arrays, and closures
   - Managed by the garbage collector

   **Characteristics**

   - **Unstructured Memory Space**: The heap is an unordered memory pool. Objects are allocated dynamically, meaning memory can be requested and released as needed
   - **Dynamic Nature**: Data stored in the heap can grow and shrink at runtime, making it ideal for storing objects, arrays, and other structures whose size may vary
   - **Longer Lifetime**: Variables stored in the heap remain in memory as long as they are accessible (i.e., as long as references to them exist in the code)

   **Process**

   - **Dynamic Allocation**: When you create an object, array, or function, JavaScript allocates memory for it in the heap. For example:

     ```javascript
     const obj = { name: "Nishant", age: 30 };
     ```

     Here, the `obj` object is stored in the heap, and its reference is stored in the call stack.

   - **Reference to Heap Memory**: Variables in the stack store references (pointers) to the memory location in the heap where the actual data resides

   - **Garbage Collection**:

     - Uses algorithms like mark-and-sweep to identify unreachable objects and free up memory
     - An object is considered unreachable when there are no references to it
     - JavaScript uses Garbage Collection (GC) to manage memory in the heap. If an object in the heap is no longer referenced, the garbage collector automatically frees up the memory
     - Garbage Collection primarily works for the heap memory and not directly for the stack memory
     - It is responsible for managing memory allocation and deallocation
     - The garbage collector identifies and frees up memory that is no longer in use, which helps prevent memory leaks and ensures efficient memory usage
     - Garbage Collection is designed to manage memory in the heap
     - The stack memory is managed automatically by the JavaScript engine's execution context mechanism and doesn't need garbage collection

   - **Memory Leaks**: Common Causes of Memory Leaks in the Heap:
     1. Global Variables
     2. Uncleared Timers or Callbacks
     3. Detached DOM Elements
     4. Closures
     5. Circular References
     6. Over-Retaining Data Structures

   **Common Scenarios Using the Heap**

   - **Object and Array Creation**: Objects and arrays are stored in the heap because their size and structure can change dynamically during runtime

     ```javascript
     const numbers = [1, 2, 3, 4]; // Stored in heap
     ```

   - **Closures**: Functions and their enclosed variables (closures) are stored in the heap if they persist beyond their initial execution

     ```javascript
     function outer() {
       let counter = 0;
       return function inner() {
         counter++;
         console.log(counter);
       };
     }
     const increment = outer(); // Closure stored in heap
     ```

   - **Global Variables**: Global objects and functions typically live in the heap for the lifetime of the program

   **Memory Management in the Heap**

   1. **Garbage Collection**:

      - JavaScript employs automatic garbage collection to free up memory no longer in use
      - Mark-and-Sweep Algorithm is commonly used:
        - It "marks" objects that are still reachable (e.g., through variables or references)
        - "Sweeps" away unmarked objects to free memory

   2. **Memory Leaks**: If objects in the heap are not properly dereferenced, they remain in memory, causing a memory leak. Common causes:
      - Unnecessary global variables
      - Forgotten event listeners
      - Retaining references in closures

   **Common Issues with Heap Memory**

   - **Memory Leaks**: When objects are no longer needed but are still referenced, they are not garbage collected

     ```javascript
     let obj = {};
     const ref = obj; // obj is still referenced, won't be garbage collected
     obj = null; // Memory leak if `ref` persists
     ```

   - **Out-of-Memory Errors**: If too much data is allocated to the heap without freeing up unused objects, you may encounter a heap out-of-memory error
     ```javascript
     const largeArray = [];
     while (true) {
       largeArray.push(new Array(1000000)); // Unbounded growth
     }
     ```

   **Best Practices for Managing Heap Memory**

   - **Use Local Variables**: Prefer local variables over global variables to limit the scope and lifetime of data
   - **Avoid Retaining References**: Ensure objects and event listeners are properly cleaned up when no longer needed
   - **Limit Object Size**: Avoid creating unnecessarily large objects or arrays unless required
   - **Debug Memory Usage**: Use tools like Chrome DevTools or Node.js --inspect flag to monitor memory usage and identify memory leaks

   **Heap Debugging Tools**

   - **Browser DevTools**:
     - Memory Tab: Use the Heap Snapshot to identify memory usage and leaks
     - Timeline Tab: Monitor memory allocation over time
   - **Node.js**: Use the v8 module to inspect heap statistics
   - **Third-Party Tools**: Tools like Heapdump and Memwatch can help identify memory leaks and debug heap usage

   **Function Definition and Memory**

   - The actual code of a function (its definition) is stored in memory in the heap, which is where all objects and functions live
   - When you declare or define a function, a reference to its memory location is stored in the relevant execution context (like the Global Execution Context (GEC) or the Function Execution Context (FEC) where it was declared)
   - The call stack holds execution contexts, which are responsible for managing the execution of code
   - When a function is invoked, its execution context is pushed onto the call stack. This context contains references to variables, including references to functions
   - The function definition itself is not directly stored in the execution context, only its reference is

6. Call Stack

   **Definition**

   - The call stack is the mechanism to manage call stacks
   - The call stack is a stack data structure that stores `Execution Contexts`
   - Each item in the stack is called an `Execution Context`, representing a function's execution
   - On the bottom is always the `GEC` (Global Execution Context), followed by `FEC` (Function Execution Contexts) as functions get invoked
   - The most recent `FEC` is always on the top
   - Function calls themselves (the code) aren't stored in the stack or heap. The call stack stores the execution contexts created when a function is called
   - It is used to keep track of where we are in the code during its execution
   - The call stack is a data structure within the V8 engine that keeps track of the execution of functions and their respective contexts
   - It manages the flow of control when functions are called and returns

   **Role**

   - It stores the information about the active function calls in a program
   - It tracks the order of function calls and their respective contexts

   **Process**

   - When a function is called, a stack frame (or Execution Context) for that function is pushed onto the call stack
   - The stack frame contains information like the function's arguments, local variables, and the location (file name and line number) of the function call
   - As functions are executed, the call stack grows with each new function call. When a function completes, its corresponding stack frame is popped off the stack, allowing the program to return to the previous `Execution Context`
   - The call stack operates on a Last In, First Out (LIFO) basis, meaning the last `Execution Context` added is the first one to be removed
   - Every time a function is called, a "stack frame" (or execution context) is pushed onto the call stack. This frame contains important details about that function, such as its `local variables`, the `arguments passed` to it, and `reference to the calling function` where it was called from
   - The stack itself stores primitive data types (like numbers, strings, booleans, etc.) by value
   - The "quick access" refers to how the call stack lets JavaScript quickly find the context of the function that's currently executing. Since it's a stack, JavaScript always knows where the most recent function call (the "top" of the stack) is
   - As the call stack operates on a Last In, First Out (LIFO) basis, the most recent function is at the top, so it can be quickly accessed for execution or when it's time to pop it off the stack after it finishes
   - `Call history` means the stack keeps track of all previous function calls, letting the program return to the previous function context when the current function finishes
   - The stack memory is managed automatically by the JavaScript engine's execution context mechanism and doesn't need garbage collection

   **Call Stack Overflow**

   - A call stack overflow occurs when there are too many nested function calls, causing the stack to exceed its limit
   - **Recursion**: If a function keeps calling itself indefinitely without a base case to stop, the stack will keep growing until it overflows
   - The browser prevents crashes by throwing an error: "Maximum call stack size exceeded"

   ```javascript
   function overflow() {
     overflow(); // Infinite recursion
   }
   overflow(); // Error: Maximum call stack size exceeded
   ```

   - In JavaScript, a "stack overflow" occurs when the call stack exceeds its maximum size due to too many function calls being nested one inside another without returning. This situation usually leads to a runtime error
   - The call stack is a data structure used by the JavaScript engine to keep track of the sequence of active function calls during program execution
   - When a function is called, a new frame (also known as an activation record or stack frame) is added to the top of the call stack
   - If we keep calling function nested inside of each other it will cause stackoverflow because same function gets pushed on top of stack frame over and over again until browser crashes
   - To prevent the browser from crashing the browser gives an error after certain limit of function execution gets crossed. The error is maximum call size exceeded

   ```javascript
   function inception() {
     inception();
   }
   inception(); // returns Maximum call stack Size exceeded error.
   ```

   **Characteristics**

   - **Fast access**: Allows quick access to the current function's context and its call history
   - **Limited size**: Has a maximum size, leading to a "stack overflow" error if the call history is too deep, often due to improperly terminated recursive functions

   **Example**

   ```javascript
   function func1() {
     console.log("Inside func1");
     func2();
   }

   function func2() {
     console.log("Inside func2");
     func3();
   }

   function func3() {
     console.log("Inside func3");
   }

   func1();
   ```

   **Synchronous Nature of the Call Stack**

   - JavaScript is single-threaded, i.e., it has only one call stack
   - Only one set of instructions is executed at a time. It's not doing multiple things
   - The best way to check that a language is single-threaded is if it has only one call stack
   - One call stack allows us to run code one at a time. We're never running functions in parallel
   - The stack keeps growing as we push new functions on the stack and then we pop them one at a time
   - Functions get invoked in LIFO manner
   - When the function is invoked it gets popped/removed from the call stack
   - Because of single-threaded JavaScript is synchronous, i.e., one at a time in order. It appears that only one thing can happen at the time

   **Call Stack and Asynchronous Code**

   - JavaScript is single-threaded, but asynchronous code (like setTimeout, Promises, or AJAX calls) doesn't block the call stack. The asynchronous functions are placed in the Event Queue, and once the call stack is empty, the event loop picks them up and moves them onto the stack for execution
   - This behavior makes JavaScript non-blocking, allowing asynchronous tasks to run while other code is being executed, giving the appearance of parallelism

   While JavaScript is single-threaded, it handles asynchronous code using the Event Loop, which works alongside the call stack. Here's an example:

   ```javascript
   console.log("Start");

   setTimeout(() => {
     console.log("Timeout");
   }, 1000);

   console.log("End");

   // Output
   // Start
   // End
   // Timeout
   ```

   Call Stack Execution:

   1. console.log("Start") → Prints "Start"
   2. setTimeout() → Sends the callback to the Web API and immediately returns
   3. console.log("End") → Prints "End"
   4. After 1000ms, the callback from the Web API is sent to the Message Queue
   5. The Event Loop pushes the callback onto the stack when it is empty → Prints "Timeout"

   **Call Stack and Execution Context**

   - The Call Stack works closely with the Execution Context
   - Execution Context contains all the information needed to execute a function (variables, this binding, etc.)
   - When a function is called, its execution context is created and pushed onto the call stack
   - The top of the stack is always the currently executing function

   **Data Storage in Call Stack**

   - **Primitive Data Types**: Primitives like numbers, strings, booleans, undefined, null, and symbols are stored by value on the stack. This means that the actual value is directly placed in the stack frame for each function
   - **Non-Primitive Data Types**: Non-primitives like objects, arrays, and functions are stored in the heap. What the stack stores in the execution context is a reference (a pointer) to the memory location in the heap where the actual object or array is stored. The stack frame holds this reference, and not the object itself
   - Primitives: Directly in the stack
   - Non-primitives including Functions: Reference in the stack, but the actual object or array is in the heap
   - The function definition itself is not directly stored in the execution context, only its reference is

   Example:

   ```javascript
   function example() {
     let num = 10; // Primitive (stored on the stack)
     let person = { name: "John" }; // Object (reference stored on the stack, actual object in heap)

     console.log(num);
     console.log(person.name);
   }
   ```

   **Call Stack Debugging**

   1. **Browser DevTools**:

      - Use the Sources tab to debug and view the call stack in real-time
      - Set breakpoints to pause execution and examine the stack

   2. **Stack Traces**: When an error occurs, JavaScript provides a stack trace to help debug

## Interpreter vs Compiler (JIT) vs Transpiler

### Interpreter

- Executes code line-by-line, translating on the fly.
- Fast feedback, simpler debugging; slower overall; no output artifact.

### Compiler / JIT

- Translates ahead-of-time (or just-in-time) to machine code/bytecode; can optimize hotspots (JIT) after profiling.
- Better steady-state performance; slower startup; errors reported after compile step.
- JIT in modern engines: parser → AST → interpreter → baseline bytecode; profiler identifies hot paths; optimizing compiler rewrites hot code to optimized machine code.

### Transpiler

- Converts from one source language/version to another (e.g., TS→JS, Babel ESNext→ES5).
- Keeps you using newer language features while targeting older environments.
