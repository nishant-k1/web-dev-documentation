# Common Pitfalls & Gotchas

Common mistakes developers make when working with mutation in JavaScript.

---

## 1. Mutating Function Parameters

### âŒ BAD - Mutates Input Parameter

```js
function addId(user) {
  user.id = generateId(); // âŒ Mutates original
  return user;
}

const user = { name: "John" };
addId(user);
console.log(user); // { name: "John", id: 123 } âŒ Original changed!
```

### âœ… GOOD - Returns New Object

```js
function addId(user) {
  return { ...user, id: generateId() }; // âœ… Returns new object
}

const user = { name: "John" };
const userWithId = addId(user);
console.log(user); // { name: "John" } âœ… Original unchanged
```

**Rule:** Functions should not mutate their input parameters unless explicitly intended.

---

## 2. Mutation in Loops

### âŒ BAD - Mutates Original Array

```js
const users = [{ name: "John" }, { name: "Jane" }];
users.forEach((user) => {
  user.active = true; // âŒ Mutates original objects
});

console.log(users[0].active); // true âŒ Original changed!
```

### âœ… GOOD - Creates New Array

```js
const users = [{ name: "John" }, { name: "Jane" }];
const updatedUsers = users.map((user) => ({ ...user, active: true })); // âœ… New array

console.log(users[0].active); // undefined âœ… Original unchanged
console.log(updatedUsers[0].active); // true âœ… New objects
```

---

## 3. Shared References

### âŒ PROBLEM - Shared Reference

```js
const original = { data: { value: 1 } };
const copy = original; // Same reference
copy.data.value = 2;
console.log(original.data.value); // 2 âŒ Original changed!
```

### âœ… SOLUTION - Shallow Copy

```js
const original = { data: { value: 1 } };
const copy = { ...original }; // Shallow copy
copy.data.value = 2;
console.log(original.data.value); // 2 âŒ Still changed! (nested object shared)
```

### âœ… SOLUTION - Deep Copy

```js
const original = { data: { value: 1 } };
const deepCopy = structuredClone(original); // Deep copy
deepCopy.data.value = 2;
console.log(original.data.value); // 1 âœ… Original unchanged
```

---

## 4. Accidental Mutation in React

### âŒ BAD - Direct Mutation

```js
function Component() {
  const [items, setItems] = useState([1, 2, 3]);

  const addItem = () => {
    items.push(4); // âŒ Mutates state directly
    setItems(items); // React won't detect change (same reference)
    // Component won't re-render!
  };
}
```

### âœ… GOOD - Immutable Update

```js
function Component() {
  const [items, setItems] = useState([1, 2, 3]);

  const addItem = () => {
    setItems([...items, 4]); // âœ… New array reference
    // Component will re-render correctly
  };
}
```

### âŒ BAD - Nested Mutation

```js
function Component() {
  const [user, setUser] = useState({ profile: { age: 25 } });

  const updateAge = () => {
    user.profile.age = 26; // âŒ Mutates nested object
    setUser(user); // Won't trigger re-render
  };
}
```

### âœ… GOOD - Immutable Nested Update

```js
function Component() {
  const [user, setUser] = useState({ profile: { age: 25 } });

  const updateAge = () => {
    setUser({
      ...user,
      profile: {
        ...user.profile,
        age: 26,
      },
    }); // âœ… New object at all levels
  };
}
```

---

## 5. const Doesn't Prevent Mutation

Many developers think `const` prevents mutation. It only prevents re-assignment.

### Common Misconception

```js
const obj = { name: "John" };
obj.name = "Jane"; // âœ… This WORKS! const doesn't prevent mutation
console.log(obj.name); // "Jane"

const arr = [1, 2, 3];
arr.push(4); // âœ… This WORKS!
console.log(arr); // [1, 2, 3, 4]
```

### To Actually Prevent Mutation

```js
const obj = { name: "John" };
Object.freeze(obj); // Now mutation is prevented
obj.name = "Jane"; // âŒ Fails (in strict mode throws error)
```

---

## 6. Array Methods That Mutate

Some array methods mutate the original array:

### Mutating Methods (Be Careful!)

```js
const arr = [1, 2, 3];

arr.push(4); // Mutates
arr.pop(); // Mutates
arr.shift(); // Mutates
arr.unshift(0); // Mutates
arr.sort(); // Mutates
arr.reverse(); // Mutates
arr.splice(0, 1); // Mutates
arr.fill(0); // Mutates
```

### Non-Mutating Methods (Safe)

```js
const arr = [1, 2, 3];

arr.map(...); // Returns new array
arr.filter(...); // Returns new array
arr.slice(...); // Returns new array
arr.concat(...); // Returns new array
arr.reduce(...); // Returns new value
```

**Rule:** Check array method documentation - if it returns a new array/value, it's usually non-mutating.

---

## 7. Object.assign() Mutates First Argument

### âŒ PROBLEM - Mutates Target

```js
const target = { a: 1 };
const source = { b: 2 };
Object.assign(target, source);
console.log(target); // { a: 1, b: 2 } âŒ target was mutated
```

### âœ… SOLUTION - Use Empty Object

```js
const target = { a: 1 };
const source = { b: 2 };
const result = Object.assign({}, target, source); // âœ… target unchanged
console.log(target); // { a: 1 } âœ… Original unchanged
console.log(result); // { a: 1, b: 2 } âœ… New object
```

---

## 8. Modifying Arrays During Iteration

### âŒ BAD - Adding/Removing During Iteration

```js
const arr = [1, 2, 3];
arr.forEach((item, index) => {
  if (item === 2) {
    arr.splice(index, 1); // âŒ Mutates array during iteration
  }
});
// Unexpected behavior!
```

### âœ… GOOD - Filter First, Then Process

```js
const arr = [1, 2, 3];
const filtered = arr.filter((item) => item !== 2); // âœ… Create new array
filtered.forEach((item) => {
  // Process filtered array
});
```

---

## 9. Default Parameters Mutation

### âŒ BAD - Mutating Default Parameter

```js
function processItems(items = []) {
  items.push("processed"); // âŒ Mutates default parameter
  return items;
}

processItems(); // Returns ["processed"]
processItems(); // Returns ["processed", "processed"] âŒ Default was mutated!
```

### âœ… GOOD - Create New Array

```js
function processItems(items = []) {
  return [...items, "processed"]; // âœ… Returns new array
}

processItems(); // Returns ["processed"]
processItems(); // Returns ["processed"] âœ… Correct
```

---

## 10. Cloning Not Deep Enough

### âŒ PROBLEM - Shallow Copy

```js
const original = { user: { name: "John" } };
const copy = { ...original }; // Shallow copy
copy.user.name = "Jane";
console.log(original.user.name); // "Jane" âŒ Original changed!
```

### âœ… SOLUTION - Deep Copy When Needed

```js
const original = { user: { name: "John" } };
const copy = structuredClone(original); // Deep copy
copy.user.name = "Jane";
console.log(original.user.name); // "John" âœ… Original unchanged
```

---

## Best Practices to Avoid Pitfalls

1. **Always assume inputs are shared** - Don't mutate function parameters
2. **Use map/filter/reduce** - Prefer non-mutating array methods
3. **Create copies for shared data** - When data might be shared, always copy first
4. **Use spread operator** - Default to `{...obj}` and `[...arr]` for copies
5. **Deep copy nested structures** - Use `structuredClone()` for nested objects/arrays
6. **Freeze configuration objects** - Use `Object.freeze()` for config that shouldn't change
7. **Test immutability** - Verify that operations don't mutate originals

---

## Related Topics

ğŸ“– See: [Mutation Overview](./01.%20Mutation%20Overview.md)
ğŸ“– See: [Preventing Mutation](./03.%20Preventing%20Mutation.md)
ğŸ“– See: [Practical Patterns](./04.%20Practical%20Patterns.md)
