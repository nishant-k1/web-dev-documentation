# Initializations

Initialization is the process of giving a variable its **first value** when it is declared. It's the act of setting an initial value to a variable during or immediately after declaration.

## Key Concepts

- **Initialization** = Giving a variable its first value
- **Declaration** = Creating the variable (introducing the identifier)
- **Assignment** = Giving a variable a value (can be initial or subsequent)

## Declaration vs Initialization

### Declaration Only

A variable can be declared without initialization:

```js
let x; // Declaration only - x is declared but not initialized
```

### Declaration with Initialization

A variable can be declared and initialized in one step:

```js
let x = 10; // Declaration + Initialization
```

Here, `x` is both declared and initialized with the value `10` in a single statement.

### Declaration Then Initialization

A variable can be declared first, then initialized later:

```js
let y; // Declaration
y = 20; // Initialization (first assignment)
```

## Initialization Behavior by Declaration Type

### `var` Initialization

- **Default Value**: `undefined` (automatically initialized during hoisting)
- **Timing**: Initialized during the **Creation Phase** of Execution Context
- **Access Before Declaration**: Returns `undefined` (not an error)

```js
console.log(x); // undefined (not an error)
var x = 10; // Declaration + Initialization
console.log(x); // 10
```

**What happens:**

1. During Creation Phase: `x` is hoisted and initialized with `undefined`
2. During Execution Phase: `x` is assigned the value `10`

### `let` Initialization

- **Default Value**: No default (remains uninitialized)
- **Timing**: Initialized when execution reaches the declaration line
- **Access Before Declaration**: Throws `ReferenceError` (Temporal Dead Zone)

```js
console.log(x); // ❌ ReferenceError: Cannot access 'x' before initialization
let x = 10; // Declaration + Initialization
console.log(x); // 10
```

**What happens:**

1. During Creation Phase: `x` is hoisted but **not initialized** (in TDZ)
2. During Execution Phase: When line `let x = 10;` is reached, `x` is initialized with `10`

### `const` Initialization

- **Default Value**: No default (remains uninitialized)
- **Timing**: Initialized when execution reaches the declaration line
- **Access Before Declaration**: Throws `ReferenceError` (Temporal Dead Zone)
- **Requirement**: **Must be initialized** at declaration (cannot be declared without initialization)

```js
const x = 10; // ✅ Declaration + Initialization (required)
console.log(x); // 10

const y; // ❌ SyntaxError: Missing initializer in const declaration
```

**What happens:**

1. During Creation Phase: `x` is hoisted but **not initialized** (in TDZ)
2. During Execution Phase: When line `const x = 10;` is reached, `x` is initialized with `10`

## Initialization Values

### Primitive Values

```js
let num = 42; // Number
let str = "Hello"; // String
let bool = true; // Boolean
let nul = null; // Null
let undef = undefined; // Undefined
let sym = Symbol("id"); // Symbol
let big = 100n; // BigInt
```

### Non-Primitive Values

```js
let obj = {}; // Object
let arr = []; // Array
let func = function () {}; // Function
```

## Multiple Initializations

You can initialize multiple variables in one statement:

```js
let a = 1,
  b = 2,
  c = 3; // Multiple declarations with initialization
```

## Destructuring Initialization

You can initialize variables using destructuring:

```js
// Array destructuring
let [x, y, z] = [1, 2, 3];

// Object destructuring
let { name, age } = { name: "John", age: 30 };
```

## Initialization in Different Scopes

### Global Scope

```js
var globalVar = 10; // Global initialization
let globalLet = 20; // Global initialization
const globalConst = 30; // Global initialization
```

### Function Scope

```js
function example() {
  var funcVar = 10; // Function-scoped initialization
  let funcLet = 20; // Block-scoped initialization
  const funcConst = 30; // Block-scoped initialization
}
```

### Block Scope

```js
if (true) {
  var blockVar = 10; // Function-scoped (not block-scoped)
  let blockLet = 20; // Block-scoped initialization
  const blockConst = 30; // Block-scoped initialization
}
```

## Important Notes

1. **`const` requires initialization**: You cannot declare a `const` without initializing it
2. **`var` auto-initializes**: `var` variables are automatically initialized with `undefined` during hoisting
3. **`let`/`const` TDZ**: `let` and `const` remain uninitialized until the declaration line is executed
4. **Initialization vs Assignment**: Initialization is the first assignment; subsequent assignments are just assignments
5. **Timing matters**: When initialization happens affects when you can access the variable

## Comparison Table

| Declaration Type | Default Initialization | Can Declare Without Init | TDZ    |
| ---------------- | ---------------------- | ------------------------ | ------ |
| `var`            | `undefined` (auto)     | ✅ Yes                   | ❌ No  |
| `let`            | None (uninitialized)   | ✅ Yes                   | ✅ Yes |
| `const`          | None (uninitialized)   | ❌ No (must initialize)  | ✅ Yes |
