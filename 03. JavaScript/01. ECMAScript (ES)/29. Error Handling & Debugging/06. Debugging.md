# Debugging

Debugging is the process of finding and fixing bugs in your code. As a developer, you'll spend a significant amount of time debugging, so mastering debugging techniques is essential.

---

## What is Debugging?

Debugging involves:

- **Understanding** what your code is supposed to do
- **Identifying** why it's not working as expected
- **Finding** the root cause of the issue
- **Fixing** the problem

---

## Debugging Methods

### 1. Console Methods

#### `console.log()` - Basic Logging

```javascript
console.log("Variable value:", variable);
console.log("Multiple values:", a, b, c);
```

#### `console.error()` - Error Messages

```javascript
console.error("Error occurred:", error);
```

#### `console.warn()` - Warnings

```javascript
console.warn("This might be a problem:", warning);
```

#### `console.table()` - Tabular Data

```javascript
const users = [
  { name: "John", age: 30 },
  { name: "Jane", age: 25 },
];
console.table(users);
```

#### `console.trace()` - Stack Trace

```javascript
function a() {
  function b() {
    function c() {
      console.trace("Call stack:");
    }
    c();
  }
  b();
}
a();
```

#### `console.time()` / `console.timeEnd()` - Performance

```javascript
console.time("operation");
// ... some code ...
console.timeEnd("operation"); // Logs: operation: 123.456ms
```

#### `console.group()` - Grouped Logs

```javascript
console.group("User Data");
console.log("Name: John");
console.log("Age: 30");
console.groupEnd();
```

---

### 2. The `debugger` Statement

The `debugger` keyword pauses execution when DevTools is open.

```javascript
function processData(data) {
  debugger; // Execution stops here if DevTools is open
  const result = data.map((item) => item * 2);
  return result;
}
```

**How to use:**

1. Add `debugger;` where you want to pause
2. Open browser DevTools (F12)
3. Run your code
4. Execution pauses at the `debugger` statement
5. Inspect variables, step through code, etc.

---

### 3. Chrome DevTools

#### Breakpoints

1. Open DevTools (F12)
2. Go to Sources tab
3. Click line numbers to set breakpoints
4. Execution pauses at breakpoints

#### Step Controls

- **Resume (F8)** - Continue execution
- **Step Over (F10)** - Execute current line, don't enter functions
- **Step Into (F11)** - Enter function calls
- **Step Out (Shift+F11)** - Exit current function
- **Step** - Execute next statement

#### Watch Expressions

Monitor variable values:

- Add variables to Watch panel
- Values update as you step through code

#### Call Stack

View the function call chain:

- See how you got to the current point
- Navigate between stack frames

#### Scope Panel

Inspect variables in different scopes:

- Local scope
- Closure scope
- Global scope

---

### 4. Network Debugging

#### Inspect Network Requests

1. Open DevTools → Network tab
2. See all HTTP requests
3. Inspect request/response headers
4. Check response data
5. Monitor request timing

#### Filter Requests

- Filter by type (XHR, Fetch, JS, CSS, etc.)
- Filter by status code
- Search by URL

---

### 5. Performance Debugging

#### Performance Tab

1. Record performance
2. Analyze runtime performance
3. Identify bottlenecks
4. Optimize slow code

#### Memory Profiling

1. Memory tab
2. Take heap snapshots
3. Identify memory leaks
4. Compare snapshots

---

### 6. Source Maps

Source maps allow debugging of minified/transpiled code:

```javascript
// Original code (TypeScript/ES6)
function processData(data: number[]): number[] {
  return data.map((x) => x * 2);
}

// Minified code (what browser runs)
function processData(a) {
  return a.map((b) => b * 2);
}

// Source map connects them
```

**Enable source maps:**

- DevTools → Settings → Enable source maps
- Debug original code, not minified

---

## Debugging Strategies

### 1. Reproduce the Bug

- Understand when/why it happens
- Create minimal test case
- Isolate the problem

### 2. Use Binary Search

- Comment out half the code
- See if bug still occurs
- Narrow down the problem area

### 3. Read Error Messages

- Error messages tell you what went wrong
- Stack traces show where it happened
- Don't ignore error details

### 4. Check Assumptions

- Verify variable values
- Check function return values
- Validate input data

### 5. Use Rubber Duck Debugging

- Explain your code out loud
- Often reveals the problem
- Forces you to think clearly

---

## Common Debugging Scenarios

### Undefined Variables

```javascript
// Problem
console.log(user.name); // ReferenceError: user is not defined

// Debug
console.log("user:", user); // Check if user exists
```

### Type Errors

```javascript
// Problem
arr.push(item); // TypeError: arr.push is not a function

// Debug
console.log("arr type:", typeof arr);
console.log("arr value:", arr);
```

### Async Issues

```javascript
// Problem
let data;
fetch("/api/data").then((res) => (data = res.json()));
console.log(data); // undefined

// Debug
fetch("/api/data")
  .then((res) => {
    console.log("Response:", res);
    return res.json();
  })
  .then((json) => {
    console.log("Data:", json);
    data = json;
  });
```

---

## Best Practices

### ✅ Do

- Use meaningful console messages
- Remove debug code before production
- Use source maps for debugging
- Set breakpoints strategically
- Use conditional breakpoints

### ❌ Don't

- Leave `console.log` everywhere
- Use `debugger` in production code
- Ignore error messages
- Debug without understanding the code

---

## Related Topics

- [2. Errors in javascript.md](./2.%20Errors%20in%20javascript.md) - Understanding errors
- [11. Common Interview Questions.md](./11.%20Common%20Interview%20Questions.md) - Debugging questions
