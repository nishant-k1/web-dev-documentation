# OOP Core Principles: Polymorphism

- The idea behind polymorphism is the ability to call the same method on different objects and each object responding in different way.
- OOP gets ability to process objects differently depending on their datatype or class. Now, because JavaScript is a dynamically typed language, it actually limits the amount of polymorphism.

---

## What is Polymorphism?

Polymorphism (from Greek: "many forms") is the ability of objects of different types to be accessed through the same interface. It allows you to write code that works with objects of multiple types, where each type can provide its own implementation of a method.

---

## Types of Polymorphism

### 1. Method Overloading

Same methods act differently for different instances of a class. (Note: JavaScript doesn't support true method overloading like Java/C++, but we can simulate it)

```js
class Calculator {
  // JavaScript doesn't have true overloading, but we can use default parameters
  add(a, b, c) {
    if (c !== undefined) {
      return a + b + c;
    }
    return a + b;
  }
}

const calc = new Calculator();
calc.add(1, 2); // 3
calc.add(1, 2, 3); // 6
```

### 2. Method Overriding

Adding extra features or extra parameters to the method. Child classes can override parent class methods.

```js
class Animal {
  makeSound() {
    return "Some generic sound";
  }
}

class Dog extends Animal {
  // Overriding parent method
  makeSound() {
    return "Woof! Woof!";
  }
}

class Cat extends Animal {
  // Overriding parent method
  makeSound() {
    return "Meow! Meow!";
  }
}

const dog = new Dog();
const cat = new Cat();

dog.makeSound(); // "Woof! Woof!"
cat.makeSound(); // "Meow! Meow!"
```

---

## Polymorphism in Action

### Example: Shape Hierarchy

```js
class Shape {
  area() {
    throw new Error("Method 'area()' must be implemented");
  }
}

class Circle extends Shape {
  constructor(radius) {
    super();
    this.radius = radius;
  }

  area() {
    return Math.PI * this.radius * this.radius;
  }
}

class Rectangle extends Shape {
  constructor(width, height) {
    super();
    this.width = width;
    this.height = height;
  }

  area() {
    return this.width * this.height;
  }
}

class Triangle extends Shape {
  constructor(base, height) {
    super();
    this.base = base;
    this.height = height;
  }

  area() {
    return (this.base * this.height) / 2;
  }
}

// Polymorphic behavior - same method, different implementations
const shapes = [new Circle(5), new Rectangle(4, 6), new Triangle(3, 4)];

shapes.forEach((shape) => {
  console.log(`Area: ${shape.area()}`); // Each shape calculates area differently
});
```

---

## Duck Typing in JavaScript

JavaScript's dynamic typing enables "duck typing" - if it walks like a duck and quacks like a duck, it's a duck. This is a form of polymorphism.

```js
// Different objects with same method signature
const dog = {
  makeSound() {
    return "Woof!";
  },
};

const cat = {
  makeSound() {
    return "Meow!";
  },
};

const robot = {
  makeSound() {
    return "Beep!";
  },
};

// Polymorphic function - works with any object that has makeSound()
function makeAnimalSound(animal) {
  return animal.makeSound();
}

makeAnimalSound(dog); // "Woof!"
makeAnimalSound(cat); // "Meow!"
makeAnimalSound(robot); // "Beep!"
```

---

## Benefits of Polymorphism

1. **Code Reusability**: Write code that works with multiple types
2. **Flexibility**: Easy to add new types without modifying existing code
3. **Maintainability**: Changes to one type don't affect others
4. **Extensibility**: Easy to extend functionality through inheritance
5. **Abstraction**: Work with objects at a higher level of abstraction

---

## Real-World Examples

### 1. Array Methods

```js
// Different types, same interface
const numbers = [1, 2, 3];
const strings = ["a", "b", "c"];
const objects = [{ id: 1 }, { id: 2 }];

// Same method works with different types
numbers.map((x) => x * 2);
strings.map((x) => x.toUpperCase());
objects.map((x) => x.id);
```

### 2. Event Handlers

```js
// Different event types, same handler interface
button.addEventListener("click", handler);
input.addEventListener("change", handler);
form.addEventListener("submit", handler);
```

### 3. Payment Processing

```js
class PaymentMethod {
  processPayment(amount) {
    throw new Error("Must implement processPayment");
  }
}

class CreditCard extends PaymentMethod {
  processPayment(amount) {
    return `Processing $${amount} via Credit Card`;
  }
}

class PayPal extends PaymentMethod {
  processPayment(amount) {
    return `Processing $${amount} via PayPal`;
  }
}

class BankTransfer extends PaymentMethod {
  processPayment(amount) {
    return `Processing $${amount} via Bank Transfer`;
  }
}

function checkout(paymentMethod, amount) {
  return paymentMethod.processPayment(amount);
}

// Same interface, different implementations
checkout(new CreditCard(), 100);
checkout(new PayPal(), 100);
checkout(new BankTransfer(), 100);
```

---

## Limitations in JavaScript

Since JavaScript is dynamically typed, polymorphism is less strict than in statically typed languages:

- No compile-time type checking
- Runtime errors if methods don't exist
- Duck typing allows flexibility but can lead to errors
- TypeScript can help add static type checking for better polymorphism support

---

## Interview Points

- Polymorphism allows objects of different types to be treated through the same interface
- Method overriding enables child classes to provide specific implementations
- JavaScript's dynamic typing enables duck typing (if it has the method, it works)
- Polymorphism improves code flexibility and maintainability
- It's one of the four pillars of OOP along with Encapsulation, Abstraction, and Inheritance
- In JavaScript, polymorphism is achieved through method overriding and duck typing
