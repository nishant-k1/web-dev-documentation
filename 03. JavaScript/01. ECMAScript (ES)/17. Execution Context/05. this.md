# this

It's basically the value that the this keyword holds in that particular execution context.

> ðŸ“– **Parent Topic:** [03. Components of Execution Context](./03.%20Components%20of%20Execution%20Context.md)

## How `this` binding in EC is Determined

The **value of `this`** is determined by how the function is called:

1. **Method Call**: When a function is called as a method of an object, `this` refers to that object.

   ```Javascript
   const obj = {
     name: 'Nishant',
     greet() {
       console.log(this.name); // `this` refers to `obj`
     }
   };
   obj.greet(); // 'Nishant'
   ```

2. **Explicit Binding**: Using `.bind()`, `.call()`, or `.apply()`, you can explicitly set `this`.

   ```Javascript
   function greet() {
     console.log(this.name);
   }
   const obj = { name: 'Alice' };
   greet.call(obj); // `this` refers to `obj`
   ```

3. **Arrow Functions**: Arrow functions do not have their own `this`. Instead, they inherit `this` from their enclosing lexical scope.

   ```Javascript
   const obj = {
     name: 'Nishant',
     greet: () => {
       console.log(this.name); // `this` is inherited from the outer scope, not `obj`
     }
   };
   obj.greet(); // `this` refers to global/window (or undefined in strict mode)
   ```

4. **Constructor Functions (new keyword)**: When a function is called with `new`, `this` refers to the newly created object.

   ```javascript
   function Person(name) {
     this.name = name; // `this` is the new object being created
   }
   const person = new Person("Alice");
   console.log(person.name); // 'Alice'
   ```

5. **Default Binding**: In a regular function call (not a method), `this` refers to the global object (or `undefined` in strict mode).

   ```Javascript
   function greet() {
     console.log(this); // `this` refers to global object (or undefined in strict mode)
   }
   greet();
   ```

---

## ðŸ”¥ `call()`, `apply()`, `bind()` - Deep Dive

These methods allow you to explicitly set the value of `this`.

### Syntax Comparison

| Method    | Syntax                                | Invokes Immediately? | Returns         |
| --------- | ------------------------------------- | -------------------- | --------------- |
| `call()`  | `func.call(thisArg, arg1, arg2, ...)` | âœ… Yes               | Function result |
| `apply()` | `func.apply(thisArg, [argsArray])`    | âœ… Yes               | Function result |
| `bind()`  | `func.bind(thisArg, arg1, arg2, ...)` | âŒ No                | New function    |

### Examples

```javascript
function introduce(greeting, punctuation) {
  console.log(`${greeting}, I'm ${this.name}${punctuation}`);
}

const person = { name: "Nishant" };

// call - arguments passed individually
introduce.call(person, "Hello", "!"); // "Hello, I'm Nishant!"

// apply - arguments passed as array
introduce.apply(person, ["Hi", "?"]); // "Hi, I'm Nishant?"

// bind - returns a new function, doesn't invoke immediately
const boundIntro = introduce.bind(person, "Hey");
boundIntro("..."); // "Hey, I'm Nishant..."
```

### ðŸ”¥ Interview Trap: bind() Returns a Function!

```javascript
function greet() {
  console.log(this.name);
}

const obj = { name: "Test" };

// âŒ Common mistake - forgetting to invoke
greet.bind(obj); // Does nothing! Just returns a function
console.log("done");

// âœ… Correct - invoke the bound function
greet.bind(obj)(); // "Test"
// OR
const bound = greet.bind(obj);
bound(); // "Test"
```

### ðŸ”¥ Interview Trap: bind() Cannot Be Overridden

```javascript
function greet() {
  console.log(this.name);
}

const obj1 = { name: "First" };
const obj2 = { name: "Second" };

const boundOnce = greet.bind(obj1);
const boundTwice = boundOnce.bind(obj2); // Trying to rebind

boundTwice(); // "First" - NOT "Second"! bind() only works once
```

### ðŸ”¥ Interview Trap: Arrow Functions Ignore call/apply/bind

```javascript
const obj = { name: "Object" };

const arrow = () => {
  console.log(this.name);
};

arrow.call(obj); // undefined (or global) - NOT "Object"
arrow.apply(obj); // undefined (or global) - NOT "Object"
arrow.bind(obj)(); // undefined (or global) - NOT "Object"

// Arrow functions ALWAYS use lexical this - you cannot override it!
```

---

## ðŸ”¥ Common `this` Interview Traps

### Trap 1: Lost `this` in Callbacks

```javascript
const obj = {
  name: "Nishant",
  greet() {
    console.log(this.name);
  },
};

obj.greet(); // "Nishant" âœ…

setTimeout(obj.greet, 100); // undefined âŒ - `this` is lost!

// Why? When you pass obj.greet to setTimeout, you're passing
// just the function reference, not the object context.

// Solutions:
setTimeout(() => obj.greet(), 100); // Arrow function wrapper
setTimeout(obj.greet.bind(obj), 100); // Explicit bind
```

### Trap 2: `this` in Nested Functions

```javascript
const obj = {
  name: "Outer",
  outer() {
    console.log(this.name); // "Outer" âœ…

    function inner() {
      console.log(this.name); // undefined âŒ (or global in non-strict)
    }
    inner();
  },
};

obj.outer();

// Why? inner() is called as a standalone function, not as a method.

// Solutions:
const obj2 = {
  name: "Outer",
  outer() {
    const self = this; // Solution 1: Save reference
    function inner() {
      console.log(self.name); // "Outer" âœ…
    }

    const innerArrow = () => {
      // Solution 2: Arrow function
      console.log(this.name); // "Outer" âœ…
    };

    inner();
    innerArrow();
  },
};
```

### Trap 3: Method Shorthand vs Arrow in Objects

```javascript
const obj = {
  name: "Test",

  // âœ… Method shorthand - this works correctly
  method() {
    console.log(this.name);
  },

  // âŒ Arrow function - this is lexical (probably global/undefined)
  arrow: () => {
    console.log(this.name);
  },
};

obj.method(); // "Test" âœ…
obj.arrow(); // undefined âŒ
```

### Trap 4: Extracting Methods

```javascript
const obj = {
  name: "Original",
  getName() {
    return this.name;
  },
};

console.log(obj.getName()); // "Original" âœ…

const extracted = obj.getName;
console.log(extracted()); // undefined âŒ - context lost!

// The moment you extract a method, it loses its `this` context
```

### Trap 5: `this` in Event Handlers

```javascript
const button = {
  text: "Click me",
  handleClick() {
    console.log(this.text);
  },
};

// âŒ Wrong - this will be the DOM element, not button object
document.querySelector("btn").addEventListener("click", button.handleClick);

// âœ… Correct solutions:
document
  .querySelector("btn")
  .addEventListener("click", () => button.handleClick());
document
  .querySelector("btn")
  .addEventListener("click", button.handleClick.bind(button));
```

### Trap 6: `this` with `new` Keyword Priority

```javascript
function Foo(name) {
  this.name = name;
}

const obj = { name: "bound" };
const BoundFoo = Foo.bind(obj);

const instance = new BoundFoo("constructed");
console.log(instance.name); // "constructed" - NOT "bound"!

// `new` has HIGHER priority than bind()!
```

---

## `this` Binding Priority (Highest to Lowest)

1. **`new` keyword** - `this` = newly created object
2. **Explicit binding** (`call`, `apply`, `bind`) - `this` = specified object
3. **Implicit binding** (method call) - `this` = object before the dot
4. **Default binding** - `this` = global object (or undefined in strict mode)

**Arrow functions** break this rule - they ALWAYS use lexical `this` from enclosing scope.
