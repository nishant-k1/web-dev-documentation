# Arrow Function

> ðŸ“– **Parent Topic:** [03. Components of Execution Context](./03.%20Components%20of%20Execution%20Context.md)

## Arrow Functions and Execution Context

**Common Misconception:** "Arrow functions do not create their own execution context."

**âœ… Reality:** Arrow functions DO create their own execution context when invoked. What makes them different is what they DON'T have:

- âŒ No own `this` binding (inherited from enclosing lexical scope)
- âŒ No `arguments` object
- âŒ No `super` binding
- âŒ No `new.target`
- âŒ Cannot be used as constructors (cannot use `new`)

Arrow functions lexically bind the `this` keyword, meaning they inherit `this` from the surrounding execution context (the context in which the arrow function was defined).

## Arrow Functions vs Regular Functions

| Feature            | Regular Function             | Arrow Function                    |
| ------------------ | ---------------------------- | --------------------------------- |
| Execution Context  | âœ… Creates its own           | âœ… Creates its own                |
| `this` Binding     | âœ… Creates its own (dynamic) | âŒ Inherited (lexical)            |
| `arguments` Object | âœ… Has its own               | âŒ Inherited from enclosing scope |
| Can be Constructor | âœ… Yes (using `new`)         | âŒ No                             |
| `super` Binding    | âœ… Creates its own           | âŒ Inherited                      |
| `new.target`       | âœ… Has its own               | âŒ Inherited                      |

## Arrow Function and `this`

- In JavaScript, the `this` keyword refers to the object that the function is a property of.
- However, the value of `this` depends on how a function is called.
- Arrow functions don't have their own `this` â€” they capture `this` from the enclosing scope at the time they are defined.
- To ensure that a regular function's `this` refers to the desired context, we can bind it explicitly using the `.bind()` method.

```javascript
const obj = {
  name: "Example",
  regularFunc: function () {
    console.log(this.name); // "Example" - this is obj
  },
  arrowFunc: () => {
    console.log(this.name); // undefined - this is inherited from global/module scope
  },
  methodWithArrow: function () {
    const arrow = () => {
      console.log(this.name); // "Example" - this is inherited from methodWithArrow's scope
    };
    arrow();
  },
};
```

## Key Takeaway

Arrow functions have their own execution context, but they inherit `this`, `arguments`, `super`, and `new.target` from their enclosing lexical scope. This makes them ideal for callbacks and situations where you want to preserve the outer `this` context.
