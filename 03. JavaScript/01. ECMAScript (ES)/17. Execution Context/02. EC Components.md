# Components of Execution Context

Each Execution Context Type (GEC, FEC etc) has **3 core components**:

1. **Variable Environment** - stores `var` declarations and `function` declarations
2. **Lexical Environment** - stores `let`/`const`, scope chain reference
3. **this Binding** - determines value of `this`

```js
ExecutionContext = {
  LexicalEnvironment: { ... },
  VariableEnvironment: { ... },
  ThisBinding: value
}
```

## When Are These Components Created?

**All three components are created during the Creation/Memory Phase of the Execution Context**, not during the Execution Phase. However, the level of initialization varies:

### Creation Phase / Hosting Phase

During this phase, the JavaScript engine creates all three components of the Execution Context. Hoisting occurs as part of this process:

> ðŸ“– **For detailed hoisting coverage:** See [18. Hoisting](../18.%20Hoisting/) for comprehensive examples, hoisting types, and TDZ details.

1. **Variable Environment:**
   - `var` declarations are **hoisted** and **initialized** to `undefined`
   - `function` declarations are **hoisted** and **initialized** with their `full function body`
   - `arguments` object is created (in function execution contexts)

2. **Lexical Environment:**
   - `let` and `const` declarations are **hoisted** and **allocated but NOT initialized** (TDZ - Temporal Dead Zone)
   - Scope chain is set up by linking to the outer Lexical Environment
   - `class` declarations and `import` declarations are **allocated but NOT initialized** (in TDZ)

3. **this Binding:**
   - `this` binding is created and its value is **determined** (by how function is invoked, not where it's defined)
   - Global Context: `this` = global object (window/global)
   - Function Context: `this` = determined by how function is invoked
   - Arrow Functions: inherit `this` from enclosing scope (no own `this` binding created)

### Execution Phase

During this phase:

- Variables are assigned their actual values (from `undefined`/TDZ to actual values)
- Code executes line by line
- Functions are invoked (creating new execution contexts)

- **The components themselves are NOT created here** - they were already created in the Creation Phase

> ðŸ“– **For the complete lifecycle flow and call stack behavior, see [04. Execution Context Life Cycle and Call Stack](./04.%20Execution%20Context%20Life%20Cycle%20and%20Call%20Stack.md).**

**Key Point:** The structure of all three components exists before any code execution begins. Some bindings are fully initialized (var, functions, this), while others are only allocated (let/const in TDZ). The Execution Phase initializes TDZ variables and updates values, then executes statements.

## All the three Execution Context components in detail

### 1. Lexical Environment

- A structure that holds the environment record (variable bindings) and a reference to its outer environment.
- Stores variable bindings for `let`, `const`, `class`, and `import` declarations.
- Points to the Lexical Environment of the parent (outer) scope, forming a scope chain.
- Determines scope and enables closures.
- **Note:** Function declarations using function keyword are NOT stored hereâ€”they go in the Variable Environment.

### 2. Variable Environment

- It is the part of an execution context responsible for storing variables and function declarations during the creation phase.
- Specifically responsible for storing:
  - `var` declarations.
  - `function` declarations
  - `arguments` object (in function execution contexts)

Eg:

```js
function test(a) {
  var x = 10;
  function inner() {}
}
```

The Variable Environment (VE) inside test() will contain (after execution phase):

```sql
x: 10                    // After execution: was undefined during creation phase
inner: function reference  // Fully initialized during creation phase
arguments: { a: value }    // Created during creation phase

```

**Note:** During the Creation Phase, `x` would be `undefined`. The value `10` is assigned during the Execution Phase.

**Note:** According to the ECMAScript specification:

- `var` declarations and function declarations are stored in the **Variable Environment**
- `let` and `const` declarations are stored in the **Lexical Environment**

This separation is why `var` and function declarations are fully hoisted (available before their declaration line), while `let`/`const` are in the Temporal Dead Zone (TDZ) until their declaration line is reached.

### 3. this Binding

- Determines the value of `this` based on how a function is invoked.
- It refers to the object that is executing the current function.
- The binding of `this` depends on the execution context type:
  - `Global Context`: `this` refers to the global object (window in browsers or global in Node.js).
  - `Function Context`: Depends on the calling object (default is global object in non-strict mode, or undefined in strict mode).
  - `Arrow Functions`: Do not have their own `this`. They inherit `this` from the enclosing Lexical Environment.

<!-- Image: this Binding visualization -->

> ðŸ“– **Deep Dive:** See [05. this](./05.%20this.md) for detailed examples and interview traps.

## Complete Declaration Types and Their Storage

| Declaration Type                | Stored In            | Notes                                      |
| ------------------------------- | -------------------- | ------------------------------------------ |
| `var`                           | Variable Environment | Fully hoisted, initialized to `undefined`  |
| `let`                           | Lexical Environment  | Hoisted but in TDZ until declaration       |
| `const`                         | Lexical Environment  | Hoisted but in TDZ until declaration       |
| Function declarations           | Variable Environment | Fully hoisted with function body           |
| Function expressions            | Depends on variable  | Variable follows its declaration type      |
| Arrow functions                 | Depends on variable  | Variable follows its declaration type      |
| Class declarations              | Lexical Environment  | Hoisted but in TDZ (like `let`/`const`)    |
| Class expressions               | Depends on variable  | Variable follows its declaration type      |
| Function parameters             | Variable Environment | Behave like `var` declarations             |
| `import` declarations           | Lexical Environment  | Hoisted but in TDZ (like `const`)          |
| `arguments` object              | Variable Environment | Only in Function Execution Contexts        |
| Generator function declarations | Variable Environment | Fully hoisted (like function declarations) |
| Async function declarations     | Variable Environment | Fully hoisted (like function declarations) |

### Detailed Examples

**Function Expressions & Arrow Functions:**

```js
var funcExpr = function () {}; // funcExpr â†’ Variable Environment
let arrowFunc = () => {}; // arrowFunc â†’ Lexical Environment
const arrowFunc2 = () => {}; // arrowFunc2 â†’ Lexical Environment
```

**Class Declarations:**

```js
class MyClass {} // MyClass â†’ Lexical Environment (TDZ)
let MyClass2 = class {}; // MyClass2 â†’ Lexical Environment
var MyClass3 = class {}; // MyClass3 â†’ Variable Environment
```

**Function Parameters:**

```js
function test(a, b) {
  // a, b â†’ Variable Environment
  var x = 10; // x â†’ Variable Environment
}
```

**Import Declarations:**

```js
import { something } from "./module"; // something â†’ Lexical Environment (TDZ)
import * as utils from "./utils"; // utils â†’ Lexical Environment (TDZ)
```

### Key Principles

1. **Variable Environment** stores:
   - All `var` declarations (variables, function expressions assigned to `var`, class expressions assigned to `var`)
   - All function declarations (including async and generator functions)
   - Function parameters
   - `arguments` object (in function execution contexts)
   - **Behavior:** Fully hoisted and initialized (functions with body, `var` with `undefined`)

2. **Lexical Environment** stores:
   - All `let` and `const` declarations
   - Class declarations
   - `import` declarations
   - Function/arrow/class expressions assigned to `let`/`const`
   - **Behavior:** Hoisted but in Temporal Dead Zone (TDZ) until declaration line

3. **Rule of Thumb:**
   - If it's a **declaration** (not an expression), check the keyword:
     - `var` or `function` â†’ Variable Environment
     - `let`, `const`, `class`, `import` â†’ Lexical Environment
   - If it's an **expression** (function/arrow/class expression), follow the variable it's assigned to:
     - Assigned to `var` â†’ Variable Environment
     - Assigned to `let`/`const` â†’ Lexical Environment

### ðŸ”¥ Critical: Each Function Call Gets Its OWN Execution Context

This is the essence of how execution contexts work:

- Each function **call** creates a **new** execution context (with its own Variable Environment, Lexical Environment, and this Binding)
- Local variables are **not shared** between different calls to the same function
- This is why closures work â€” each closure captures its own execution context (both Variable Environment and Lexical Environment)

```javascript
function createLocker() {
  let secret = Math.random(); // Stored in Lexical Environment
  var count = 0; // Stored in Variable Environment
  return () => {
    count++; // Accesses Variable Environment
    return secret; // Accesses Lexical Environment
  };
}

const locker1 = createLocker(); // locker1 captures its own EC with secret = 0.123...
const locker2 = createLocker(); // locker2 captures its own EC with secret = 0.789...

console.log(locker1()); // 0.123... (accesses locker1's Lexical Environment)
console.log(locker2()); // 0.789... (accesses locker2's Lexical Environment - different!)
```

Think of it like lockers:

- `locker1` â†’ Locker #101 with its own key (captures its own execution context)
- `locker2` â†’ Locker #102 with its own key (captures its own execution context)
- Keys (closures) only unlock their own locker (access their own captured execution context)
