# Dynamic Scope vs Lexical Scope

> ðŸ“– **Parent Topic:** [01. Lexical Scope](./01. Lexical Scope.md)

## Lexical Scope (What JavaScript Uses)

- **Lexical scoping** (also called "static scoping") means the scope of a variable is determined by where it is **defined** in the source code.
- The scope is fixed at compile time based on the code structure.
- In JavaScript, our lexical scope (available data + variables where the function was defined) determines our available variables.

```javascript
function outer() {
  let x = 10;

  function inner() {
    console.log(x); // 10 - looks at where inner was DEFINED (inside outer)
  }

  return inner;
}

const fn = outer();
fn(); // 10 - still uses lexical scope from where it was defined
```

## Dynamic Scope (NOT Used in JavaScript)

- **Dynamic scoping** means the scope of a variable is determined by the **call stack** at runtime.
- The scope depends on where the function is **called**, not where it is defined.
- When a function is called, the interpreter looks for variables in the call chain. If a variable isn't found in the local scope, it looks in the scope of the **calling function**, and so on.

**Languages that use dynamic scoping:**

- Early versions of Lisp
- Bash/Shell scripts
- Some configurations in Emacs Lisp

### Hypothetical Dynamic Scoping Example

```javascript
// IF JavaScript used dynamic scoping (IT DOESN'T):
let x = 10;

function foo() {
  console.log(x); // Would look at call stack, not definition location
}

function bar() {
  let x = 20;
  foo(); // In dynamic scope, this would print 20 (caller's x)
}

bar(); // Actually prints 10 in JavaScript (lexical scope)
```

## Lexical vs Dynamic Scope Comparison

| Aspect         | Lexical Scope                 | Dynamic Scope                |
| -------------- | ----------------------------- | ---------------------------- |
| Determined by  | Where function is **defined** | Where function is **called** |
| When resolved  | Compile time                  | Runtime                      |
| Used by        | JavaScript, C, Java, Python   | Bash, some Lisp dialects     |
| Predictability | More predictable              | Less predictable             |

## Example: Why This Matters

```javascript
function sayMyName() {
  var a = "a";
  return function findName() {
    var b = "b";
    return function printName() {
      var c = "c";
      console.log(a, b, c); // Can access a, b, c due to lexical scope
      return "Andrei Neagoie";
    };
  };
}

sayMyName()()(); // Output: a b c "Andrei Neagoie"
```

In this example:

- `printName` can access `a`, `b`, and `c` because of lexical scoping
- Each nested function has access to variables from its outer (enclosing) functions
- This is determined by where the functions are **written**, not where they are called

## Key Takeaway

**JavaScript uses lexical scoping.** This means variable access is determined by the structure of your code (where functions are defined), not by the runtime call stack (where functions are called).
