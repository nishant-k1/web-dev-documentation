# Scope (Accessing Declarations)

A scope is just a "container of variables," NOT something that runs.

## JavaScript Lexical/Static Scoping Model and JavaScript Scope (Global, Module, Function, Block)

JS uses lexical (static) scoping, not dynamic.
In JavaScript, **scope** refers to the context in which variables, functions, and objects are **accessible or visible**.
Scope determines the **lifetime and visibility** of these constructs during the execution of a program.

## Types of Scope in JavaScript

JavaScript has one scoping model: **lexical/static scope**. Within that model, there are `four` main types of scopes:

1. Global Scope
2. Module Scope
3. Function Scope
4. Block Scope

**Note:** `Local Scope` is a terminology for combined `Function Scope` and `Block Scope`. Both can be called local scope.

---

## Lexical (Static) Scope

- Global Scope, Function Scope, Block Scope, and Module Scope are specific types of scopes that operate within the rules of lexical scope.
- In other words, these scopes are instances or subcategories of lexical scope, not the other way around.
- Lexical scope is the broader mechanism that governs how these specific scopes are structured and accessed.
- `Lexical Scope: variable names are resolved based on where functions and variables are defined in the source code, not where they are executed.`
- JavaScript uses lexical scoping, meaning the scope of a variable is determined by its location in the source code.
- Inner functions have access to variables in their outer functions. This access persists even after the outer function has finished executing ‚Äî a mechanism known as a **closure**.

### THE KEY DISTINCTION between Closure and Lexical Scope

- ‚úîÔ∏è **Lexical scope** ‚Üí inner function can access outer variables **WHILE** outer is still running
- ‚úîÔ∏è **Closure** ‚Üí inner function can access outer variables **EVEN AFTER** outer has finished
- Every closure uses lexical scope, but not every lexical scope produces a closure.

- The inner block has access to the variables declared in the outer function

```javascript
function outer() {
  let outerVar = "I am from outer";

  function inner() {
    console.log(outerVar); // Accessible due to lexical scoping
  }

  inner();
}

outer();
```

> üìñ **For detailed internal mechanisms:** See [11. Execution Context, Hoisting, Scope and Closures](<../11. Execution Context, Hoisting, Scope and Closures/>) for deep technical understanding of how JavaScript engine implements scope, hoisting, and closures.

### 1. Global Scope

- Variables declared in the Global Execution Context (outside of functions, blocks, or modules).
- `var` ‚Üí hoists to function scope (or global)
- These variables can be accessed from anywhere in the program.
- `Globally scoped` means the variable is accessible anywhere in your code, including inside functions or blocks. Both `var`, `let`, and `const` can behave this way when declared in the global scope.
- The term "`global scope`" differs from being `attached to the global object`:

  - `var` becomes globally scoped when declared in the top level of the script (not module) and gets attached to the window/global object.
  - `let` and `const` are also globally scoped when declared in the top level of the script (not module) but do not get attached to the window/global object, which makes them safer for modern JavaScript development.
  - `let` and `const` declared at the top level of a script (not module) do not create true global variables. They are scoped to the script and not global in the same way `var` is.
  - `let` and `const` declared at the top level of a script are not added to the global object (window in browsers), even though they are accessible throughout the script.

```javascript
var globalVar = "I am global";

function example() {
  console.log(globalVar); // Accessible
}

console.log(globalVar); // Accessible
```

### 2. Module Scope

- This isolation is enforced by the ES6 module system. Variables inside a module are not added to the global scope unless explicitly exported and imported.
- Variables declared in a module (using `import` / `export`) are scoped to that module and not accessible globally.
- If a variable is declared in a module and exported, it is still module-scoped, not global-scoped ‚Äî even though other modules can import it.
- In ES6 modules, variables declared at the top level of a module are in the module scope.
- They are only accessible within the module, not globally.
- This is achieved using `import` and `export`.
- Modules are always in strict mode, and top-level `this` is `undefined` (not window), further proving they're isolated.

```javascript
// module1.js
export const moduleVar = "I am module-scoped";

// module2.js
import { moduleVar } from "./module1.js";
console.log(moduleVar); // Accessible
```

### 3. Function Scope

- Function scope: Variables declared inside a function.
- `var` ‚Üí hoists to function scope (or global)
- Accessible variables: A function can access its own scope + outer scopes, thanks to lexical scoping. But only the variables declared inside a function are considered to be in that function's scope.
- **Parameters of a function belong to that function's scope. They are treated just like variables declared inside the function ‚Äî they are local to that function.**
- Variables declared with `var` inside a function are accessible only inside that function.
- Variables declared inside a function (using `var`, `let`, or `const`) are in the function scope.
- These variables are only accessible within that function.
- Variables declared outside a function are not part of the function's own scope, but the function can access them through the scope chain. So they are not in the function scope, but are accessible to the function via outer (or parent) scopes.

```javascript
function example() {
  var functionVar = "I am function-scoped";
  console.log(functionVar); // Accessible
}

console.log(functionVar); // Error: functionVar is not defined
```

### 4. Block Scope

- Variables declared with `let` or `const` inside a block (`{}`) are block-scoped.
- They are accessible only inside that block.
- `let`/`const` ‚Üí hoists to block scope (`{}`)

```javascript
{
  let blockVar = "I am block-scoped";
  const blockConst = "I am also block-scoped";
  console.log(blockVar); // Accessible
  console.log(blockConst); // Accessible
}

console.log(blockVar); // Error: blockVar is not defined
console.log(blockConst); // Error: blockConst is not defined
```

---

## Scope Chain

- Variables declared outside a function are not part of the function's own scope, but the function can access them through the scope chain. So they are not in the function scope, but are accessible to the function via outer (or parent) scopes.
- When a function executes, JavaScript looks for variables in this order:

  1. Local scope (inside the function)
  2. Parent (outer) scopes, one level up at a time
  3. Global scope

- When a variable is referenced, JavaScript looks for it in the current scope. If not found, it traverses up the scope chain to outer scopes until it reaches the global scope.
- The scope chain is established based on the lexical (code) structure, not the call stack.

### Example: Scope Chain

```javascript
let globalVar = "global";

function outer() {
  let outerVar = "outer";

  function inner() {
    let innerVar = "inner";
    console.log(innerVar); // Found in local scope
    console.log(outerVar); // Found in outer scope
    console.log(globalVar); // Found in global scope
  }

  inner();
}

outer();
```

## Dynamic Scope (Not in JavaScript)

- JavaScript does **not** use dynamic scoping (like some other languages).
- In dynamic scoping, variable resolution depends on the call stack (where the function was called from).
- JavaScript uses lexical scoping, where variable resolution depends on where the code was written.

### Comparison: Lexical vs Dynamic Scope

```javascript
let x = "global";

function outer() {
  let x = "outer";
  inner();
}

function inner() {
  console.log(x); // What does this print?
}

outer(); // Prints "global" (lexical scope)
// If JavaScript used dynamic scope, it would print "outer"
```

**In lexical scoping:** `inner()` looks for `x` where it was **defined** (global scope) ‚Üí "global"
**In dynamic scoping:** `inner()` would look for `x` where it was **called** from (outer scope) ‚Üí "outer"

## Accessing Declarations

### Rules for Accessing Variables

1. **Same Scope**: Variables can be accessed within their own scope
2. **Inner Scopes**: Inner scopes can access variables from outer scopes
3. **Outer Scopes**: Outer scopes cannot access variables from inner scopes
4. **Scope Chain**: JavaScript searches up the scope chain to find variables

### Examples

```javascript
// Global scope
let global = "I am global";

function outer() {
  // Function scope
  let outerVar = "I am in outer";

  function inner() {
    // Inner function scope
    let innerVar = "I am in inner";
    console.log(innerVar); // ‚úÖ Accessible (same scope)
    console.log(outerVar); // ‚úÖ Accessible (outer scope)
    console.log(global); // ‚úÖ Accessible (global scope)
  }

  inner();
  console.log(outerVar); // ‚úÖ Accessible (same scope)
  // console.log(innerVar); // ‚ùå Error: not accessible (inner scope)
}

outer();
// console.log(outerVar); // ‚ùå Error: not accessible (function scope)
```

## Important Notes

1. **Scope is determined at write-time**: Scope is based on where code is written, not where it's executed
2. **Lexical scoping**: JavaScript uses lexical (static) scoping, not dynamic scoping
3. **Scope chain**: Variables are searched up the scope chain until found or until global scope is reached
4. **Block scope**: `let` and `const` create block scope; `var` does not
5. **Module scope**: ES6 modules create their own isolated scope
6. **Function parameters**: Are part of the function's scope
