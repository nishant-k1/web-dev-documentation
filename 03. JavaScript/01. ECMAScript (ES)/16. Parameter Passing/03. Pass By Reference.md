# Pass By Reference

Pass by reference means a **reference** (pointer) to the object is passed to the function parameter. Changes to the object's properties affect the original object.

---

## What is Pass By Reference?

When you pass a non-primitive value to a function:

1. JavaScript passes a **reference** to the object (not a copy)
2. The parameter and original variable **point to the same object**
3. Changes to the object's properties **affect the original**
4. Reassigning the parameter **doesn't affect** the original variable

---

## Applies To

Pass by reference applies to **all non-primitive types**:

- `object`
- `array`
- `function`
- `Date`
- `RegExp`
- `Map`, `Set`, `WeakMap`, `WeakSet`
- Any custom objects

---

## Basic Example

```javascript
function modifyObject(obj) {
  obj.a = 42; // Modifies the original object
  console.log("Inside function:", obj); // { a: 42 }
}

let myObj = { a: 10 };
modifyObject(myObj);
console.log("Outside function:", myObj); // { a: 42 } (modified!)
```

**What happens:**

1. `myObj` points to an object in memory
2. Reference to that object is passed to `obj`
3. Both `myObj` and `obj` point to the **same object**
4. Changing `obj.a` modifies the shared object
5. `myObj.a` reflects the change

---

## Memory Model

```
Before function call:
myObj (variable) → [reference] → { a: 10 } (object in heap)

During function call:
myObj (variable) → [reference] ─┐
                                ├─→ { a: 10 } (same object)
obj (parameter)  → [reference] ┘

After modifying obj.a:
myObj (variable) → [reference] ─┐
                                ├─→ { a: 42 } (modified object)
obj (parameter)  → [reference] ┘
```

---

## Examples by Type

### Objects

```javascript
function updateUser(user) {
  user.name = "John Doe";
  user.age = 30;
}

let person = { name: "Jane", age: 25 };
updateUser(person);
console.log(person); // { name: "John Doe", age: 30 } (modified)
```

### Arrays

```javascript
function addItem(arr) {
  arr.push("new item");
  console.log("Inside:", arr); // [1, 2, 3, "new item"]
}

let numbers = [1, 2, 3];
addItem(numbers);
console.log("Outside:", numbers); // [1, 2, 3, "new item"] (modified)
```

### Nested Objects

```javascript
function updateNested(obj) {
  obj.user.profile.name = "Updated";
  obj.user.profile.age = 35;
}

let data = {
  user: {
    profile: { name: "Original", age: 25 },
  },
};

updateNested(data);
console.log(data.user.profile); // { name: "Updated", age: 35 } (modified)
```

---

## Important: Reassignment Doesn't Affect Original

**Key Point:** Reassigning the parameter breaks the reference link.

```javascript
function reassign(obj) {
  obj = { a: 100 }; // Reassignment - creates new object
  console.log("Inside:", obj); // { a: 100 }
}

let myObj = { a: 10 };
reassign(myObj);
console.log("Outside:", myObj); // { a: 10 } (unchanged!)
```

**Why?**

- `obj` initially points to the same object as `myObj`
- `obj = { a: 100 }` makes `obj` point to a **new object**
- `myObj` still points to the original object
- The original object is unchanged

---

## Memory Model: Reassignment

```
Before reassignment:
myObj → [ref1] ─┐
                ├─→ { a: 10 }
obj    → [ref1] ┘

After reassignment:
myObj → [ref1] → { a: 10 } (unchanged)
obj    → [ref2] → { a: 100 } (new object)
```

---

## Modifying vs Reassigning

### ✅ Modifying Properties (Affects Original)

```javascript
function modify(obj) {
  obj.property = "new value"; // Modifies original
}

let myObj = { property: "old value" };
modify(myObj);
console.log(myObj.property); // "new value" (modified)
```

### ❌ Reassigning Parameter (Doesn't Affect Original)

```javascript
function reassign(obj) {
  obj = { property: "new value" }; // Doesn't affect original
}

let myObj = { property: "old value" };
reassign(myObj);
console.log(myObj.property); // "old value" (unchanged)
```

---

## Array Mutations

### Mutating Methods (Affect Original)

```javascript
function mutateArray(arr) {
  arr.push(4); // Mutates original
  arr.pop(); // Mutates original
  arr.shift(); // Mutates original
  arr.unshift(0); // Mutates original
  arr.sort(); // Mutates original
  arr.reverse(); // Mutates original
  arr.splice(0, 1); // Mutates original
}

let numbers = [1, 2, 3];
mutateArray(numbers);
console.log(numbers); // Modified array
```

### Non-Mutating Methods (Don't Affect Original)

```javascript
function nonMutateArray(arr) {
  arr.map((x) => x * 2); // Returns new array
  arr.filter((x) => x > 0); // Returns new array
  arr.slice(); // Returns new array
  arr.concat([4]); // Returns new array
  // Original array unchanged
}

let numbers = [1, 2, 3];
nonMutateArray(numbers);
console.log(numbers); // [1, 2, 3] (unchanged)
```

---

## Common Patterns

### Pattern 1: Modifying Object Properties

```javascript
function updateConfig(config) {
  config.debug = true;
  config.version = "2.0";
}

let appConfig = { debug: false, version: "1.0" };
updateConfig(appConfig);
console.log(appConfig); // { debug: true, version: "2.0" }
```

### Pattern 2: Adding Properties

```javascript
function addProperty(obj) {
  obj.newProp = "value";
}

let myObj = {};
addProperty(myObj);
console.log(myObj.newProp); // "value"
```

### Pattern 3: Deleting Properties

```javascript
function removeProperty(obj) {
  delete obj.oldProp;
}

let myObj = { oldProp: "value", keepProp: "keep" };
removeProperty(myObj);
console.log(myObj); // { keepProp: "keep" }
```

---

## Why Non-Primitives Are Passed By Reference

Non-primitives are:

1. **Large** - Copying would be expensive
2. **Mutable** - Can be modified in place
3. **Stored in heap** - References are small pointers

Passing references is efficient and allows shared state.

---

## Common Misconceptions

### ❌ Misconception: "Reassigning affects original"

```javascript
// This doesn't work
function wrongReassign(obj) {
  obj = { new: "object" }; // Only affects local parameter
}

let original = { old: "object" };
wrongReassign(original);
console.log(original); // { old: "object" } (unchanged)
```

### ✅ Reality: Only property modifications affect original

```javascript
// This works
function correctModify(obj) {
  obj.property = "new value"; // Modifies shared object
}

let original = { property: "old value" };
correctModify(original);
console.log(original.property); // "new value" (modified)
```

---

## Interview Trap: Array Reassignment

```javascript
function replaceArray(arr) {
  arr = [4, 5, 6]; // Reassignment - doesn't affect original
}

let numbers = [1, 2, 3];
replaceArray(numbers);
console.log(numbers); // [1, 2, 3] (unchanged)

// But this works:
function modifyArray(arr) {
  arr[0] = 100; // Modification - affects original
}

let numbers2 = [1, 2, 3];
modifyArray(numbers2);
console.log(numbers2); // [100, 2, 3] (modified)
```

---

## Preventing Unintended Mutations

### Option 1: Create a Copy

```javascript
function safeModify(obj) {
  const copy = { ...obj }; // Shallow copy
  copy.property = "new value";
  return copy; // Return modified copy
}

let original = { property: "old value" };
let modified = safeModify(original);
console.log(original); // { property: "old value" } (unchanged)
console.log(modified); // { property: "new value" } (new object)
```

### Option 2: Use Immutable Patterns

```javascript
function immutableUpdate(obj) {
  return {
    ...obj,
    property: "new value", // New object with updated property
  };
}

let original = { property: "old value" };
let updated = immutableUpdate(original);
console.log(original); // { property: "old value" } (unchanged)
console.log(updated); // { property: "new value" } (new object)
```

---

## Best Practices

### ✅ Do

```javascript
// Document if function mutates
function mutateObject(obj) {
  // Modifies obj in place
  obj.updated = true;
}

// Or return new object
function createUpdated(obj) {
  return { ...obj, updated: true }; // Doesn't mutate
}
```

### ❌ Don't

```javascript
// Don't mutate without documenting
function surprise(obj) {
  obj.secret = "changed"; // Unexpected mutation
}

// Don't reassign and expect it to work
function wrong(obj) {
  obj = { new: "object" }; // Won't affect original
}
```

---

## Related Topics

- [2. Pass By Value.md](./2.%20Pass%20By%20Value.md) - How primitives are passed
- [4. Pass By Value of Reference.md](./4.%20Pass%20By%20Value%20of%20Reference.md) - Technical implementation
- [13. Copying](../13.%20Copying/) - How to copy objects
- [12. Comparing](../12.%20Comparing/) - How objects are compared
