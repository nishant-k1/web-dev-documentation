# Common Mistakes and Best Practices

This document covers common mistakes developers make with `this` binding and function invocation, along with best practices to avoid these pitfalls.

---

## Common Mistakes

### 1. Forgetting `new` with Constructors

**âŒ Mistake:**

```javascript
function Person(name) {
  this.name = name;
}

Person("John"); // Forgot 'new'
console.log(window.name); // "John" (pollutes global in non-strict)
```

**Problem:** Without `new`, `this` = `window`/`global`, creating global variables.

**âœ… Solution 1: Always use `new`**

```javascript
const person = new Person("John");
console.log(person.name); // "John"
```

**âœ… Solution 2: Use `new.target` check**

```javascript
function Person(name) {
  if (!new.target) {
    return new Person(name); // Auto-correct
  }
  this.name = name;
}

Person("John"); // Works - automatically uses new
```

**âœ… Solution 3: Use Classes (enforces `new`)**

```javascript
class Person {
  constructor(name) {
    this.name = name;
  }
}

// Person("John"); // TypeError: Must use new
const person = new Person("John"); // Required
```

---

### 2. Losing Context in Callbacks

**âŒ Mistake:**

```javascript
const obj = {
  name: "Object",
  process: function () {
    this.items.forEach(function (item) {
      console.log(this.name); // undefined (lost context)
    });
  },
};
```

**Problem:** Regular function callbacks lose `this` context.

**âœ… Solution 1: Arrow Function**

```javascript
this.items.forEach((item) => {
  console.log(this.name); // "Object" (lexical binding)
});
```

**âœ… Solution 2: Bind**

```javascript
this.items.forEach(
  function (item) {
    console.log(this.name);
  }.bind(this)
);
```

**âœ… Solution 3: thisArg Parameter**

```javascript
this.items.forEach(function (item) {
  console.log(this.name);
}, this); // Pass this as second argument
```

---

### 3. Losing Context in Event Handlers

**âŒ Mistake:**

```javascript
class Button {
  constructor(label) {
    this.label = label;
    button.addEventListener("click", this.handleClick);
  }

  handleClick() {
    console.log(this.label); // undefined (lost context)
  }
}
```

**Problem:** Method is detached when passed as callback.

**âœ… Solution 1: Bind in Constructor**

```javascript
constructor(label) {
  this.label = label;
  this.handleClick = this.handleClick.bind(this);
  button.addEventListener("click", this.handleClick);
}
```

**âœ… Solution 2: Arrow Function Class Field**

```javascript
handleClick = () => {
  console.log(this.label); // Preserves context
};

constructor(label) {
  this.label = label;
  button.addEventListener("click", this.handleClick);
}
```

---

### 4. Using Arrow Functions as Object Methods

**âŒ Mistake:**

```javascript
const obj = {
  name: "Object",
  method: () => {
    console.log(this.name); // undefined (this from outer scope)
  },
};

obj.method(); // undefined
```

**Problem:** Arrow functions don't bind to the object.

**âœ… Solution: Use Regular Function**

```javascript
const obj = {
  name: "Object",
  method: function () {
    console.log(this.name); // "Object"
  },
};

obj.method(); // "Object"
```

**Exception:** When you want `this` from outer scope:

```javascript
const outer = {
  name: "Outer",
  inner: {
    method: () => {
      console.log(this.name); // "Outer" (intentional)
    },
  },
};
```

---

### 5. Not Binding Class Methods

**âŒ Mistake:**

```javascript
class Component {
  constructor() {
    this.data = [];
  }

  process() {
    this.data.forEach(function (item) {
      this.transform(item); // Error: this is undefined
    });
  }

  transform(item) {
    return item * 2;
  }
}
```

**Problem:** Callback loses `this` context.

**âœ… Solution 1: Arrow Function**

```javascript
process() {
  this.data.forEach((item) => {
    this.transform(item); // Works
  });
}
```

**âœ… Solution 2: Bind Method**

```javascript
constructor() {
  this.data = [];
  this.process = this.process.bind(this);
}

process() {
  this.data.forEach(function(item) {
    this.transform(item); // Works (but process is already bound)
  });
}
```

---

### 6. Confusing Arrow and Regular Functions

**âŒ Mistake:**

```javascript
const obj = {
  items: [1, 2, 3],
  process: function () {
    return this.items.map(function (item) {
      return item * this.multiplier; // undefined
    });
  },
  multiplier: 10,
};
```

**Problem:** Regular function loses `this`.

**âœ… Solution: Use Arrow Function**

```javascript
process: function() {
  return this.items.map((item) => {
    return item * this.multiplier; // 10, 20, 30
  });
}
```

---

### 7. Not Understanding Binding Precedence

**âŒ Mistake:**

```javascript
function Test() {
  console.log(this.name);
}

const obj = { name: "Object" };
const bound = Test.bind(obj);

// Expecting obj, but...
new bound(); // undefined (new takes precedence)
```

**Problem:** Not understanding that `new` has highest precedence.

**âœ… Solution: Understand Precedence**

```javascript
// new > explicit > implicit > default
// new always wins
```

---

### 8. Using `call`/`apply`/`bind` on Arrow Functions

**âŒ Mistake:**

```javascript
const obj = { name: "Object" };
const arrow = () => {
  console.log(this.name);
};

arrow.call(obj); // undefined (ignored)
arrow.bind(obj)(); // undefined (ignored)
```

**Problem:** Arrow functions ignore explicit binding.

**âœ… Solution: Use Regular Function**

```javascript
const regular = function () {
  console.log(this.name);
};

regular.call(obj); // "Object"
```

---

### 9. Destructuring Methods

**âŒ Mistake:**

```javascript
const obj = {
  name: "Object",
  method: function () {
    return this.name;
  },
};

const { method } = obj;
method(); // undefined (lost context)
```

**Problem:** Destructuring detaches method from object.

**âœ… Solution 1: Bind**

```javascript
const { method } = obj;
const boundMethod = method.bind(obj);
boundMethod(); // "Object"
```

**âœ… Solution 2: Call on Object**

```javascript
obj.method(); // "Object" (keep method attached)
```

---

### 10. Not Handling Strict Mode

**âŒ Mistake:**

```javascript
function test() {
  console.log(this.name);
}

("use strict");
const obj = { name: "Object" };
const method = obj.test;
method(); // TypeError: Cannot read property 'name' of undefined
```

**Problem:** Strict mode makes `this` = `undefined`, causing errors.

**âœ… Solution: Always Bind or Use Arrow Functions**

```javascript
"use strict";
const obj = { name: "Object" };
const method = obj.test.bind(obj);
method(); // "Object"
```

---

## Best Practices

### 1. Always Use `===` for `this` Checks

**âœ… Best Practice:**

```javascript
if (this === undefined) {
  throw new Error("Method must be called on object");
}
```

**Why:** Prevents accidental global binding and makes errors obvious.

---

### 2. Use Arrow Functions for Callbacks

**âœ… Best Practice:**

```javascript
class DataProcessor {
  process(items) {
    // Arrow function preserves this
    return items.map((item) => {
      return this.transform(item);
    });
  }

  transform(item) {
    return item * 2;
  }
}
```

**Why:** Arrow functions automatically preserve `this` context.

---

### 3. Bind Class Methods in Constructor

**âœ… Best Practice:**

```javascript
class Component {
  constructor() {
    // Bind all methods that will be used as callbacks
    this.handleClick = this.handleClick.bind(this);
    this.handleSubmit = this.handleSubmit.bind(this);
  }

  handleClick() {
    // Always has correct this
  }
}
```

**Why:** Bind once in constructor, use everywhere.

---

### 4. Use Arrow Function Class Fields

**âœ… Best Practice:**

```javascript
class Button {
  handleClick = () => {
    // Automatically preserves this
    console.log(this.label);
  };
}
```

**Why:** Cleaner than binding, automatically preserves context.

---

### 5. Use Strict Mode

**âœ… Best Practice:**

```javascript
"use strict";

function test() {
  console.log(this); // undefined (fails fast)
}
```

**Why:** Prevents accidental global binding, makes bugs obvious.

---

### 6. Use ES6 Modules

**âœ… Best Practice:**

```javascript
// module.js (automatically strict)
export function myFunction() {
  console.log(this); // undefined (strict by default)
}
```

**Why:** Modules are automatically strict, prevents global pollution.

---

### 7. Prefer Classes Over Constructor Functions

**âœ… Best Practice:**

```javascript
// âœ… Good: Class
class Person {
  constructor(name) {
    this.name = name;
  }
}

// âŒ Avoid: Constructor function (easy to forget 'new')
function Person(name) {
  this.name = name;
}
```

**Why:** Classes enforce `new`, prevent accidental global binding.

---

### 8. Use `thisArg` When Available

**âœ… Best Practice:**

```javascript
const obj = { multiplier: 10 };

[1, 2, 3].forEach(function (item) {
  console.log(item * this.multiplier);
}, obj); // Pass thisArg
```

**Why:** Some array methods support `thisArg`, use it when available.

---

### 9. Document `this` Requirements

**âœ… Best Practice:**

```javascript
/**
 * Processes items. Must be called on DataProcessor instance.
 * @this {DataProcessor}
 */
process() {
  this.items.forEach(/* ... */);
}
```

**Why:** Makes `this` requirements clear to other developers.

---

### 10. Test Context Preservation

**âœ… Best Practice:**

```javascript
class Component {
  method() {
    // Test that this is preserved
    if (!(this instanceof Component)) {
      throw new Error("Method must be called on Component instance");
    }
    // ...
  }
}
```

**Why:** Fails fast if context is lost.

---

## Code Review Checklist

When reviewing code for `this` binding issues, check:

- [ ] Are constructors always called with `new`?
- [ ] Are callbacks using arrow functions or bind?
- [ ] Are class methods bound if used as callbacks?
- [ ] Are event handlers preserving context?
- [ ] Is strict mode enabled?
- [ ] Are arrow functions used appropriately (not as object methods)?
- [ ] Are methods that need `this` documented?
- [ ] Are there any destructured methods that lose context?
- [ ] Are promise chains preserving `this`?
- [ ] Are async functions handling `this` correctly?

---

## Summary

### Common Mistakes to Avoid

1. âŒ Forgetting `new` with constructors
2. âŒ Losing context in callbacks
3. âŒ Losing context in event handlers
4. âŒ Using arrow functions as object methods (usually)
5. âŒ Not binding class methods
6. âŒ Confusing arrow and regular functions
7. âŒ Not understanding binding precedence
8. âŒ Using `call`/`apply`/`bind` on arrow functions
9. âŒ Destructuring methods
10. âŒ Not handling strict mode

### Best Practices to Follow

1. âœ… Always use `new` with constructors (or use classes)
2. âœ… Use arrow functions for callbacks
3. âœ… Bind class methods in constructor
4. âœ… Use arrow function class fields
5. âœ… Use strict mode
6. âœ… Use ES6 modules
7. âœ… Prefer classes over constructor functions
8. âœ… Use `thisArg` when available
9. âœ… Document `this` requirements
10. âœ… Test context preservation

---

> ðŸ“– **Related Topics:**
>
> - [2. Understanding this Binding.md](./2.%20Understanding%20this%20Binding.md) - Overview
> - [8. this Binding Precedence.md](./8.%20this%20Binding%20Precedence.md) - Precedence rules
> - [16. Common Interview Questions.md](./15.%20Common%20Interview%20Questions.md) - Interview questions
