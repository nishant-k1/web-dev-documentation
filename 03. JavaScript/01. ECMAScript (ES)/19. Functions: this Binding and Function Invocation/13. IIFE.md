# IIFE (Immediately Invoked Function Expression)

An **IIFE** (Immediately Invoked Function Expression) is a function that is defined and executed immediately. It's a pattern used to create a new scope and avoid polluting the global namespace.

---

## What is an IIFE?

An IIFE is a function expression that is invoked immediately after it's defined. The syntax uses parentheses to make the function an expression, then immediately calls it.

### Basic Syntax

```javascript
(function () {
  // Code here
})();
```

Or with the alternative syntax:

```javascript
(function () {
  // Code here
})();
```

Both are equivalent and valid.

---

## Why Use IIFE?

### Problem: Global Scope Pollution

```javascript
// Without IIFE - pollutes global scope
var count = 0;
var name = "Global";

function increment() {
  count++;
}

increment();
console.log(window.count); // 0 (accessible globally)
```

### Solution: IIFE Creates Isolated Scope

```javascript
// With IIFE - isolated scope
(function () {
  var count = 0;
  var name = "Local";

  function increment() {
    count++;
  }

  increment();
})();

console.log(window.count); // undefined (not in global scope)
```

---

## How IIFE Works

### Function Declaration vs Function Expression

JavaScript distinguishes between function declarations and function expressions:

```javascript
// Function Declaration - hoisted, can't be called immediately
function test() {
  console.log("test");
}

// Function Expression - can be called immediately
var test = function () {
  console.log("test");
};
```

### Making a Function Expression

When you wrap a function in parentheses, JavaScript treats it as an expression:

```javascript
// This is a function expression (not declaration)
(function () {
  console.log("IIFE");
});

// Can be invoked immediately
(function () {
  console.log("IIFE");
})();
```

**Why parentheses work:**

- Parentheses create a grouping expression
- JavaScript sees `(function...)` as an expression, not a declaration
- Expressions can be invoked immediately

---

## Basic Patterns

### Pattern 1: Anonymous IIFE

```javascript
(function () {
  var private = "This is private";
  console.log(private);
})();

// private is not accessible outside
// console.log(private); // ReferenceError
```

### Pattern 2: Named IIFE

```javascript
(function myIIFE() {
  console.log("Named IIFE");
  // Can call itself recursively
  if (someCondition) {
    myIIFE(); // Recursive call
  }
})();
```

### Pattern 3: IIFE with Parameters

```javascript
(function (name, age) {
  console.log(`Name: ${name}, Age: ${age}`);
})("John", 30);
// Output: "Name: John, Age: 30"
```

### Pattern 4: IIFE Returning Value

```javascript
const result = (function () {
  var private = "secret";
  return {
    getPrivate: function () {
      return private;
    },
  };
})();

console.log(result.getPrivate()); // "secret"
console.log(result.private); // undefined
```

---

## Common Use Cases

### Use Case 1: Module Pattern

```javascript
const Calculator = (function () {
  // Private variables
  var result = 0;

  // Private functions
  function add(a, b) {
    return a + b;
  }

  // Public API
  return {
    calculate: function (a, b, operation) {
      if (operation === "add") {
        result = add(a, b);
      }
      return result;
    },
    getResult: function () {
      return result;
    },
  };
})();

Calculator.calculate(5, 3, "add");
console.log(Calculator.getResult()); // 8
// Calculator.result is not accessible (private)
```

### Use Case 2: Avoiding Variable Conflicts

```javascript
// Library 1
(function () {
  var $ = function (selector) {
    return document.querySelector(selector);
  };
  window.myLibrary = { $ };
})();

// Library 2 (different $)
(function () {
  var $ = function (element) {
    return element.textContent;
  };
  window.anotherLibrary = { $ };
})();

// Both can coexist without conflict
```

### Use Case 3: Loop Variable Capture (Legacy)

```javascript
// Problem: var in loop
for (var i = 0; i < 3; i++) {
  setTimeout(function () {
    console.log(i); // 3, 3, 3 (all share same i)
  }, 100);
}

// Solution: IIFE creates new scope for each iteration
for (var i = 0; i < 3; i++) {
  (function (j) {
    setTimeout(function () {
      console.log(j); // 0, 1, 2
    }, 100);
  })(i);
}

// Modern solution: Use let
for (let i = 0; i < 3; i++) {
  setTimeout(function () {
    console.log(i); // 0, 1, 2
  }, 100);
}
```

### Use Case 4: Initialization Code

```javascript
(function () {
  // Initialize application
  const config = loadConfig();
  setupRoutes();
  initializeDatabase();

  // All variables are scoped, won't pollute global
})();
```

---

## IIFE Variations

### Variation 1: Arrow Function IIFE

```javascript
(() => {
  console.log("Arrow IIFE");
})();
```

**Note:** Arrow functions can't be named, so no recursive calls.

### Variation 2: Unary Operators

```javascript
!(function () {
  console.log("IIFE with !");
})();

+(function () {
  console.log("IIFE with +");
})();

void (function () {
  console.log("IIFE with void");
})();
```

**Note:** These work but are less readable. Parentheses are preferred.

### Variation 3: Assignment Pattern

```javascript
var result = (function () {
  return "value";
})(); // Immediately invoked

console.log(result); // "value"
```

---

## IIFE and `this`

### `this` in IIFE

```javascript
(function () {
  console.log(this); // window/global (default binding)
})();

("use strict");
(function () {
  console.log(this); // undefined (strict mode)
})();
```

### Preserving `this` with IIFE

```javascript
const obj = {
  name: "Object",
  method: function () {
    (function () {
      console.log(this.name); // undefined (lost context)
    })();

    // Solution: Arrow function or bind
    (() => {
      console.log(this.name); // "Object" (lexical)
    })();
  },
};

obj.method();
```

---

## Modern Alternatives

### ES6 Modules (Preferred)

```javascript
// module.js
const private = "secret";

export function publicFunction() {
  return private;
}

// Automatically creates isolated scope
// No need for IIFE
```

### Block Scope (let/const)

```javascript
// Modern: Use block scope
{
  const private = "secret";
  // Variables are scoped to block
}

// Old: IIFE for scope
(function () {
  var private = "secret";
})();
```

### Class with Private Fields

```javascript
// Modern: Private fields
class Calculator {
  #result = 0; // Private field

  calculate(a, b) {
    this.#result = a + b;
  }

  getResult() {
    return this.#result;
  }
}

// Old: IIFE module pattern
const Calculator = (function () {
  var result = 0;
  return {
    calculate: function (a, b) {
      result = a + b;
    },
    getResult: function () {
      return result;
    },
  };
})();
```

---

## When to Use IIFE

### Still Useful For

1. **Legacy code** that needs to work in older browsers
2. **Scripts** that need to run immediately without modules
3. **Libraries** that need to avoid global pollution
4. **One-time initialization** code
5. **Creating closures** for private data (if not using classes)

### Modern Alternatives

1. **ES6 Modules** - Better isolation, tree-shaking
2. **Block scope** (`let`/`const`) - Simpler than IIFE
3. **Classes with private fields** - Better encapsulation
4. **Namespaces** - Object literals for organization

---

## Common Patterns

### Pattern 1: Revealing Module Pattern

```javascript
const Module = (function () {
  // Private
  var privateVar = "secret";

  function privateFunction() {
    return privateVar;
  }

  // Public API
  return {
    publicMethod: function () {
      return privateFunction();
    },
  };
})();
```

### Pattern 2: Namespace Pattern

```javascript
(function (namespace) {
  namespace.utils = {
    format: function (str) {
      return str.toUpperCase();
    },
  };
})((window.MyApp = window.MyApp || {}));
```

### Pattern 3: Dependency Injection

```javascript
(function ($, _) {
  // Use $ and _ safely
  // They're parameters, not global variables
  $(".element").hide();
  _.each([1, 2, 3], console.log);
})(jQuery, _);
```

---

## Best Practices

### 1. Use Modules When Possible

```javascript
// âœ… Modern: ES6 Modules
export function myFunction() {
  // Isolated scope automatically
}

// âŒ Legacy: IIFE
(function () {
  function myFunction() {
    // Manual isolation
  }
  window.myFunction = myFunction;
})();
```

### 2. Use Block Scope for Simple Cases

```javascript
// âœ… Modern: Block scope
{
  const temp = calculate();
  process(temp);
}

// âŒ Legacy: IIFE
(function () {
  var temp = calculate();
  process(temp);
})();
```

### 3. Use Classes for Encapsulation

```javascript
// âœ… Modern: Classes
class Calculator {
  #result = 0;
  calculate(a, b) {
    this.#result = a + b;
  }
}

// âŒ Legacy: IIFE Module
const Calculator = (function () {
  var result = 0;
  return {
    calculate: function (a, b) {
      result = a + b;
    },
  };
})();
```

---

## Summary

### Key Points

1. **IIFE** creates isolated scope immediately
2. **Prevents global pollution** by keeping variables private
3. **Legacy pattern** - still useful but modern alternatives exist
4. **Module pattern** uses IIFE for encapsulation
5. **Modern alternatives:** ES6 modules, block scope, classes

### Syntax

- `(function() {})()` - Standard syntax
- `(function() {}())` - Alternative syntax
- Both are equivalent

### Use Cases

- âœ… Creating private scope
- âœ… Module pattern
- âœ… Avoiding variable conflicts
- âœ… One-time initialization
- âœ… Legacy browser support

### Modern Alternatives

- âœ… ES6 modules (preferred)
- âœ… Block scope with `let`/`const`
- âœ… Classes with private fields
- âœ… Namespace objects

---

> ðŸ“– **Related Topics:**
>
> - [1. Function Invocation.md](./1.%20Function%20Invocation.md) - Function invocation types
> - [3. Default Binding.md](./3.%20Default%20Binding.md) - `this` in IIFE
> - [15. Modules & Module Loaders](../14.%20Modules%20&%20Module%20Loaders%20-%20Belongs%20to%20ECMAScript%20%7C%20Module%20Bundlers%20&%20Build%20-%20Tooling/) - Modern module alternative
