# Map, Set, WeakMap, and WeakSet - Complete Reference

Map, Set, WeakMap, and WeakSet are built-in JavaScript object types (collection objects) with specialized behavior and internal memory handling.

## ğŸ“Š Quick Comparison

| Type        | Key Type          | Value Type   | Iterable | Size Property | Weak References |
| ----------- | ----------------- | ------------ | -------- | ------------- | --------------- |
| **Map**     | Any type          | Any type     | âœ… Yes   | âœ… Yes        | âŒ No           |
| **Set**     | N/A (values only) | Any type     | âœ… Yes   | âœ… Yes        | âŒ No           |
| **WeakMap** | Objects only      | Any type     | âŒ No    | âŒ No         | âœ… Yes          |
| **WeakSet** | N/A (values only) | Objects only | âŒ No    | âŒ No         | âœ… Yes          |

---

## ğŸ—ºï¸ 1. Map

A collection of key-value pairs where **keys can be any type** (not just strings like objects).

### ğŸ”¹ Creation

```js
// Empty Map
const map = new Map();

// From array of [key, value] pairs
const map = new Map([
  ["name", "John"],
  [1, "one"],
  [true, "yes"],
]);

// From existing Map
const map2 = new Map(map);
```

### ğŸ”¹ Methods

| Method                | Description            | Returns                |
| --------------------- | ---------------------- | ---------------------- |
| `map.set(key, value)` | Sets value for key     | `Map` (chainable)      |
| `map.get(key)`        | Gets value for key     | `value` or `undefined` |
| `map.has(key)`        | Checks if key exists   | `boolean`              |
| `map.delete(key)`     | Removes key-value pair | `boolean`              |
| `map.clear()`         | Removes all entries    | `undefined`            |
| `map.size`            | Number of entries      | `number`               |

### ğŸ”¹ Iteration Methods

| Method            | Description                    | Returns       |
| ----------------- | ------------------------------ | ------------- |
| `map.keys()`      | Iterator of keys               | `MapIterator` |
| `map.values()`    | Iterator of values             | `MapIterator` |
| `map.entries()`   | Iterator of [key, value] pairs | `MapIterator` |
| `map.forEach(cb)` | Iterates over entries          | `undefined`   |

### Examples

```js
const map = new Map();

// Set values
map.set("name", "John");
map.set(1, "one");
map.set(true, "yes");
map.set({ id: 1 }, "object key"); // Object as key!

// Get values
map.get("name"); // 'John'
map.get("unknown"); // undefined

// Check existence
map.has("name"); // true
map.has("unknown"); // false

// Size
map.size; // 4

// Iteration
for (const [key, value] of map) {
  console.log(key, value);
}

map.forEach((value, key) => {
  console.log(key, value);
});

// Convert to array
Array.from(map.keys()); // ['name', 1, true, { id: 1 }]
Array.from(map.values()); // ['John', 'one', 'yes', 'object key']
Array.from(map.entries()); // [['name', 'John'], [1, 'one'], ...]
```

### ğŸ”¹ Map vs Object

| Feature           | Map                            | Object                     |
| ----------------- | ------------------------------ | -------------------------- |
| **Key Types**     | Any type                       | String or Symbol           |
| **Size**          | `map.size`                     | Must calculate manually    |
| **Iteration**     | Directly iterable              | Need `Object.keys()` etc.  |
| **Default Keys**  | No default keys                | Has prototype chain        |
| **Performance**   | Better for frequent add/delete | Better for frequent access |
| **Serialization** | Not JSON serializable          | JSON serializable          |
| **Use Case**      | Dynamic key-value collections  | Static structure           |

### Common Use Cases

```js
// 1. Counting occurrences
const countMap = new Map();
arr.forEach((item) => {
  countMap.set(item, (countMap.get(item) || 0) + 1);
});

// 2. Caching computed values
const cache = new Map();
function fibonacci(n) {
  if (cache.has(n)) return cache.get(n);
  const result = n <= 1 ? n : fibonacci(n - 1) + fibonacci(n - 2);
  cache.set(n, result);
  return result;
}

// 3. Storing metadata for objects
const metadata = new Map();
const user = { id: 1 };
metadata.set(user, { lastLogin: Date.now() });
metadata.get(user); // { lastLogin: ... }
```

---

## ğŸ¯ 2. Set

A collection of **unique values** (no duplicates allowed).

### ğŸ”¹ Creation

```js
// Empty Set
const set = new Set();

// From array (removes duplicates automatically)
const set = new Set([1, 2, 3, 2, 1]); // Set(3) {1, 2, 3}

// From string
const set = new Set("hello"); // Set(4) {'h', 'e', 'l', 'o'}
```

### ğŸ”¹ Methods

| Method              | Description            | Returns           |
| ------------------- | ---------------------- | ----------------- |
| `set.add(value)`    | Adds value to set      | `Set` (chainable) |
| `set.has(value)`    | Checks if value exists | `boolean`         |
| `set.delete(value)` | Removes value          | `boolean`         |
| `set.clear()`       | Removes all values     | `undefined`       |
| `set.size`          | Number of values       | `number`          |

### ğŸ”¹ Iteration Methods

| Method            | Description                      | Returns                      |
| ----------------- | -------------------------------- | ---------------------------- |
| `set.keys()`      | Iterator of values               | `SetIterator`                |
| `set.values()`    | Iterator of values               | `SetIterator` (same as keys) |
| `set.entries()`   | Iterator of [value, value] pairs | `SetIterator`                |
| `set.forEach(cb)` | Iterates over values             | `undefined`                  |

**Note:** `keys()` and `values()` return the same iterator for Sets (since Sets don't have separate keys).

### ğŸ”¹ Examples

```js
const set = new Set();

// Add values
set.add(1);
set.add(2);
set.add(1); // Duplicate, ignored
set.add("hello");
set.add({ id: 1 });

// Check existence
set.has(1); // true
set.has(3); // false

// Size
set.size; // 4 (only unique values)

// Iteration
for (const value of set) {
  console.log(value);
}

set.forEach((value) => {
  console.log(value);
});

// Convert to array
Array.from(set); // [1, 2, 'hello', { id: 1 }]
```

### ES2024 Set Methods â­ (New!)

These methods perform set operations and return new Sets:

| Method                           | Description                            | Returns   |
| -------------------------------- | -------------------------------------- | --------- |
| `set1.union(set2)`               | All elements from both sets            | `Set`     |
| `set1.intersection(set2)`        | Elements in both sets                  | `Set`     |
| `set1.difference(set2)`          | Elements in set1 but not in set2       | `Set`     |
| `set1.symmetricDifference(set2)` | Elements in either set, but not both   | `Set`     |
| `set1.isSubsetOf(set2)`          | Checks if set1 is subset of set2       | `boolean` |
| `set1.isSupersetOf(set2)`        | Checks if set1 is superset of set2     | `boolean` |
| `set1.isDisjointFrom(set2)`      | Checks if sets have no common elements | `boolean` |

```js
const set1 = new Set([1, 2, 3]);
const set2 = new Set([2, 3, 4]);

set1.union(set2); // Set(4) {1, 2, 3, 4}
set1.intersection(set2); // Set(2) {2, 3}
set1.difference(set2); // Set(1) {1}
set1.symmetricDifference(set2); // Set(2) {1, 4}
set1.isSubsetOf(set2); // false
set1.isSupersetOf(new Set([2])); // true
set1.isDisjointFrom(new Set([4, 5])); // true
```

### ğŸ”¹ Set vs Array

| Feature        | Set                   | Array          |
| -------------- | --------------------- | -------------- |
| **Duplicates** | Automatically removed | Allowed        |
| **Order**      | Insertion order       | Index-based    |
| **Access**     | Must iterate          | By index       |
| **Size**       | `set.size`            | `array.length` |
| **Methods**    | Fewer methods         | Many methods   |
| **Use Case**   | Unique values         | Ordered lists  |

### Common Use Cases

```js
// 1. Remove duplicates from array
const unique = [...new Set([1, 2, 2, 3, 3, 3])]; // [1, 2, 3]

// 2. Track visited items
const visited = new Set();
if (!visited.has(node)) {
  visited.add(node);
  // process node
}

// 3. Check membership efficiently
const allowedUsers = new Set(["user1", "user2", "user3"]);
if (allowedUsers.has(currentUser)) {
  // allow access
}
```

---

## ğŸ” 3. WeakMap

A Map where **keys must be objects** and entries are **weakly referenced** (eligible for garbage collection).

### ğŸ”¹ Key Characteristics

- Keys must be **objects** (not primitives)
- Keys are **weakly referenced** (can be garbage collected)
- **Not iterable** (no keys, values, entries, forEach)
- **No size property**
- Values are **strongly referenced**

### ğŸ”¹ Creation

```js
const weakMap = new WeakMap();

const obj1 = {};
const obj2 = { id: 1 };

weakMap.set(obj1, "value1");
weakMap.set(obj2, "value2");
```

### ğŸ”¹ Methods (Limited)

| Method                    | Description                     | Returns                |
| ------------------------- | ------------------------------- | ---------------------- |
| `weakMap.set(key, value)` | Sets value (key must be object) | `WeakMap`              |
| `weakMap.get(key)`        | Gets value                      | `value` or `undefined` |
| `weakMap.has(key)`        | Checks if key exists            | `boolean`              |
| `weakMap.delete(key)`     | Removes entry                   | `boolean`              |

**Note:** No `clear()`, `size`, or iteration methods!

### ğŸ”¹ Examples

```js
const weakMap = new WeakMap();

let obj = { id: 1 };
weakMap.set(obj, "metadata");

weakMap.get(obj); // 'metadata'
weakMap.has(obj); // true

// When obj is garbage collected, entry is removed automatically
obj = null; // Entry will be garbage collected
```

### ğŸ”¹ Use Cases

```js
// 1. Private data storage
const privateData = new WeakMap();

class User {
  constructor(name) {
    privateData.set(this, { name });
  }

  getName() {
    return privateData.get(this).name;
  }
}

// 2. Caching without preventing garbage collection
const cache = new WeakMap();
function processLargeObject(obj) {
  if (cache.has(obj)) return cache.get(obj);
  const result = /* expensive computation */;
  cache.set(obj, result);
  return result;
}
```

---

## ğŸ”“ 4. WeakSet

A Set where **values must be objects** and entries are **weakly referenced**.

### ğŸ”¹ Key Characteristics

- Values must be **objects** (not primitives)
- Values are **weakly referenced** (can be garbage collected)
- **Not iterable** (no keys, values, entries, forEach)
- **No size property**

### ğŸ”¹ Creation

```js
const weakSet = new WeakSet();

const obj1 = {};
const obj2 = { id: 1 };

weakSet.add(obj1);
weakSet.add(obj2);
```

### ğŸ”¹ Methods (Limited)

| Method                  | Description       | Returns   |
| ----------------------- | ----------------- | --------- |
| `weakSet.add(value)`    | Adds object value | `WeakSet` |
| `weakSet.has(value)`    | Checks if exists  | `boolean` |
| `weakSet.delete(value)` | Removes value     | `boolean` |

**Note:** No `clear()`, `size`, or iteration methods!

### ğŸ”¹ Examples

```js
const weakSet = new WeakSet();

let obj = { id: 1 };
weakSet.add(obj);

weakSet.has(obj); // true
weakSet.delete(obj); // true

// When obj is garbage collected, entry is removed
obj = null;
```

### ğŸ”¹ Use Cases

```js
// 1. Track object membership without preventing GC
const trackedObjects = new WeakSet();

function trackObject(obj) {
  trackedObjects.add(obj);
}

function isTracked(obj) {
  return trackedObjects.has(obj);
}

// 2. Prevent circular references
const visited = new WeakSet();
function traverse(obj) {
  if (visited.has(obj)) return; // Avoid circular ref
  visited.add(obj);
  // continue traversal
}
```

---

## ğŸ§  Interview Patterns

### ğŸ”¹ Map Patterns

```js
// 1. Frequency counting
function countFrequency(arr) {
  const map = new Map();
  arr.forEach((item) => {
    map.set(item, (map.get(item) || 0) + 1);
  });
  return map;
}

// 2. Grouping
function groupBy(arr, keyFn) {
  const map = new Map();
  arr.forEach((item) => {
    const key = keyFn(item);
    if (!map.has(key)) map.set(key, []);
    map.get(key).push(item);
  });
  return map;
}
```

### ğŸ”¹ Set Patterns

```js
// 1. Remove duplicates
const unique = [...new Set(array)];

// 2. Check for duplicates
function hasDuplicates(arr) {
  return new Set(arr).size !== arr.length;
}

// 3. Set operations (ES2024)
const union = set1.union(set2);
const intersection = set1.intersection(set2);
const difference = set1.difference(set2);
```

---

## ğŸ“Š When to Use Each

| Use Case                       | Recommended Type | Reason                          |
| ------------------------------ | ---------------- | ------------------------------- |
| Key-value pairs, any key type  | `Map`            | Flexible keys, better iteration |
| Simple object with string keys | `Object`         | JSON serializable, familiar     |
| Unique values                  | `Set`            | Automatic deduplication         |
| Ordered list with duplicates   | `Array`          | Index access, many methods      |
| Private data for objects       | `WeakMap`        | Garbage collection friendly     |
| Track object membership        | `WeakSet`        | Garbage collection friendly     |
| Set operations                 | `Set` (ES2024)   | Built-in union, intersection    |

---

## âœ… Quick Reference

### ğŸ”¹ Map

```js
const map = new Map([["key", "value"]]);
map.set(key, value);
map.get(key);
map.has(key);
map.delete(key);
map.size;
map.forEach((value, key) => {});
for (const [key, value] of map) {
}
```

### ğŸ”¹ Set

```js
const set = new Set([1, 2, 3]);
set.add(value);
set.has(value);
set.delete(value);
set.size;
set.forEach((value) => {});
for (const value of set) {
}
// ES2024
set.union(otherSet);
set.intersection(otherSet);
```

### ğŸ”¹ WeakMap / WeakSet

```js
const weakMap = new WeakMap();
weakMap.set(obj, value);
weakMap.get(obj);
weakMap.has(obj);
// No iteration, no size!
```

---

---

ğŸ’¡ **Interview Tips:**

- Know when to use Map vs Object (any keys, iteration, size)
- Know when to use Set vs Array (unique values, membership checks)
- Understand weak references (WeakMap/WeakSet for garbage collection)
- ES2024 Set methods are cutting-edge and may be asked about

| Type      | Keys allowed    | Iteration | Garbage-collected keys |
| --------- | --------------- | --------- | ---------------------- |
| `Object`  | String / Symbol | Yes       | âŒ                     |
| `Map`     | Any type        | Yes       | âŒ                     |
| `Set`     | Values only     | Yes       | âŒ                     |
| `WeakMap` | Objects only    | âŒ        | âœ…                     |
| `WeakSet` | Objects only    | âŒ        | âœ…                     |

One crucial distinction (interview favorite)

Map / Set â†’ strong references

WeakMap / WeakSet â†’ weak references (keys donâ€™t prevent GC)

Thatâ€™s why:

Weak collections canâ€™t be iterated

Theyâ€™re used for private data, caching, metadata

One-liner you can confidently say

Map, Set, WeakMap, and WeakSet are built-in collection objects in JavaScript, not plain objects, designed for specialized data storage and memory management.

If you want next:

Difference between Map vs Object with real use cases

Why WeakMap canâ€™t be looped

How structuredClone treats Map/Set but not WeakMap/WeakSet
