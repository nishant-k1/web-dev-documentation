# Non-Primitive Operations Overview

This document provides an overview of operations that apply to **non-primitive (reference) data types** in JavaScript.

---

## ğŸ“‹ Operations on Non-Primitives

Non-primitives support the following operations:

### 1. **Initialization**

Giving a variable its first value (reference to object/array/function).

**Examples:**

```js
let obj = {}; // Object
let arr = []; // Array
let func = function () {}; // Function
```

ğŸ“– **See:** [12. Initializations](../../12.%20Initializations/) for comprehensive initialization details

---

### 2. **Assignment**

Assigning references to variables.

**Examples:**

```js
let obj = { name: "John" }; // Initialization
obj = { name: "Jane" }; // Re-assignment (changes reference)
```

ğŸ“– **See:** [13. Assignments](../../13.%20Assignments/) for comprehensive assignment details

---

### 3. **Arithmetic Operations**

Operators work with non-primitives too.

**Examples:**

```js
let arr = [1, 2, 3];
let length = arr.length; // Property access
let exists = "name" in obj; // in operator
```

ğŸ“– **See:** [11. Operators](../../11.%20Operators/) for comprehensive operator details

---

### 4. **Comparing**

Comparing non-primitive values.

**Characteristics:**

- Non-primitives are compared by **reference**
- Two variables referring to different objects are never equal, even if content is identical
- Can perform shallow or deep comparison

**Examples:**

```js
let obj1 = { name: "John" };
let obj2 = { name: "John" };
console.log(obj1 === obj2); // false (different references)

let obj3 = obj1;
console.log(obj1 === obj3); // true (same reference)
```

ğŸ“– **See:**

- [14. Comparing - Reference Comparison](../../14.%20Comparing/03.%20Reference%20Comparison.md)
- [14. Comparing - Shallow Comparison](../../14.%20Comparing/04.%20Shallow%20Comparison.md)
- [14. Comparing - Deep Comparison](../../14.%20Comparing/05.%20Deep%20Comparison.md)

---

### 5. **Copying**

Copying non-primitive values.

**Characteristics:**

- By default, copying creates a **reference copy** (both variables point to same object)
- Can create **shallow copies** (top-level properties copied)
- Can create **deep copies** (nested structures also copied)

**Examples:**

```js
// Reference copy (default)
let obj1 = { name: "John" };
let obj2 = obj1; // Same reference
obj2.name = "Jane";
console.log(obj1.name); // "Jane" (both affected)

// Shallow copy
let obj3 = { ...obj1 }; // New object
obj3.name = "Bob";
console.log(obj1.name); // "Jane" (original unchanged)
```

ğŸ“– **See:**

- [15. Copying - Reference Copy](../../15.%20Copying/03.%20Reference%20Copy.md)
- [15. Copying - Shallow Copy](../../15.%20Copying/04.%20Shallow%20Copy.md)
- [15. Copying - Deep Copy](../../15.%20Copying/05.%20Deep%20Copy.md)

---

### 6. **Mutation** â­

Changing the contents of objects/arrays without changing the reference.

**Characteristics:**

- Changes the internal properties/elements of the object
- The reference stays the same
- Only applies to non-primitives (primitives are immutable)
- Critical concept for React, Redux, and modern JavaScript development

**Examples:**

```js
let arr = [1, 2, 3];
arr.push(4); // Mutation: array contents changed, reference same
console.log(arr); // [1, 2, 3, 4]

let obj = { name: "John" };
obj.age = 30; // Mutation: object properties changed, reference same
```

ğŸ“– **See:** [16. Mutation](../../16.%20Mutation/) â­ - Comprehensive mutation guide including:

- Mutation vs re-assignment
- Ways to prevent mutation
- React/Redux patterns
- Common pitfalls

---

## ğŸ”‘ Key Characteristics of Non-Primitive Operations

### **Mutability**

- âœ… Non-primitives are **mutable**
- âœ… Contents can be changed without changing reference
- âœ… Operations can modify the object/array directly

### **Storage**

- âœ… Stored **by reference** in heap memory
- âœ… Variables hold pointers to memory locations
- âœ… Dynamic size

### **Comparison**

- âœ… Compared **by reference**, not by value
- âœ… Two objects with identical content are not equal if they're different objects
- âœ… Need shallow/deep comparison to compare contents

### **Copying**

- âœ… Default copying is **by reference** (shared reference)
- âœ… Need explicit shallow/deep copy for independence
- âœ… Changes to copy can affect original (if reference copy)

### **Mutation**

- âœ… Can mutate (change contents)
- âœ… Critical for understanding React/Redux patterns
- âœ… Need to prevent mutation in many modern development scenarios

---

## ğŸ”„ Operations Overview

| Operation          | How It Works                               | Applies To                                  |
| ------------------ | ------------------------------------------ | ------------------------------------------- |
| **Initialization** | First assignment of reference              | âœ… All non-primitives                       |
| **Assignment**     | Re-assigning references                    | âœ… All non-primitives                       |
| **Operators**      | Various operators work with non-primitives | âœ… All non-primitives                       |
| **Comparing**      | Reference comparison (or shallow/deep)     | âœ… All non-primitives                       |
| **Copying**        | Reference copy (or shallow/deep copy)      | âœ… All non-primitives                       |
| **Mutation**       | Changing contents                          | âœ… Objects, Arrays, Functions, Date, RegExp |

---

## âš ï¸ Important Concepts

### **Mutation vs Re-assignment**

- **Mutation:** Changes contents, keeps same reference
  ```js
  arr.push(4); // Mutation
  ```
- **Re-assignment:** Changes reference to point to different object
  ```js
  arr = [4, 5]; // Re-assignment
  ```

ğŸ“– **See:** [16. Mutation - Mutation vs Re-assignment](../../16.%20Mutation/02.%20Mutation%20vs%20Re-assignment.md)

### **Preventing Mutation**

For React, Redux, and functional programming, you often need to avoid mutation:

- Use shallow/deep copies
- Use `Object.freeze()`
- Use immutable libraries (Immer, Immutable.js)

ğŸ“– **See:** [16. Mutation - Preventing Mutation](../../16.%20Mutation/03.%20Preventing%20Mutation.md)

---

## ğŸ“š Related Topics

For detailed information on specific operations, see:

- ğŸ“– [11. Operators](../../11.%20Operators/) - All operators
- ğŸ“– [12. Initializations](../../12.%20Initializations/) - Initialization details
- ğŸ“– [13. Assignments](../../13.%20Assignments/) - Assignment details
- ğŸ“– [14. Comparing](../../14.%20Comparing/) - Comparison methods (reference, shallow, deep)
- ğŸ“– [15. Copying](../../15.%20Copying/) - Copying methods (reference, shallow, deep)
- ğŸ“– [16. Mutation](../../16.%20Mutation/) â­ - Comprehensive mutation guide
- ğŸ“– [04. Data Types - Non-Primitives](./02.%20Non-Primitives.md) - Non-primitive types overview

---

## ğŸ’¡ Quick Reference

```js
// All these operations work with non-primitives
let obj = { name: "John" }; // Initialization
obj = { name: "Jane" }; // Re-assignment
let hasName = "name" in obj; // Operators (in)
let same = obj1 === obj2; // Comparing (by reference)
let copy = { ...obj }; // Copying (shallow copy)
obj.age = 30; // Mutation (changes contents)
```
