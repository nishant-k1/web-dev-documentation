# Non-Primitive Types

## All Non-primitives/Object Types

- **Object**:
  - A collection of key-value pairs (e.g., { name: "Alice", age: 25 }).
  - Special Object Types
    - **Map** : A collection of key-value pairs where **keys can be any type** (not just strings like objects).
    - **Set**: A collection of **unique values** (no duplicates allowed).
    - **WeakMap**: A Map where **keys must be objects** and entries are **weakly referenced** (eligible for garbage collection).
    - **WeakSet**: A Set where **values must be objects** and entries are **weakly referenced**.
- **Array**: A special type of object used to store ordered collections (e.g., [1, 2, 3, 4]).
- **Function**: A block of code designed to perform a particular task (e.g., function add(a, b) { return a + b; }).
- **Date**: Represents dates and times (e.g., new Date()).
- **RegExp**: Represents regular expressions (e.g., /^[a-z]+$/).

## Characteristics of Non-primitives Data Types

1. `Mutability`:
   - Non-Primitive values can be modified.
   - Changes to one reference will affect all other references pointing to the same object.

2. `Storage:`
   - Stored by Reference
   - Non-primitives are stored in the heap memory.
   - variables hold a reference (or pointer) to the memory location where the actual value resides.

3. `Equality/Comparing`:
   - Non-primitives are `compared by reference`, not by their value.
   - Two variables referring to different objects are never equal, even if the objects have identical content.

   ```Javascript
   let obj1 = { name: "Nishant" };
   let obj2 = { name: "Nishant" };
   console.log(obj1 === obj2); // Output: false (different references)

   let obj3 = obj1;
   console.log(obj1 === obj3); // Output: true (same reference)

   ```

4. `Copying`:
   - When assigning or passing a non-primitive, only the reference is copied, not the actual value.
   - Copying a non-primitive creates a reference to the original data unless explicitly cloned.
   - Deep cloning requires special handling like using `JSON.parse(JSON.stringify())` or predefined function, `const copy = structuredClone(original);`.

   ```Javascript
   let original = { a: 1 };
   let copy = original; // Reference to the same object
   copy.a = 2;
   console.log(original.a); // Output: 2 (original is affected)

   let deepCopy = JSON.parse(JSON.stringify(original)); // Deep clone
   deepCopy.a = 3;
   console.log(original.a); // Output: 2 (original is unaffected)
   ```

   ```js
   const original = {
     date: new Date(),
     map: new Map([["a", 1]]),
     set: new Set([1, 2, 3]),
     nested: { x: 10 },
   };

   const copy = structuredClone(original);

   copy.nested.x = 99;

   console.log(original.nested.x); // 10 âœ… (no shared reference)
   ```

5. `Dynamic in Size`
   Non-primitives (e.g., objects and arrays) can dynamically grow or shrink in size

6. `Can Have Methods and Properties`:
   - Non-primitives can have methods and properties, enabling complex data structures and behavior encapsulation.

7. `Type Check with typeof`: Non-Primitive types can be identified using the typeof operator.

8. `Use typeof as "object"`
   The typeof operator returns "object" for non-primitives, except for functions which return "function".

9. `Versatility`
   Non-primitives allow complex data structures and encapsulation, supporting key programming paradigms like object-oriented programming (OOP).
