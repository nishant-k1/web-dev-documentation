# Conditions: Inner Function Outlives Outer Function

> ðŸ“– **Parent Topic:** [05. Lexical Scope](./05.%20Lexical%20Scope.md) | [05.4. Closures](./05.4.%20Closures.md)

## All the conditions under which an inner function OUTLIVES the outer function (therefore creating a closure)

1. The outer function RETURNS the inner function

   ```js
   function outer() {
     let x = 10;
     return function inner() {
       console.log(x);
     };
   }
   ```

   This creates a closure because inner is still alive after outer is finished.

2. The inner function is PASSED to another function that stores it

   ```js
   function outer() {
     let x = 10;
     setTimeout(function inner() {
       console.log(x);
     }, 1000);
   }
   ```

   The callback is stored by setTimeout.
   Outer finishes, but inner survives.

3. The inner function is assigned to a variable OUTSIDE the outer function

   ```js
   let fn;

   function outer() {
     let x = 10;
     fn = function inner() {
       console.log(x);
     };
   }
   ```

   Now fn survives longer than outer.

4. The inner function is pushed into an array or object in outer scope

   ```js
   const arr = [];

   function outer() {
     let x = 10;
     arr.push(function inner() {
       console.log(x);
     });
   }
   ```

   Stored â†’ outlives outer â†’ closure.

5. The inner function is used as an event handler

   ```js
   function outer() {
     let x = 10;
     button.addEventListener("click", function inner() {
       console.log(x);
     });
   }
   ```

   Stored by DOM event system â†’ outlives outer.

6. The inner function is saved in a Promise or async callback

   ```js
   function outer() {
     let y = 20;
     fetch("/data").then(function inner() {
       console.log(y);
     });
   }
   ```

   Stored by Promise system â†’ outlives outer â†’ closure.

7. The inner function is captured by REACT as a callback prop

   ```js
   function Parent() {
     const name = "Nishant";

     return <Child onClick={() => console.log(name)} />;
   }
   ```

   The arrow function is stored inside Child.
   Parent re-runs, but old callback still exists.

8. The inner function is used inside useEffect callback

   ```js
   useEffect(() => {
     console.log(count); // closure
   }, []);
   ```

   React stores this callback and runs it later.

9. The inner function is used in useCallback or useMemo

   ```js
   const handle = useCallback(() => console.log(value), []);
   ```

   React stores the function instance â†’ closure.

10. The inner function is stored in a ref

    ```js
    const ref = useRef();

    function outer() {
      let x = 10;
      ref.current = function inner() {
        console.log(x);
      };
    }
    ```

    Stored â†’ survives â†’ closure.

11. The inner function is used inside a library that holds it

    ```js
    socket.on("message", () => console.log(user));
    ```

    Stored â†’ outlives outer â†’ closure.

12. The inner function becomes a callback in ANY async API

    ```js
    Timers, promises, async, events, workers.
    ```

    Any API that executes it later â†’ closure.

13. The inner function is executed later because outer returns a promise

    ```js
    async function outer() {
      let x = 10;
      await fetch(...);
      console.log(x); // closure
    }
    ```

    Because the function resumes AFTER outerâ€™s synchronous part completed, using stored state.

**THE ESSENCE OF ALL 13 CASES**

They all boil down to ONE rule:
If the inner function is reachable anywhere after the outer function finishes, then a closure MUST be created.
Any of these count:

- Stored
- Returned
- Passed
- Queued
- Scheduled
- Saved
- Registered
- Delayed
- Memoized
- Subscribed
- Assigned

Retained by JS engine or external API

If it survives â†’ closure.
