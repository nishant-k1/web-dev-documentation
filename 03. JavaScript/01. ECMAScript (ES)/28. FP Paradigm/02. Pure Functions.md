# FP Core Principles: Pure Functions

A function is pure if it satisfies two conditions:

1. **Deterministic**: It always produces the same output for the same input.
2. **No side effects**: It does not modify or depend on state outside its scope, nor does it interact with the external environment in a way that affects or is affected by external state.

---

## Side Effects

A function is said to have a side effect if it modifies or interacts with anything outside its own local scope (Function Scope). Side effects aren't just about modifying variables — they can also include interacting with the outside world.

A side effect is anything a function does that affects the outside world or is affected by it. A side effect is when a function reads from or writes to anything outside its local scope, such as: Global/Window variables, DOM, browser APIs, I/O operations, or time/random-based utilities.

When a function has side effects then it is no more a pure function.

### Examples of Side Effects

- Modifying variables outside the function (including global or closure scope)
- Modifies a declaration outside its Function Scope
- Changing a global/window variable
- Modifying a DOM element (part of the window object)
- Writing to a file or logging to the console (console is part of the window object)
- Making API calls (Part of the fetch which is again a method of window)
- Using random values or current time (`Math.random()`, `Date.now()`) (Math object and Date object are certainly outside the Function Scope of our function)
- If a function modifies its parameters, especially if they are objects or arrays passed by reference, it is considered a side effect — and the function is NOT pure. Even though the parameter is local to the function, modifying it affects the original object outside, because objects and arrays in JavaScript are passed by reference.

### A Side Effect Occurs When a Function

- Modifies state outside its local scope (e.g., a global variable).
- Interacts with the external environment (e.g., console output, DOM manipulation, file system, network requests). `Here external environment refers to the Web APIs in the BRE.`
- The act of logging changes the state of the console (it adds output to the console's history), which is observable outside the function.
- Depends on external state that may change (e.g., reading a global variable that could be modified elsewhere).
- Produces non-deterministic results (e.g., using `Math.random()`).

### Example 1: Side Effect

```javascript
const array = [1, 2, 3];
// below function has side effect. mutateArray is modifying the array that lives outside of this function
function mutateArray(arr) {
  arr.pop();
}
mutateArray(array);
console.log(array);
```

### Example 2: Side Effect

```javascript
function someFun(arr) {
  console.log("hi"); // logging in the browser console is a side effect.
}
someFun();
```

---

## No Side Effects

### Example 1: No Side Effect

```javascript
const array = [1, 2, 3];
// below function has no side effect. removeLastItem is not modifying anything that lives outside of this function. It is modifying newArray that lives inside of this function.
function removeLastItem(arr) {
  const newArray = [].concat(arr); // creating new copy of the array instead of pointing to the same memory location.
  newArray.pop();
  return newArray;
}
removeLastItem(array);
console.log(array);
```

### Example 2: No Side Effect

```javascript
const array = [1, 2, 3];
// below function has no side effect. removeLastItem is not modifying anything that lives outside of this function. It is modifying newArray that lives inside of this function.
function removeLastItem(arr) {
  const newArray = [].concat(arr); // creating new copy of the array instead of pointing to the same memory location.
  newArray.pop();
  return newArray;
}

function multiplyBy2(arr) {
  return arr.map((item) => item * 2);
}
console.log(removeLastItem(array));
console.log(multiplyBy2(array));
console.log(array);
```

---

## Pure Functions

- A pure function can modify variables declared within its local scope.
- A pure function can NOT modify variables declared outside its local scope.
- A function is a pure function if:
  1. It doesn't depend on or alter external state.
     A pure function's output is determined solely by its input arguments.
     It does not rely on:
     - Variables outside the function's local scope.
     - Any global or external state
  2. A pure function always produces the same output given the same input.

---

## Pure Functions in Redux

- Reducers are pure functions in Redux.
- We use the spread operator to create a shallow copy of the state object, and then make changes to that copy — instead of modifying the original — to keep the reducer pure.
- Instead of modifying the actual state object we create a shallow clone of it using spread operator and then modify it to keep the reducer function pure.

### Why Not Deep Copy in Reducers?

- **Performance**: Deep copying is slow, especially for large or deeply nested state trees.
- **Redux is designed to be fast and predictable**, so deep copying every time would introduce unnecessary overhead.
- **Shallow copy is enough to detect changes**. In the Redux state, only create clone of those nested objects which are supposed to be mutated. Keep the other references as it is. For each nested object clone can be created using the spread operator.

```js
const newState = { ...state, user: { ...state.user, name: "Nishant" } };
// Only user and state references are changed.
// No need to deep copy everything else (like settings, posts, etc.).
```

---

## First-Class Functions

In JavaScript, functions are first-class citizens and function parameters are local variables.

```javascript
function someFun1(num1, num2) {
  return num1 + num2;
}

function someFun2(num) {
  return num * 2;
}
someFun1();
someFun2();
```

---

## Can Everything Be Pure?

- `console.log` is a side effect
- Input/output is a side effect (communicating with the outside world in any way which is what input/output is)
- Program cannot exist outside side effect.
- Without side effect we cannot interact with the browser.
- We can't have websites with just pure functions.
- Browsers have to make fetch calls, HTTP calls, we have to manipulate DOM which is not possible with pure functions.

- **The Goal of FP is not to make everything pure functions but the goal is to minimize side effects.**
- The idea behind FP is to organize your code in such a way that there is a specific part that has side effects so that when you have a bug you know right away to go to that spot because that's where the side effects are happening while rest of the code are pure functions and because they are pure we don't have to worry about them as much.
- Purity is more of a confidence level, it cannot be 100%.
- Side effects and impurity are not necessarily bad but the goal is to organize your code in a way that you isolate these side effects, these database calls, API calls, input, output to a certain location in your program, in your code so that your code becomes predictable and easier to debug.
- At the end of the day, we do have to have some sort of a global state to describe our application.
- In FP we want to build programs that are built with a bunch of very small, very reusable, predictable pure functions.

---

## Perfect Function in FP

- Should do 1 task
- Should have return statement
- Should be pure
- Should have no shared state
- Immutable state
- Composable
- Predictable

---

## FAQs

### How console.log Makes a Function Impure?

- `console` is a global object (`window.console` in browsers), and `console.log` writes to the console, which is an I/O operation outside the function's control.
- The act of logging changes the state of the console (it adds output to the console's history), which is observable outside the function.

### What's Safe Inside a Pure Function (like a Reducer)?

| Safe to Use? | Example                        | Why                              |
| ------------ | ------------------------------ | -------------------------------- |
| ✅ Yes       | `Object.assign()`              | Deterministic, no side effects   |
| ✅ Yes       | Spread operator (`...`)        | Pure copying                     |
| ✅ Yes       | `.map()`, `.filter()`          | No mutation, no side effects     |
| ✅ Yes       | Functions passed via arguments | Under control of calling context |

`Array.prototype.filter()` and `Array.prototype.map()` do not mutate the original array — they return a new array. So we can use those in reducers because it won't mutate the state or any nested state properties, instead it will return a new one. So purity of reducers remains intact.

---

## Idempotence

- The idea of idempotence is a function that always returns or does what we expect it to do.
- It's a little different from pure functions as it can still modify anything outside of itself.
- It is valuable in case of parallel and distributed computation because it makes our code predictable.

```javascript
// Eg1: Not idempotent
function notGood(num) {
  return Math.random();
}

// Eg2: Below function is not pure but idempotent
function notGood2(num) {
  console.log(num);
}
```

---

## Interview Points

- Pure functions are deterministic and have no side effects
- They make code predictable, testable, and easier to reason about
- Side effects include I/O operations, DOM manipulation, API calls, and modifying external state
- Redux reducers must be pure functions
- The goal of FP is to minimize side effects, not eliminate them completely
- Idempotence is related but different from purity
