# Object-Oriented Programming in React

While React is primarily functional, you can use OOP patterns in React applications.

---

## Class Components (Legacy - Not Recommended)

> ⚠️ **Note:** Class components are legacy. The React team recommends using functional components with hooks for all new code. Class components are only mentioned here for maintaining existing codebases.

React class components were the primary way to create components before hooks were introduced in React 16.8 (2019). They are now considered legacy:

```js
class Counter extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
  }

  increment = () => {
    this.setState({ count: this.state.count + 1 });
  };

  render() {
    return (
      <div>
        <p>Count: {this.state.count}</p>
        <button onClick={this.increment}>Increment</button>
      </div>
    );
  }
}
```

---

## Modern Approach: Functional Components

Modern React favors functional components with hooks:

```js
function Counter() {
  const [count, setCount] = useState(0);

  const increment = () => {
    setCount(count + 1);
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
}
```

---

## OOP Patterns in React

### 1. Service Classes

```js
class ApiService {
  constructor(baseURL) {
    this.baseURL = baseURL;
  }

  async get(endpoint) {
    const response = await fetch(`${this.baseURL}${endpoint}`);
    return response.json();
  }
}

// Usage in component
const apiService = new ApiService("https://api.example.com");
```

### 2. Utility Classes

```js
class FormValidator {
  static validateEmail(email) {
    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
  }

  static validateRequired(value) {
    return value.trim().length > 0;
  }
}
```

### 3. State Management with Classes

```js
class Store {
  constructor() {
    this.state = {};
    this.listeners = [];
  }

  setState(newState) {
    this.state = { ...this.state, ...newState };
    this.notify();
  }

  subscribe(listener) {
    this.listeners.push(listener);
  }

  notify() {
    this.listeners.forEach((listener) => listener(this.state));
  }
}
```

---

## When to Use OOP in React

- **Service layers**: API clients, data managers (✅ Recommended)
- **Utility classes**: Validators, formatters, calculators (✅ Recommended)
- **State management**: Custom stores, managers (⚠️ Consider hooks/context first)
- **Legacy code**: Maintaining existing class components (⚠️ Only for existing codebases)
- **React Components**: ❌ **Do NOT use class components** - Use functional components with hooks

---

## Best Practices

- Prefer functional components with hooks for UI
- Use OOP for business logic, services, and utilities
- Keep OOP patterns separate from React components when possible
- Consider TypeScript for better OOP support in React
