# OOP Patterns: Class Pattern

The **Class Pattern** is a modern (ES6+) way to implement object-oriented programming in JavaScript. It provides a cleaner and more familiar syntax for creating constructor functions and working with prototypes.

The Class Pattern in JavaScript is a syntactic combination of the Constructor Pattern and the Prototype Pattern, making object-oriented code more readable and structured.

---

## âœ… What is the Class Pattern?

> The Class Pattern uses the `class` keyword to define blueprints for creating objects with shared properties and methods, using inheritance and prototypes under the hood.

---

## ðŸ”§ Syntax:

```js
class User {
  constructor(name, role) {
    this.name = name;
    this.role = role;
  }

  greet() {
    console.log(`Hi, I'm ${this.name}, a ${this.role}.`);
  }
}

const user1 = new User("Nishant", "Engineer");
user1.greet(); // Hi, I'm Nishant, a Engineer.
```

---

## ðŸ” Key Characteristics

- Uses the `class` keyword (introduced in ES6)
- Includes a `constructor()` method to initialize instances
- Methods defined inside the class are added to the prototype (shared across instances)
- Can use `extends` and `super()` for inheritance
- Still uses `new` under the hood

---

## ðŸ§  What Happens Internally?

JavaScript classes are just **syntactic sugar** over constructor functions:

```js
class User {
  constructor(name) {
    this.name = name;
  }

  greet() {
    console.log("Hi " + this.name);
  }
}

// Is equivalent to:
function User(name) {
  this.name = name;
}

User.prototype.greet = function () {
  console.log("Hi " + this.name);
};
```

âœ… Methods are on `User.prototype`, not recreated per object.

---

## ðŸ§¬ Inheritance with Classes

```js
class Admin extends User {
  constructor(name, accessLevel) {
    super(name);
    this.accessLevel = accessLevel;
  }

  showAccess() {
    console.log(`${this.name} has ${this.accessLevel} access.`);
  }
}

const admin1 = new Admin("Aditi", "Full");
admin1.greet(); // Hi Aditi
admin1.showAccess(); // Aditi has Full access.
```

---

## ðŸ§ª Comparison: Class vs Constructor vs Factory

| Feature       | Class Pattern                 | Constructor Function     | Factory Function   |
| ------------- | ----------------------------- | ------------------------ | ------------------ |
| Uses `new`?   | âœ… Yes                        | âœ… Yes                   | âŒ No              |
| Syntax?       | Modern (`class`)              | Traditional (`function`) | Simple function    |
| Inheritance?  | âœ… `extends`, `super()`       | âœ… Manual via prototype  | âš ï¸ Custom/composed |
| Memory Usage  | âœ… Efficient (shared methods) | âœ… Efficient             | âš ï¸ More per-object |
| Private Data? | âœ… With `#privateFields`      | âŒ Not native            | âœ… Closures        |

---

## ðŸ”¥ Interview Talking Points

- "The class syntax is a modern way to use OOP in JS, built on top of prototypes."
- "It makes inheritance and method-sharing cleaner and more familiar for devs from Java/TypeScript backgrounds."
- "It supports inheritance with `extends` and initialization with `super()`."
- "It improves readability and maintainability for large applications."

---

## âœ… Pros

- Cleaner syntax
- Built-in inheritance support
- Methods on prototype â†’ memory efficient
- Easier onboarding for devs from OOP languages

## âŒ Cons

- Still uses prototypes under the hood (not a true class-based language)
- Doesn't prevent misuse of `this` unless using strict mode
- Can be overkill for simple objects (use factory functions instead)

---

## Object.create() vs Class

- Both are the same, class is just syntactic sugar to achieve prototypal inheritance.
- Modern/newer code bases with Object oriented principles use class
- We can use `Object.create()` instead of class to achieve the same. Also `Object.create()` makes more pure form Object oriented programming.

### Example: Using Object.create()

```js
// Object.create: code is DRY, also for each elf same memory location will get assigned for the attack method

const elfFunctions = {
  attack() {
    return "attack with " + this.weapon;
  },
};

function createElf(name, weapon) {
  let newElf = Object.create(elfFunctions);
  newElf.name = name;
  newElf.weapon = weapon;
  return newElf;
}

const peter = createElf("Peter", "Stones");
peter.attack();

const sam = createElf("sam", "fire");
sam.attack();
```

### Example: Using ES6 Classes

```js
// class: code is DRY, also for each elf same memory location will get assigned for the attack method

class Elf {
  constructor(name, weapon) {
    this.name = name;
    this.weapon = weapon;
  }
  attack() {
    return "attack with " + this.weapon;
  }
}

const peter = new Elf("Peter", "Stones");
peter.attack();

const sam = new Elf("sam", "fire");
sam.attack();
```

---

## ðŸ§µ Summary (1-liner):

> The Class Pattern in JS provides a clean, ES6+ syntax to create objects with shared methods using prototypes, supporting inheritance via `extends` and `super()`.
