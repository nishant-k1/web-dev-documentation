# Extending Errors (Custom Error Classes)

The `Error` constructor is a class that can be extended to create custom error types. This allows you to create specific error types for different scenarios in your application.

---

## Why Create Custom Errors?

- **Better error identification** - Know exactly what type of error occurred
- **Structured error handling** - Handle different errors differently
- **Additional context** - Add custom properties and methods
- **Type safety** - Use `instanceof` to check error types

---

## Basic Custom Error

```javascript
class AuthenticationError extends Error {
  constructor(message) {
    super(message);
    this.name = "AuthenticationError";
  }
}

const error = new AuthenticationError("Invalid credentials");
console.log(error instanceof AuthenticationError); // true
console.log(error instanceof Error); // true
```

---

## Custom Errors with Additional Properties

You can add custom properties to your error classes:

```javascript
class AuthenticationError extends Error {
  constructor(message, statusCode = 401) {
    super(message);
    this.name = "AuthenticationError";
    this.statusCode = statusCode;
    this.timestamp = new Date().toISOString();
  }
}

class DatabaseError extends Error {
  constructor(message, query) {
    super(message);
    this.name = "DatabaseError";
    this.query = query;
  }
}

class PermissionError extends Error {
  constructor(message, resource) {
    super(message);
    this.name = "PermissionError";
    this.resource = resource;
  }
}
```

---

## Using Custom Errors

```javascript
function authenticateUser(username, password) {
  if (!username || !password) {
    throw new AuthenticationError("Username and password required", 400);
  }

  if (password.length < 8) {
    throw new AuthenticationError("Password too short", 400);
  }

  // Authentication logic...
}

try {
  authenticateUser("user", "pass");
} catch (error) {
  if (error instanceof AuthenticationError) {
    console.log(`Auth error (${error.statusCode}): ${error.message}`);
  } else {
    console.log("Unknown error:", error);
  }
}
```

---

## Error Hierarchy

You can create an error hierarchy for better organization:

```javascript
// Base custom error
class AppError extends Error {
  constructor(message, statusCode = 500) {
    super(message);
    this.name = this.constructor.name;
    this.statusCode = statusCode;
    Error.captureStackTrace(this, this.constructor);
  }
}

// Specific error types
class ValidationError extends AppError {
  constructor(message, field) {
    super(message, 400);
    this.field = field;
  }
}

class NotFoundError extends AppError {
  constructor(resource) {
    super(`${resource} not found`, 404);
    this.resource = resource;
  }
}

class DatabaseError extends AppError {
  constructor(message, query) {
    super(message, 500);
    this.query = query;
  }
}
```

---

## Production Considerations

### ❌ Never Expose Sensitive Information

When running a server, **never expose**:

- Full stack traces to users
- Database connection strings
- Internal file paths
- System information

```javascript
// ❌ BAD - Exposes too much
app.use((err, req, res, next) => {
  res.status(500).json({ error: err.stack }); // Never do this!
});

// ✅ GOOD - User-friendly messages
app.use((err, req, res, next) => {
  if (err instanceof AppError) {
    res.status(err.statusCode).json({
      error: err.message,
      code: err.name,
    });
  } else {
    // Log full error internally
    console.error("Internal error:", err);
    // Send generic message to user
    res.status(500).json({
      error: "An internal error occurred",
    });
  }
});
```

### Error Logging

Always log full error details internally:

```javascript
function handleError(error, req, res) {
  // Log full error for debugging
  logger.error({
    error: error.message,
    stack: error.stack,
    url: req.url,
    method: req.method,
    timestamp: new Date(),
  });

  // Send safe message to user
  res.status(error.statusCode || 500).json({
    error: error.message || "An error occurred",
  });
}
```

---

## Best Practices

### ✅ Do

```javascript
// Use specific error types
throw new ValidationError("Email is required", "email");

// Check error types
if (error instanceof ValidationError) {
  // Handle validation errors
}

// Add useful context
class NetworkError extends Error {
  constructor(message, url, statusCode) {
    super(message);
    this.url = url;
    this.statusCode = statusCode;
  }
}
```

### ❌ Don't

```javascript
// Don't create too many error types
// Keep it simple and meaningful

// Don't expose internal details
throw new Error(`Database connection failed: ${connectionString}`); // Bad!
```

---

## Related Topics

- [7. Built-in Error Types.md](./7.%20Built-in%20Error%20Types.md) - Standard error types
- [9. Best Practices.md](./9.%20Best%20Practices.md) - Error handling patterns
- [11. Production Error Handling.md](./10.%20Production%20Error%20Handling.md) - Production strategies
