# Promise

> **Note:** `Promise` is a **built-in JavaScript object** (like `Array`, `String`, `Object`). While documented here under async handling for logical grouping with async concepts, it's also listed in [Standard Built-in Objects Overview](../../04.%20Data%20Types/11.%20Standard%20Built-in%20Objects%20Overview.md#-9-async-objects).

---

- Promises in JavaScript are used to handle asynchronous operations.
- Asynchronous operations are tasks that don't necessarily execute immediately or in a predictable order, like fetching data from a server or reading a file.
- Promises provide a cleaner and more manageable way to work with asynchronous code compared to traditional callback functions.

## What is a Promise?

A Promise is an object that represents the eventual completion or failure of an asynchronous operation and its resulting value. It has three states:

Pending: Initial state, neither fulfilled nor rejected.
Fulfilled: The operation completed successfully.
Rejected: The operation failed.

## How to Use a Promise

1. **Creating a Promise**
   You create a new Promise using the `new Promise()` constructor. It takes a function as an argument with two parameters: `resolve` and `reject`.

   ```Javascript
      const myPromise = new Promise((resolve, reject) => {
        // Perform an asynchronous operation
        // If successful, call resolve(value)
        // If an error occurs, call reject(error)
      });
   ```

   Eg:

   ```Javascript
    function fetchData() {
      return new Promise((resolve, reject) => {
          setTimeout(() => {
              resolve("Data received");
          }, 1000);
      });
    }
   ```

   <!-- now fetchData function when called will return a promise -->

2. **Handling a Promise**

   1. Using .then and .catch

      - Once a Promise is created, you can handle its result using .then() and .catch() methods
      - .then() takes a function as an argument with one parameter: result
      - .catch() takes a function as an argument with one parameter: error

      ```Javascript
          <!-- Creating fetchData promise -->

          function fetchData() {
              return new Promise((resolve, reject) => {
                  setTimeout(() => {
                      resolve("Data received");
                  }, 1000);
              });
          }

        <!-- Handling fetchData promise -->
          fetchData()
              .then(result => {
                  console.log(result); // Output: Data received
              })
              .catch(error => {
                  console.error(error);
              });
      ```

   2. Using async and await
      In the below code the function getData will remain blocked until await fetchData resolves and gives some value. i.e. await keyword pauses the execution of getData function until the fetchData promise gets resolved.

      Once fetchData promise gets resolved and returns a value only then the next line of code which is `console.log(result);` will get executed until then execution of getData function remains blocked but any function our tasks outside this getData function will continue executing.

      ```Javascript
          <!-- Creating fetchData promise -->
            function fetchData() {
              return new Promise((resolve, reject) => {
                  setTimeout(() => {
                        resolve("Data received");
                    }, 1000);
                });
              }

          <!-- Handling fetchData promise -->
            async function getData() {
              try {
                  const result = await fetchData();
                  console.log(result); // Output: Data received
              } catch (error) {
                  console.error(error);
              }
            }
      ```

   Differences and Best Practices:

   - Callbacks are prone to callback hell (nested callbacks), making code harder to read and maintain.
   - Promises alleviate callback hell and provide better error handling with .catch().
   - Async/await further improves code readability and maintainability, especially for complex asynchronous flows.
   - Prefer async/await over callbacks and promises when possible for cleaner asynchronous code.

---

## Promise Static Methods

These are **static methods** on the Promise constructor that help work with multiple promises. **Extremely important for interviews!**

### `Promise.all(promises)` ⭐⭐⭐⭐⭐

Waits for **all promises to resolve**, or rejects if **any promise rejects**.

**Returns:** Promise that resolves to array of results, or rejects with first rejection.

```javascript
const p1 = Promise.resolve(1);
const p2 = Promise.resolve(2);
const p3 = Promise.resolve(3);

Promise.all([p1, p2, p3])
  .then((values) => {
    console.log(values); // [1, 2, 3]
  })
  .catch((error) => {
    console.error(error); // If any promise rejects
  });

// If any promise rejects, entire Promise.all rejects immediately
const p4 = Promise.reject("Error");
Promise.all([p1, p2, p4])
  .then((values) => {
    // Won't execute
  })
  .catch((error) => {
    console.error(error); // "Error"
  });
```

**Use Cases:**

- Fetching multiple API endpoints in parallel
- Waiting for all operations to complete
- **Fail-fast behavior** - stops on first error

### `Promise.race(promises)` ⭐⭐⭐⭐⭐

Returns promise that resolves or rejects **as soon as the first promise settles**.

**Returns:** Promise that resolves/rejects with value from first settled promise.

```javascript
const p1 = new Promise((resolve) => setTimeout(() => resolve("First"), 1000));
const p2 = new Promise((resolve) => setTimeout(() => resolve("Second"), 500));

Promise.race([p1, p2]).then((value) => {
  console.log(value); // "Second" (faster)
});

// With rejection
const p3 = Promise.reject("Error");
Promise.race([p1, p3])
  .then((value) => {
    // Won't execute
  })
  .catch((error) => {
    console.error(error); // "Error" (first to settle)
  });
```

**Use Cases:**

- Timeout patterns
- First response wins scenarios
- Racing multiple data sources

### `Promise.allSettled(promises)` ⭐⭐⭐⭐ (ES2020)

Waits for **all promises to settle** (resolve or reject), **never rejects**.

**Returns:** Promise that resolves to array of objects with `status` and `value`/`reason`.

```javascript
const p1 = Promise.resolve(1);
const p2 = Promise.reject("Error");
const p3 = Promise.resolve(3);

Promise.allSettled([p1, p2, p3]).then((results) => {
  console.log(results);
  // [
  //   { status: 'fulfilled', value: 1 },
  //   { status: 'rejected', reason: 'Error' },
  //   { status: 'fulfilled', value: 3 }
  // ]
});
// Note: .catch() is never called - always resolves!
```

**Use Cases:**

- Need results from all promises, even if some fail
- Batch operations where partial success is acceptable
- **Doesn't fail-fast** - waits for all to complete

### `Promise.any(promises)` ⭐⭐⭐⭐ (ES2021)

Returns promise that resolves when **first promise resolves**, or rejects if **all promises reject**.

**Returns:** Promise that resolves with first successful value, or rejects with AggregateError if all fail.

```javascript
const p1 = Promise.reject("Error 1");
const p2 = new Promise((resolve) => setTimeout(() => resolve("Success"), 500));
const p3 = Promise.reject("Error 2");

Promise.any([p1, p2, p3]).then((value) => {
  console.log(value); // "Success" (first to resolve)
});

// If all reject
Promise.any([Promise.reject("Error 1"), Promise.reject("Error 2")])
  .then((value) => {
    // Won't execute
  })
  .catch((error) => {
    console.error(error); // AggregateError: All promises were rejected
    console.error(error.errors); // ["Error 1", "Error 2"]
  });
```

**Use Cases:**

- First success wins
- Fallback strategies
- Redundant data sources

### `Promise.resolve(value)` ⭐⭐⭐

Creates a resolved promise with the given value.

```javascript
Promise.resolve(42).then((value) => console.log(value)); // 42

// Equivalent to:
new Promise((resolve) => resolve(42));
```

**Use Cases:**

- Converting values to promises
- Starting promise chains

### `Promise.reject(reason)` ⭐⭐⭐

Creates a rejected promise with the given reason.

```javascript
Promise.reject("Error").catch((error) => console.error(error)); // "Error"

// Equivalent to:
new Promise((resolve, reject) => reject("Error"));
```

---

## Comparison: Promise.all vs Promise.race vs Promise.allSettled vs Promise.any

| Method                 | Behavior         | Rejects When              | Use Case           |
| ---------------------- | ---------------- | ------------------------- | ------------------ |
| **Promise.all**        | Waits for all    | **Any promise rejects**   | All must succeed   |
| **Promise.race**       | First to settle  | **First promise rejects** | First result wins  |
| **Promise.allSettled** | Waits for all    | **Never rejects**         | Need all results   |
| **Promise.any**        | First to resolve | **All promises reject**   | First success wins |

---

## Interview Common Questions

### Q: Difference between Promise.all and Promise.race?

**Promise.all:**

- Waits for ALL promises to resolve
- Rejects if ANY promise rejects (fail-fast)
- Returns array of all results

**Promise.race:**

- Returns first promise to settle (resolve OR reject)
- Doesn't wait for others
- Returns value from first settled promise

### Q: When to use Promise.allSettled?

When you need results from all promises regardless of failures. Unlike Promise.all, it doesn't fail-fast.

### Q: What does Promise.race([]) return?

A promise that **stays pending forever** (no promises to race).

### Q: Implement a timeout pattern using Promise.race?

```javascript
function withTimeout(promise, timeoutMs) {
  const timeout = new Promise((_, reject) =>
    setTimeout(() => reject(new Error("Timeout")), timeoutMs)
  );
  return Promise.race([promise, timeout]);
}
```
