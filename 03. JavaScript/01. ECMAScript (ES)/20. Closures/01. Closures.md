# Closures

> üìñ **Parent Topic:** [01. Lexical Scope](../19. Scope/01. Lexical Scope.md)

- A closure is created when a function, using lexical scope, "remembers" those variables even after the outer scope is gone.
- A closure is created ANY TIME a function is defined inside another function ‚Äî whether or not it is returned.

**‚ùå Misconception:** "Closure requires the inner function definition to be literally written inside the parent component."
**‚úÖ Reality:** Closure happens whenever a function is CREATED inside another function's execution. Not where it is written in the file, but where it is created during execution.

- Inner function doesn't need to be inside the outer function's code block directly, it should be lexically inside of the outer function and outlive the outer function for the closure to be formed. For example, when inside any function we call setTimeout, this setTimeout has a callback function, this callback function is not directly inside the parent function rather lexically inside, same goes for the useEffect hook inside a React component.

- JavaScript creates closures ANYWHERE an inner function uses outer variables, even if NOTHING is returned.

- A closure is created whenever a function remembers variables from the scope in which it was created ‚Äî return is NOT required.
- If these three conditions are true ‚Üí closure is created.

- Eg1:

  ```javascript
  function outer() {
    let outerVar = "I'm outer!";
    return function inner() {
      console.log(outerVar); // Closure in action, relies on lexical scope
    };
  }
  const innerFunc = outer(); // Closure created here
  innerFunc(); // Output: "I'm outer!"
  ```

- Eg2:

  ```js
  function outer() {
    let x = 10;

    function inner() {
      console.log(x); // uses x ‚Üí closure
    }

    setTimeout(inner, 1000);
  }
  ```

**‚ùå Misconception: "Closures happen only when a function RETURNS another function."**
**‚úÖ Reality:**

A closure is created ANY TIME a function is defined inside another function ‚Äî
whether or not it is returned.

That's it.
Closures are automatically created on definition, not on return.

## Is closure a function or a mechanism?

- Closure is NOT a special kind of function.
- Closure is a mechanism / feature of JavaScript.
- A closure is the mechanism by which a function remembers and continues to access variables from its outer scope even after that outer function has finished executing.

## What is the "closure function"?

- When you write an inner function that uses variables from the outer function, that inner function is said to "form a closure."
- The inner function = a normal function
- The ability to remember outer variables = closure mechanism
- **Correct Terminology**
  - Closure (mechanism): **The language feature that preserves lexical scope**.
  - Function that uses closure: Inner function / callback / handler / returned function.

‚ùå Wrong
"inner function is a closure"

‚úîÔ∏è Correct
"The inner function creates or forms a closure."
"The closure mechanism allows the inner function to access outer variables."

- Closure = mechanism
- Inner function that remembers outer variables = function WITH closure

## What Actually Creates a Closure?

**A closure is created when:**

- A function is created inside another lexical scope, and
- It accesses variables from that outer lexical scope even after the outer function has finished executing.

A closure is created when BOTH are true:

1. A function is defined inside another function (or inside any block of lexical scope)
2. The inner function uses variables from the outer function/outer lexical scope

Correct technical wording:

- outer lexical scope
- surrounding scope
- enclosing scope

Closures can capture variables from any surrounding lexical environment, not just function scope.

Does the outer function have to return the inner one?
‚ùå NO. Returning is NOT required.
Binding a callback to a button/event/timeout also creates a closure.

## Closure is tied to lexical environment, not execution context

A function forms closure when:

- It is created inside the lexical environment of another function
- AND it captures variables from that environment
- AND it outlives the parent

Important:

- Closures capture lexical environments, not execution contexts.

Execution context dies.
Lexical environment lives inside the closure.

## Closure has nothing to do with Execution Context

Execution Context vs Closure ‚Äî Two Different Worlds

**Execution Context**

- Created when a function starts running
- Gets destroyed when the function finishes
- Temporary
- Exists only on the call stack

**‚úîÔ∏è Closure**

- Created when an inner function is defined
- Lives after the parent function finishes
- Persistent
- Comes from the Lexical Environment, NOT the Execution Context
- Stored on the heap

Closures do NOT capture Execution Context.
Closures capture Lexical Environment.

Execution Context is destroyed immediately after the function returns.

```js
function outer() {
  let x = 10;

  return function inner() {
    console.log(x);
  };
}

const fn = outer();
fn();
```

Timeline:

- outer() Execution Context created
- Execution Context destroyed
- But closure keeps x alive
- fn() still prints 10

üëâ Closure survives
üëâ Execution Context dies

Therefore:

‚úîÔ∏è Closure has NOTHING to do with the Execution Context
‚úîÔ∏è Closure only preserves the Lexical Environment (variable storage), NOT the execution
