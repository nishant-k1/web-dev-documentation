# Type Conversion

- Definition: The process of converting a value from one data type to another.
- Type Conversion is the broader concept that includes both implicit (type coercion) and explicit (type casting) methods of converting data types.
- Type Coercion is a specific kind of type conversion that happens automatically.

## Types of Type Conversion

Two Types of Type Conversions:

1. `Implicit Conversion (Type Coercion)` (Automatic)
   JavaScript automatically converts types when operations are performed on values of different types.

2. `Explicit Conversion (Type Casting)` (Manual)
   You can manually convert a value from one type to another using functions like String(), Number(), Boolean(), etc.

## Types of Implicit Type Conversion (Type Coercion)

1. **String Coercion**
   When an operation involves a string and another type with (+ operator), JavaScript tries to convert the non-string operand to a string.

   ```Javascript
    let num = 5;
    let str = "Hello";
    let result = str + num; // "Hello5" - number coerced to string for concatenation

    console.log(5 + '5'); // "55" (number 5 is coerced to string)
    console.log('5' + 5); // "55" (number 5 is coerced to string)
   ```

2. **Number Coercion**
   When a number is involved in arithmetic operations `(except for +)`, JavaScript tries to convert non-numeric types to numbers.

   ```Javascript
    let str = "10";
    let result = str * 2; // 20 - string coerced to number for multiplication

    console.log("5" - 2); // 3 (string "5" is coerced to number)
    console.log("5" * 2); // 10 (string "5" is coerced to number)
    console.log("5" / 2); // 2.5 (string "5" is coerced to number)
   ```

3. **Boolean Coercion**
   - JavaScript automatically converts values to `true` or `false` in contexts that expect a Boolean, such as `if statements`, `logical operators`, etc.

     ### Truthy Values and Falsy Values

     A Boolean context in JavaScript refers to any situation where a value is coerced or interpreted as a Boolean (true or false).

     This usually happens in places where a decision is made based on whether the value is truthy or falsy. For instance, in conditional statements, loops, and logical operations, JavaScript automatically converts values to true or false to make a decision.

     `In JavaScript, truthy and falsy values refer to the way certain values are evaluated in Boolean contexts` (such as in if statements or logical operations). These values are automatically converted to true or false when evaluated in contexts that require a Boolean value.

     #### Falsy Values

     A falsy value is one that evaluates to false when coerced to a Boolean. In JavaScript, the following values are considered falsy:
     1. `false` – The Boolean value false.
     2. `""` (empty string) – A string with no characters.
     3. `null` – Represents a null or non-existent value.
     4. `undefined` – A variable that has been declared but not assigned a value.
     5. `NaN` – Not a Number (result of invalid mathematical operations).
     6. `0` – The number zero.
     7. `-0` – The negative zero.
     8. `0n` – The BigInt zero.

     ```Javascript
     if (false) {
       console.log("This won't run.");
     }

     if (0) {
       console.log("This won't run.");
     }
     if (-0) {
       console.log("This won't run.");
     }
     if (0n) {
       console.log("This won't run.");
     }
     if ("") {
       console.log("This won't run.");
     }

     if (null) {
       console.log("This won't run.");
     }

     if (undefined) {
       console.log("This won't run.");
     }

     if (NaN) {
       console.log("This won't run.");
     }

     ```

     #### Truthy Values

     A truthy value is one that evaluates to true when coerced to a Boolean. Essentially, any value that is not falsy is considered truthy.

     Some examples of truthy values:
     1. `true` – The Boolean value true.
     2. `Non-zero numbers` – Any number other than 0 or -0.
     3. `Non-empty strings` – A string that contains at least one character (including spaces).
     4. `Objects` – Any object, including empty objects ({}) and arrays ([]).
     5. `Non-zero BigInt` – Any BigInt other than 0n.
     6. `Infinity` and `-Infinity` – Positive and negative infinity.

     ```JavaScript
     if (true) {
       console.log("This will run.");
     }

     if (1) {
       console.log("This will run.");
     }

     if ("Hello") {
       console.log("This will run.");
     }

     if ({}) {
       console.log("This will run.");
     }

     if ([]) {
       console.log("This will run.");
     }

     if (Infinity) {
       console.log("This will run.");
     }
     if (-Infinity) {
       console.log("This will run.");
     }
     ```

4. **Logical Operators**
   The && (AND) and || (OR) operators perform type coercion based on the operands' `truthiness` or `falseness`.

   ```Javascript
   console.log(0 || "Hello"); // "Hello" (0 is falsy, so returns the second operand)
   console.log(5 && "Hello"); // "Hello" (5 is truthy, so returns the second operand)
   ```

5. **Equality Operators (== vs ===)**
   1. `== (loose equality):`
      - Compares two values for equality, performing type coercion if the types are different.
      - If one operand is a string and the other is a number, JavaScript tries to convert the string to a number when the operator is `==`.

      Rules of type coercion (order of operand doesn't matter)
      - string to number
        Eg: '123' to 123
      - boolean to number
        Eg: true to 1 and false to 0
      - null to undefined
      - object to primitive
        Eg: [] == "" → The empty array [] is converted to an empty string ""
      - Special Cases
        0 == false → true
        [] == false -> true
        "" == 0 → true
        " \t\r\n" == 0 → true
        null == 0 → false
        0 == null → false
        undefined == 0 → false

      Instead of trying to memorize everything, focus on these key takeaways:

      `==` allows type conversion (string → number, boolean → number, etc.).
      `===` is strict (no type conversion).
      `+` favors strings (if one operand is a string, the result is a string).
      `null` and `undefined` are only equal to each other (null == undefined → true).
      `Comparisons (>= or <=)` convert null to 0, but null == 0 is false.

      ```Javascript
        console.log("5" == 5); // true (string "5" is converted to number 5)
        console.log(5 == "5"); // true (string "5" is converted to number 5)
        console.log("hello" == 5); // false (string "hello" cannot be converted to a number)
      ```

   2. `=== (strict equality)`: Does not perform type coercion. The values must be of the same type and value.

      ```Javascript
        console.log(5 === "5"); // false (different types)
        console.log(0 === false); // false (different types)
      ```

6. **Non-Primitive to Primitive Coercion**
   JavaScript can convert objects to primitive values when necessary. This happens when objects are used in operations like string concatenation, comparison, or arithmetic.
   By default, JavaScript calls the toString() or valueOf() method of objects to convert them into a primitive value.

   ```Javascript
    let obj = { name: "John" };
    console.log(obj + ""); // "[object Object]" (object coerced to string)

    let obj = {
       valueOf() {
           return 10;
         }
    };
    console.log(obj + 5); // 15 (obj coerced to number)
   ```

## Types of Explicit Type Conversion (Type Casting)

1. String Conversion
   To convert any value to a string, use the `String()` function or the `.toString()` method.

   ```Javascript
     console.log(String(123)); // "123"
     console.log((123).toString()); // "123"

   ```

2. Number Conversion
   To convert a value to a number, use `Number()`, `parseInt()`, or `parseFloat()`.

   ```Javascript
    console.log(Number("123")); // 123
    console.log(parseInt("123px")); // 123
    console.log(parseFloat("123.45px")); // 123.45
   ```

3. Boolean Conversion
   To convert a value to a Boolean, use Boolean().

   ```Javascript
   console.log(Boolean(0)); // false
   console.log(Boolean("Hello")); // true

   ```

## Special Cases of Type Coercion

- null and undefined are loosely equal because JavaScript coerces them.
- They are not strictly equal because they are different types.

1. `null` and `undefined`
   - **null**
     1. You need to explicitly assign it.
     2. Represents the intentional absence of any object value.
     3. It is an explicitly assigned value to indicate "nothing" or "empty."
        `Type: object` (this is a historical bug in JavaScript and has been retained for backward compatibility).
     4. Used to explicitly clear or reset a value.
     5. Indicates an intentional absence of a value.
     6. Often used when a variable is expected to hold an object but currently does not

   - **undefined**
     1. Automatically assigned by JavaScript
     2. Represents the lack of value or the absence of initialization.
     3. It is a default value assigned to variables or properties that have been declared but not initialized.
        `Type: undefined`
     4. Used to indicate that a variable has been declared but not assigned a value yet.
     5. Also, functions that do not return anything implicitly return `undefined`
        When you access a property of an object or an element of an array that does not exist, the result is `undefined`.

   - **`null` vs `undefined`**
     1. null needs to be explicitly assigned while undefined automatically assigned by JavaScript
     2. null and undefined are both considered falsy values, but they are not strictly equal to each other or to any other value.
     3. null is often used to represent the intentional absence of an object, while undefined typically indicates that a variable has not been initialized.
     4. Type of null is object while type of undefined is undefined

     ```Javascript
       console.log(null == undefined); // true (loosely equal)
       console.log(null === undefined); // false (strictly not equal)
     ```

2. `+` Operator
   The `+` operator is special because, when used with strings, it concatenates rather than performs addition. This can lead to unexpected behavior if one operand is a string and the other is a number.

   ```Javascript
    console.log(5 + "5"); // "55" (string concatenation)
    console.log("5" + 5); // "55" (string concatenation)
    ---
    console.log("10" - 1); // 9 (string "10" coerced to number)
     console.log("10" * "2"); // 20 (both strings coerced to numbers)
   ```
