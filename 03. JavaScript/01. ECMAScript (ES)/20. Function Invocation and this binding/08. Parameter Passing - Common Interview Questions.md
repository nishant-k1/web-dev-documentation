# Common Interview Questions: Parameter Passing

Frequently asked interview questions about parameter passing in JavaScript.

---

## ðŸ”· 1. Basic Concepts

### Q1: What's the difference between pass by value and pass by reference?

**Answer:**

- **Pass by Value**: A copy of the value is passed. Changes to the parameter don't affect the original.

  - Applies to: Primitives (number, string, boolean, etc.)

- **Pass by Reference**: A reference to the object is passed. Changes to object properties affect the original.
  - Applies to: Non-primitives (objects, arrays, functions, etc.)

```javascript
// Pass by value
function modifyPrimitive(x) {
  x = 100;
}
let num = 10;
modifyPrimitive(num);
console.log(num); // 10 (unchanged)

// Pass by reference
function modifyObject(obj) {
  obj.value = 100;
}
let myObj = { value: 10 };
modifyObject(myObj);
console.log(myObj.value); // 100 (modified)
```

---

### Q2: Does JavaScript have true pass by reference?

**Answer:**

**No.** JavaScript passes a **copy of the reference** (pass by value of reference).

**Evidence:**

```javascript
function reassign(obj) {
  obj = { new: true }; // Only affects local parameter
}

let original = { old: true };
reassign(original);
console.log(original); // { old: true } (unchanged)
```

In true pass by reference (like C++), reassigning the parameter would affect the original variable. JavaScript doesn't do this.

---

## ðŸ”· 2. Primitives

### Q3: What will this code output?

```javascript
function changeValue(x) {
  x = x * 2;
  return x;
}

let num = 5;
let result = changeValue(num);
console.log(num); // ?
console.log(result); // ?
```

**Answer:**

```
5
10
```

`num` is unchanged because primitives are passed by value. The function returns a new value.

---

### Q4: Can you modify a string passed to a function?

**Answer:**

**No.** Strings are immutable and passed by value.

```javascript
function modifyString(str) {
  str = str.toUpperCase(); // Returns new string
  str[0] = "X"; // Doesn't work - strings are immutable
}

let text = "hello";
modifyString(text);
console.log(text); // "hello" (unchanged)
```

---

## ðŸ”· 3. Objects

### Q5: What will this code output?

```javascript
function modify(obj) {
  obj.property = "modified";
  obj = { new: "object" };
}

let myObj = { property: "original" };
modify(myObj);
console.log(myObj);
```

**Answer:**

```javascript
{
  property: "modified";
}
```

**Explanation:**

1. `obj.property = "modified"` modifies the shared object
2. `obj = { new: "object" }` only changes the local parameter reference
3. `myObj` still points to the original object with modified property

---

### Q6: How do you prevent object mutation?

**Answer:**

**Option 1: Create a copy**

```javascript
function safeModify(obj) {
  const copy = { ...obj }; // Shallow copy
  copy.property = "modified";
  return copy;
}

let original = { property: "original" };
let modified = safeModify(original);
console.log(original); // { property: "original" } (unchanged)
```

**Option 2: Use Object.freeze()**

```javascript
let frozen = Object.freeze({ property: "original" });

function tryModify(obj) {
  obj.property = "modified"; // Silently fails in non-strict mode
}

tryModify(frozen);
console.log(frozen); // { property: "original" } (unchanged)
```

---

## ðŸ”· 4. Arrays

### Q7: What will this code output?

```javascript
function processArray(arr) {
  arr.push(4);
  arr = [1, 2, 3];
}

let numbers = [1, 2, 3];
processArray(numbers);
console.log(numbers);
```

**Answer:**

```javascript
[1, 2, 3, 4];
```

**Explanation:**

- `arr.push(4)` modifies the shared array
- `arr = [1, 2, 3]` only changes the local parameter reference
- `numbers` still points to the original array with 4 added

---

### Q8: How do you pass an array without mutation?

**Answer:**

**Create a copy before passing:**

```javascript
function processArray(arr) {
  arr.push(4); // Modifies copy
}

let numbers = [1, 2, 3];
processArray([...numbers]); // Pass copy
console.log(numbers); // [1, 2, 3] (unchanged)
```

**Or use non-mutating methods:**

```javascript
function processArray(arr) {
  return [...arr, 4]; // Return new array
}

let numbers = [1, 2, 3];
let result = processArray(numbers);
console.log(numbers); // [1, 2, 3] (unchanged)
console.log(result); // [1, 2, 3, 4] (new array)
```

---

## ðŸ”· 5. Nested Objects

### Q9: What will this code output?

```javascript
function modifyNested(obj) {
  obj.nested.value = 100;
  obj.nested = { new: "object" };
}

let data = { nested: { value: 10 } };
modifyNested(data);
console.log(data);
```

**Answer:**

```javascript
{ nested: { new: "object" } }
```

**Explanation:**

1. `obj.nested.value = 100` modifies the nested object
2. `obj.nested = { new: "object" }` reassigns the `nested` property
3. This modifies the shared object's property, so it affects the original

---

### Q10: How do you do a deep copy?

**Answer:**

**Option 1: structuredClone() (modern)**

```javascript
let original = { nested: { value: 10 } };
let copy = structuredClone(original);

copy.nested.value = 100;
console.log(original.nested.value); // 10 (unchanged)
```

**Option 2: JSON methods (limited)**

```javascript
let copy = JSON.parse(JSON.stringify(original));
// Doesn't work with functions, undefined, symbols, etc.
```

**Option 3: Manual deep copy**

```javascript
function deepCopy(obj) {
  if (obj === null || typeof obj !== "object") return obj;
  if (obj instanceof Date) return new Date(obj);
  if (obj instanceof Array) return obj.map((item) => deepCopy(item));

  const copy = {};
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      copy[key] = deepCopy(obj[key]);
    }
  }
  return copy;
}
```

---

## ðŸ”· 6. Tricky Scenarios

### Q11: What will this code output?

```javascript
let a = { value: 1 };
let b = a;
b.value = 2;
console.log(a.value);
```

**Answer:**

```
2
```

Both `a` and `b` reference the same object, so modifying `b.value` affects `a.value`.

---

### Q12: What will this code output?

```javascript
let a = { value: 1 };
let b = a;
b = { value: 2 };
console.log(a.value);
```

**Answer:**

```
1
```

Reassigning `b` makes it point to a new object. `a` still points to the original.

---

### Q13: Can you swap two variables using a function?

**Answer:**

**For primitives: No** (passed by value)

```javascript
function swap(a, b) {
  let temp = a;
  a = b;
  b = temp;
}

let x = 10,
  y = 20;
swap(x, y);
console.log(x, y); // 10, 20 (not swapped)
```

**For objects: Yes** (modify properties)

```javascript
function swapProperties(obj) {
  let temp = obj.a;
  obj.a = obj.b;
  obj.b = temp;
}

let myObj = { a: 10, b: 20 };
swapProperties(myObj);
console.log(myObj); // { a: 20, b: 10 } (swapped)
```

---

## ðŸ”· 7. Default Parameters

### Q14: What's wrong with this code?

```javascript
function addItem(items = []) {
  items.push("new");
  return items;
}

let result1 = addItem();
let result2 = addItem();
console.log(result1); // ?
console.log(result2); // ?
```

**Answer:**

```javascript
["new", "new"][("new", "new")];
```

**Problem:** Default parameters are evaluated once, so `items = []` creates a shared array.

**Fix:**

```javascript
function addItem(items) {
  items = items || []; // Create new array each time
  items.push("new");
  return items;
}

// Or
function addItem(items = []) {
  items = [...items]; // Copy to avoid mutation
  items.push("new");
  return items;
}
```

---

## ðŸ”· 8. Destructuring

### Q15: What will this code output?

```javascript
function process({ name, age }) {
  name = "Changed";
  age = 100;
}

let person = { name: "John", age: 25 };
process(person);
console.log(person);
```

**Answer:**

```javascript
{ name: "John", age: 25 }
```

Destructured primitives are copies, so reassigning them doesn't affect the original.

---

### Q16: What will this code output?

```javascript
function process({ user: { name, profile } }) {
  name = "Changed";
  profile.age = 100;
}

let data = {
  user: {
    name: "John",
    profile: { age: 25 },
  },
};

process(data);
console.log(data.user.name); // ?
console.log(data.user.profile.age); // ?
```

**Answer:**

```
"John"
100
```

- `name` is a primitive copy (unchanged)
- `profile` is an object reference (modified)

---

## ðŸ”· 9. Rest Parameters

### Q17: Are rest parameters passed by value or reference?

**Answer:**

Rest parameters create a **new array**, so they're passed by reference (like any array), but modifications don't affect the original arguments.

```javascript
function process(...args) {
  args.push(4); // Modifies the rest parameter array
}

process(1, 2, 3);
// Original arguments (1, 2, 3) are unchanged
// args is a new array containing [1, 2, 3, 4]
```

---

## ðŸ”· 10. Functions as Parameters

### Q18: How are functions passed?

**Answer:**

Functions are passed **by reference** (like objects).

```javascript
function callFunction(fn) {
  fn(); // Calls the shared function
}

function myFunction() {
  console.log("Called");
}

callFunction(myFunction); // "Called"
```

---

## Summary

Key points to remember:

- âœ… Primitives: Pass by value (copies)
- âœ… Objects: Pass by reference (shared)
- âœ… Property modifications: Affect original
- âœ… Parameter reassignment: Doesn't affect original
- âœ… Default objects: Shared (create new each time)
- âœ… Destructuring: Primitives copied, objects referenced

---

## Related Topics

- [03. Pass By Value.md](./03.%20Pass%20By%20Value.md) - Detailed pass by value
- [04. Pass By Reference.md](./04.%20Pass%20By%20Reference.md) - Detailed pass by reference
- [07. Parameter Passing - Common Patterns and Use Cases.md](./07.%20Parameter%20Passing%20-%20Common%20Patterns%20and%20Use%20Cases.md) - Practical patterns
