# Explicit Binding (call, apply, bind)

Explicit binding allows you to **explicitly set** the `this` context of a function using `call()`, `apply()`, or `bind()`. This gives you control over what `this` refers to, regardless of how the function is called.

---

## Overview

All three methods (`call`, `apply`, `bind`) allow you to control the `this` context, but they work differently:

| Method    | Invokes Function | Returns         | Use Case                                                  |
| --------- | ---------------- | --------------- | --------------------------------------------------------- |
| `call()`  | Immediately      | Function result | Call function with specific `this` and arguments          |
| `apply()` | Immediately      | Function result | Call function with specific `this` and array of arguments |
| `bind()`  | Later            | New function    | Create function with bound `this` for later use           |

---

## call(thisArg, arg1, arg2, ...)

Calls a function with a specified `this` value and arguments provided individually.

### Syntax

```javascript
function.call(thisArg, arg1, arg2, ...)
```

### Basic Example

```javascript
function greet(greeting, punctuation) {
  console.log(`${greeting}, ${this.name}${punctuation}`);
}

const person = { name: "John" };
greet.call(person, "Hello", "!"); // "Hello, John!"
```

### How It Works

```javascript
const obj = {
  name: "Object",
  method: function () {
    return this.name;
  },
};

// These are equivalent:
obj.method(); // "Object"
obj.method.call(obj); // "Object" (explicit)
```

**Under the hood:** `obj.method()` is essentially `obj.method.call(obj)`

### Example: Method Borrowing

```javascript
const wizard = {
  name: "Merlin",
  health: 100,
  heal: function (amount) {
    this.health += amount;
    return this.health;
  },
};

const archer = {
  name: "Robin Hood",
  health: 30,
};

// Borrow heal method from wizard
wizard.heal.call(archer, 50);
console.log(archer.health); // 80
```

### Example: Detached Method

```javascript
const user = {
  name: "Nishant",
  greet: function () {
    return `Hello, ${this.name}`;
  },
};

const greetFn = user.greet; // Detached
console.log(greetFn()); // "Hello, undefined" (lost context)

// Restore context with call
console.log(greetFn.call(user)); // "Hello, Nishant"
```

### Passing Arguments

```javascript
function introduce(greeting, title) {
  return `${greeting}, I'm ${title} ${this.name}`;
}

const person = { name: "John" };
introduce.call(person, "Hi", "Mr."); // "Hi, I'm Mr. John"
```

### With Null/Undefined

```javascript
function showThis() {
  console.log(this);
}

showThis.call(null); // window/global (non-strict) or null (strict)
showThis.call(undefined); // window/global (non-strict) or undefined (strict)
```

---

## apply(thisArg, [arg1, arg2, ...])

Calls a function with a specified `this` value and arguments provided as an **array**.

### Syntax

```javascript
function.apply(thisArg, [arg1, arg2, ...])
```

### Basic Example

```javascript
function greet(greeting, punctuation) {
  console.log(`${greeting}, ${this.name}${punctuation}`);
}

const person = { name: "John" };
greet.apply(person, ["Hello", "!"]); // "Hello, John!"
```

### Difference from call()

The **only difference** between `call()` and `apply()` is how arguments are passed:

```javascript
function sum(a, b, c) {
  return a + b + c;
}

const numbers = [1, 2, 3];

// call() - arguments individually
sum.call(null, 1, 2, 3); // 6

// apply() - arguments as array
sum.apply(null, numbers); // 6

// Modern alternative with spread
sum(...numbers); // 6 (ES6)
```

### When to Use apply()

**Use `apply()` when:**

- You have arguments in an array
- You're working with variable number of arguments
- You're calling functions that accept arrays

### Example: Math Functions

```javascript
const numbers = [5, 2, 8, 1, 9];

// Old way with apply
Math.max.apply(null, numbers); // 9
Math.min.apply(null, numbers); // 1

// Modern way with spread
Math.max(...numbers); // 9
Math.min(...numbers); // 1
```

### Example: Function with Variable Arguments

```javascript
function introduce(greeting, ...titles) {
  return `${greeting}, I'm ${titles.join(" ")} ${this.name}`;
}

const person = { name: "John" };
const titles = ["Mr.", "Dr."];

introduce.apply(person, ["Hello", ...titles]); // "Hello, I'm Mr. Dr. John"
```

---

## bind(thisArg, arg1, arg2, ...)

Creates a **new function** with a specified `this` value and optional pre-filled arguments. Unlike `call()` and `apply()`, `bind()` does **not** invoke the function immediately.

### Syntax

```javascript
function.bind(thisArg, arg1, arg2, ...)
```

### Basic Example

```javascript
function greet(greeting) {
  return `${greeting}, ${this.name}`;
}

const person = { name: "John" };
const boundGreet = greet.bind(person);

boundGreet("Hello"); // "Hello, John"
```

### Key Characteristics

1. **Returns a new function** (doesn't call the original)
2. **Binds `this` permanently** (cannot be changed)
3. **Can pre-fill arguments** (partial application)
4. **Useful for callbacks** and event handlers

### Example: Preserving Context

```javascript
const obj = {
  name: "Object",
  method: function () {
    return this.name;
  },
};

const method = obj.method; // Lost context
console.log(method()); // undefined

const boundMethod = obj.method.bind(obj); // Preserved context
console.log(boundMethod()); // "Object"
```

### Example: Event Handlers

```javascript
const button = {
  name: "Submit",
  handleClick: function () {
    console.log(`Clicked: ${this.name}`);
  },
};

// Without bind - loses context
buttonElement.addEventListener("click", button.handleClick); // undefined

// With bind - preserves context
buttonElement.addEventListener("click", button.handleClick.bind(button)); // "Submit"
```

### Partial Application (Pre-filling Arguments)

```javascript
function multiply(a, b, c) {
  return a * b * c;
}

// Bind first argument
const multiplyBy2 = multiply.bind(null, 2);
multiplyBy2(3, 4); // 24 (2 * 3 * 4)

// Bind first two arguments
const multiplyBy2And3 = multiply.bind(null, 2, 3);
multiplyBy2And3(4); // 24 (2 * 3 * 4)
```

### Example: Method Borrowing with bind

```javascript
const wizard = {
  name: "Merlin",
  health: 100,
  heal: function (amount1, amount2) {
    this.health += amount1 + amount2;
    return this.health;
  },
};

const archer = {
  name: "Robin Hood",
  health: 30,
};

// Bind method for later use
const healArcher = wizard.heal.bind(archer, 30, 40);
healArcher(); // 100 (30 + 30 + 40)
console.log(archer.health); // 100
```

---

## Comparison: call vs apply vs bind

### call() - Immediate Invocation

```javascript
function greet(name) {
  return `Hello, ${name}. I'm ${this.name}`;
}

const person = { name: "John" };
greet.call(person, "Alice"); // "Hello, Alice. I'm John" (immediate)
```

### apply() - Immediate Invocation with Array

```javascript
greet.apply(person, ["Alice"]); // "Hello, Alice. I'm John" (immediate)
```

### bind() - Deferred Invocation

```javascript
const boundGreet = greet.bind(person);
boundGreet("Alice"); // "Hello, Alice. I'm John" (called later)
```

---

## Arrow Functions and call/apply/bind

**Important:** Arrow functions **ignore** `call()`, `apply()`, and `bind()` because they don't have their own `this`.

```javascript
const obj = {
  name: "Object",
};

const arrowFn = () => {
  console.log(this.name);
};

// These all have the same effect - this is from lexical scope
arrowFn(); // undefined (this from outer scope)
arrowFn.call(obj); // undefined (ignored)
arrowFn.apply(obj); // undefined (ignored)
arrowFn.bind(obj)(); // undefined (ignored)
```

**Why:** Arrow functions use lexical binding, so `this` cannot be changed.

---

## Common Use Cases

### Use Case 1: Method Borrowing

```javascript
const arrayLike = {
  0: "a",
  1: "b",
  length: 2,
};

// Borrow Array methods
Array.prototype.push.call(arrayLike, "c");
console.log(arrayLike); // { 0: "a", 1: "b", 2: "c", length: 3 }
```

### Use Case 2: Function Currying

```javascript
function add(a, b, c) {
  return a + b + c;
}

// Create specialized functions
const add10 = add.bind(null, 10);
add10(5, 3); // 18 (10 + 5 + 3)

const add10And5 = add.bind(null, 10, 5);
add10And5(3); // 18 (10 + 5 + 3)
```

### Use Case 3: Preserving Context in Callbacks

```javascript
class Counter {
  constructor() {
    this.count = 0;
  }

  increment() {
    this.count++;
  }

  setupTimer() {
    // Without bind - loses context
    // setInterval(this.increment, 1000); // Error

    // With bind - preserves context
    setInterval(this.increment.bind(this), 1000);
  }
}
```

### Use Case 4: Calling Parent Methods

```javascript
function Animal(name) {
  this.name = name;
}

Animal.prototype.speak = function () {
  console.log(`${this.name} makes a sound`);
};

function Dog(name) {
  Animal.call(this, name); // Call parent constructor
}

Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;

const dog = new Dog("Buddy");
dog.speak(); // "Buddy makes a sound"
```

---

## Advanced Patterns

### Pattern 1: Creating Bound Methods

```javascript
class Button {
  constructor(label) {
    this.label = label;
    // Bind method in constructor
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    console.log(`Clicked: ${this.label}`);
  }
}

const button = new Button("Submit");
const handler = button.handleClick; // Already bound
handler(); // "Clicked: Submit"
```

### Pattern 2: Soft Binding (Polyfill)

```javascript
if (!Function.prototype.softBind) {
  Function.prototype.softBind = function (obj) {
    const fn = this;
    const curried = [].slice.call(arguments, 1);
    const bound = function () {
      return fn.apply(
        !this || this === (window || global) ? obj : this,
        curried.concat.apply(curried, arguments)
      );
    };
    bound.prototype = Object.create(fn.prototype);
    return bound;
  };
}
```

### Pattern 3: Method Delegation

```javascript
const obj1 = {
  name: "Object 1",
  method: function () {
    return this.name;
  },
};

const obj2 = {
  name: "Object 2",
  method: obj1.method.bind(obj2), // Delegate to obj1's method
};

console.log(obj2.method()); // "Object 2"
```

---

## Performance Considerations

### bind() Creates New Function

```javascript
function test() {}

const bound1 = test.bind(obj);
const bound2 = test.bind(obj);

console.log(bound1 === bound2); // false - different functions
```

**Note:** Each `bind()` call creates a new function. If you need the same bound function multiple times, store it in a variable.

### Memory Implications

```javascript
// Creates new function each time (inefficient)
elements.forEach((el) => {
  el.addEventListener("click", handler.bind(obj));
});

// Better: Create bound function once
const boundHandler = handler.bind(obj);
elements.forEach((el) => {
  el.addEventListener("click", boundHandler);
});
```

---

## Summary

### Key Points

1. **`call()`** - Invokes immediately with individual arguments
2. **`apply()`** - Invokes immediately with array of arguments
3. **`bind()`** - Returns new function with bound `this`
4. **All three** allow explicit `this` control
5. **Arrow functions** ignore these methods (lexical `this`)

### When to Use

- **`call()`** - When you have individual arguments
- **`apply()`** - When you have arguments in an array
- **`bind()`** - When you need to preserve context for later use

### Common Patterns

- Method borrowing
- Preserving context in callbacks
- Function currying
- Calling parent constructors
- Event handlers

---

> ðŸ“– **Related Topics:**
>
> - [2. Understanding this Binding.md](./2.%20Understanding%20this%20Binding.md) - Overview
> - [4. Implicit Binding.md](./4.%20Implicit%20Binding.md) - Method invocation
> - [7. Arrow Functions and this.md](./7.%20Arrow%20Functions%20and%20this.md) - Why arrow functions ignore bind
> - [12. this in Event Handlers.md](./11.%20this%20in%20Event%20Handlers.md) - Using bind in event handlers
> - [13. this in Callbacks and Async.md](./12.%20this%20in%20Callbacks%20and%20Async.md) - Using bind in callbacks
