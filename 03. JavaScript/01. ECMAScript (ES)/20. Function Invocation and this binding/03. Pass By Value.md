# Pass By Value

Pass by value means a **copy** of the value is passed to the function parameter. Changes to the parameter do not affect the original variable.

---

## What is Pass By Value?

When you pass a primitive value to a function:

1. JavaScript creates a **copy** of the value
2. The copy is assigned to the function parameter
3. The parameter and original variable are **independent**
4. Changes to the parameter **don't affect** the original

---

## Applies To

Pass by value applies to **all primitive types**:

- `number`
- `string`
- `boolean`
- `undefined`
- `null`
- `symbol`
- `bigint`

---

## Basic Example

```javascript
function modifyValue(x) {
  x = 42; // Change is local to the function
  console.log("Inside function:", x); // 42
}

let num = 10;
modifyValue(num);
console.log("Outside function:", num); // 10 (unchanged)
```

**What happens:**

1. `num` has value `10`
2. Copy of `10` is passed to `x`
3. `x` is changed to `42` (only affects the copy)
4. `num` remains `10`

---

## Memory Model

```
Before function call:
num (variable) → [10] (value in memory)

During function call:
num (variable) → [10] (original, unchanged)
x (parameter)  → [10] (copy, independent)

After modifying x:
num (variable) → [10] (original, unchanged)
x (parameter)  → [42] (copy, changed)
```

---

## Examples by Primitive Type

### Numbers

```javascript
function increment(num) {
  num = num + 1;
  console.log("Inside:", num); // 11
}

let count = 10;
increment(count);
console.log("Outside:", count); // 10 (unchanged)
```

### Strings

```javascript
function changeString(str) {
  str = str.toUpperCase();
  console.log("Inside:", str); // "HELLO"
}

let greeting = "hello";
changeString(greeting);
console.log("Outside:", greeting); // "hello" (unchanged)
```

**Note:** Strings are immutable, so `toUpperCase()` returns a new string anyway.

### Booleans

```javascript
function toggle(flag) {
  flag = !flag;
  console.log("Inside:", flag); // false
}

let isActive = true;
toggle(isActive);
console.log("Outside:", isActive); // true (unchanged)
```

### null and undefined

```javascript
function setValue(val) {
  val = "new value";
  console.log("Inside:", val); // "new value"
}

let value = null;
setValue(value);
console.log("Outside:", value); // null (unchanged)
```

### Symbols

```javascript
function modifySymbol(sym) {
  sym = Symbol("new");
  console.log("Inside:", sym); // Symbol(new)
}

let mySymbol = Symbol("original");
modifySymbol(mySymbol);
console.log("Outside:", mySymbol); // Symbol(original) (unchanged)
```

### BigInt

```javascript
function addBigInt(big) {
  big = big + 100n;
  console.log("Inside:", big); // 200n
}

let bigNum = 100n;
addBigInt(bigNum);
console.log("Outside:", bigNum); // 100n (unchanged)
```

---

## Why Primitives Are Passed By Value

Primitives are:

1. **Immutable** - Can't be changed in place
2. **Fixed size** - Easy to copy
3. **Stored directly** - Value is the data itself

Since primitives are small and immutable, copying them is efficient and safe.

---

## Common Misconceptions

### ❌ Misconception: "I can modify primitives"

```javascript
// This doesn't work - primitives are immutable
function modifyString(str) {
  str[0] = "X"; // Doesn't work - strings are immutable
}

let text = "hello";
modifyString(text);
console.log(text); // "hello" (unchanged)
```

### ✅ Reality: Primitives are copied and immutable

```javascript
// You can only reassign, not mutate
function reassignString(str) {
  str = "new value"; // Only affects local copy
}

let text = "hello";
reassignString(text);
console.log(text); // "hello" (unchanged)
```

---

## Interview Trap: String Methods

```javascript
function processString(str) {
  str = str.toUpperCase(); // Returns new string
  return str;
}

let greeting = "hello";
let result = processString(greeting);
console.log(greeting); // "hello" (unchanged)
console.log(result); // "HELLO" (new string)
```

**Key point:** String methods return **new strings**, they don't modify the original.

---

## Performance Considerations

Passing primitives by value is:

- **Fast** - Copying small values is efficient
- **Safe** - No risk of unintended mutations
- **Predictable** - Original values never change

---

## Comparison with Other Languages

| Language   | Primitive Passing          |
| ---------- | -------------------------- |
| JavaScript | Pass by value              |
| Java       | Pass by value (primitives) |
| C++        | Pass by value (default)    |
| Python     | Pass by value (immutables) |

---

## Best Practices

### ✅ Do

```javascript
// Return modified values
function increment(num) {
  return num + 1; // Return new value
}

let count = 10;
count = increment(count); // Assign returned value
```

### ❌ Don't

```javascript
// Don't expect to modify primitives
function badIncrement(num) {
  num = num + 1; // Won't affect original
  // Missing return!
}
```

---

## Related Topics

- [04. Pass By Reference.md](./04.%20Pass%20By%20Reference.md) - How objects are passed
- [05. Pass By Value of Reference.md](./05.%20Pass%20By%20Value%20of%20Reference.md) - Technical details
- [14. Comparing](../14.%20Comparing/) - Comparing primitives
- [15. Copying](../15.%20Copying/) - Copying primitives
