# Function Invocation

Function invocation (also called function call or function execution) is the process of executing a function. When a function is invoked, a new execution context is created, and the function's code is executed.

---

## Types of Function Invocation

JavaScript supports several ways to invoke functions, each affecting how `this` is bound:

1. **Function Invocation** (Standalone/Default)
2. **Method Invocation** (Object Method)
3. **Constructor Invocation** (with `new`)
4. **Indirect Invocation** (using `call()`, `apply()`, `bind()`)
5. **Arrow Function Invocation**

---

## 1. Function Invocation (Standalone)

A function is invoked as a standalone function when called directly, not as a method of an object.

### Syntax

```javascript
functionName();
```

### Example

```javascript
function greet() {
  console.log("Hello");
}

greet(); // Function invocation
```

### `this` Binding

- **Non-strict mode:** `this` = `window` (browser) or `global` (Node.js)
- **Strict mode:** `this` = `undefined`

```javascript
function showThis() {
  console.log(this);
}

showThis(); // window (non-strict) or undefined (strict)

// In strict mode
("use strict");
function showThisStrict() {
  console.log(this); // undefined
}
showThisStrict();
```

---

## 2. Method Invocation

A function is invoked as a method when called as a property of an object.

### Syntax

```javascript
object.methodName();
```

### Example

```javascript
const person = {
  name: "John",
  greet: function () {
    console.log(`Hello, I'm ${this.name}`);
  },
};

person.greet(); // Method invocation - this = person
```

### `this` Binding

- `this` refers to the object that owns the method (the object before the dot)

```javascript
const obj1 = {
  name: "Object 1",
  getName: function () {
    return this.name;
  },
};

const obj2 = {
  name: "Object 2",
  getName: obj1.getName, // Method borrowing
};

console.log(obj1.getName()); // "Object 1" - this = obj1
console.log(obj2.getName()); // "Object 2" - this = obj2
```

### Important: Losing `this` Context

```javascript
const person = {
  name: "John",
  greet: function () {
    console.log(`Hello, I'm ${this.name}`);
  },
};

const greetFn = person.greet; // Function is detached from object
greetFn(); // this = window/undefined (not person!)
// Solution: Use bind() or arrow functions
```

---

## 3. Constructor Invocation (with `new`)

A function is invoked as a constructor when called with the `new` keyword.

### Syntax

```javascript
new FunctionName();
```

### Example

```javascript
function Person(name, age) {
  this.name = name;
  this.age = age;
}

const person = new Person("John", 30); // Constructor invocation
```

### `this` Binding

- `this` refers to the newly created instance
- A new object is created and assigned to `this`
- The function returns `this` (the new object) by default

```javascript
function Car(brand) {
  this.brand = brand;
  // No return statement - returns this automatically
}

const myCar = new Car("Toyota");
console.log(myCar.brand); // "Toyota"
console.log(myCar instanceof Car); // true
```

### What Happens with `new`

1. A new empty object is created
2. `this` is bound to the new object
3. The function body executes
4. The new object is returned (unless function returns something else)

```javascript
function Test() {
  this.value = 42;
  return { custom: "object" }; // Overrides default return
}

const test1 = new Test();
console.log(test1); // { custom: "object" } - not Test instance

function Test2() {
  this.value = 42;
  return 100; // Primitive return is ignored
}

const test2 = new Test2();
console.log(test2); // Test2 { value: 42 } - primitive return ignored
```

---

## 4. Indirect Invocation (call, apply, bind)

Functions can be invoked indirectly using `call()` or `apply()` to explicitly set the `this` context.

### Syntax

```javascript
functionName.call(thisArg, arg1, arg2, ...);
functionName.apply(thisArg, [arg1, arg2, ...]);
functionName.bind(thisArg, arg1, arg2, ...);
```

### Example

```javascript
function greet(greeting) {
  console.log(`${greeting}, ${this.name}`);
}

const person = { name: "John" };

greet.call(person, "Hello"); // "Hello, John"
greet.apply(person, ["Hi"]); // "Hi, John"
greet.bind(person, "Hello"); // returns function body
```

### `this` Binding

- `this` is explicitly set to the first argument (`thisArg`)
- If `thisArg` is `null` or `undefined`, `this` becomes `window`/`global` (non-strict) or `undefined` (strict)

```javascript
function showThis() {
  console.log(this);
}

showThis.call({ name: "Object" }); // { name: "Object" }
showThis.call(null); // window (non-strict) or null (strict)
```

> ðŸ“– **For detailed information:** See [5. Explicit Binding (call, apply, bind).md](<./5.%20Explicit%20Binding%20(call,%20apply,%20bind).md>)

---

## 5. Arrow Function Invocation

Arrow functions are invoked the same way as regular functions, but they handle `this` differently.

### Syntax

```javascript
const arrowFn = () => {
  /* ... */
};
arrowFn();
```

### Example

```javascript
const obj = {
  name: "John",
  regularFn: function () {
    console.log(this.name); // this = obj
  },
  arrowFn: () => {
    console.log(this.name); // this = window/undefined (lexical)
  },
};

obj.regularFn(); // "John"
obj.arrowFn(); // undefined (this is from outer scope)
```

### `this` Binding

- Arrow functions **do not have their own `this`**
- `this` is lexically bound (inherited from surrounding scope)
- `this` cannot be changed with `call()`, `apply()`, or `bind()`

```javascript
const obj = {
  name: "John",
  method: function () {
    const arrow = () => {
      console.log(this.name); // this = obj (from outer function)
    };
    arrow();
  },
};

obj.method(); // "John"
```

> ðŸ“– **For detailed information:** See [7. Arrow Functions and this.md](./7.%20Arrow%20Functions%20and%20this.md)

---

## Function Expression vs Function Declaration

### Function Declaration

```javascript
function greet() {
  console.log("Hello");
}

greet(); // Can be called before declaration (hoisting)
```

**Characteristics:**

- Hoisted to the top of scope
- Can be called before declaration
- Creates a function in the current scope

### Function Expression

```javascript
const greet = function () {
  console.log("Hello");
};

greet(); // Must be called after assignment
```

**Characteristics:**

- Not hoisted (variable is hoisted, but assignment happens at runtime)
- Cannot be called before assignment
- Can be anonymous or named

### Named Function Expression

```javascript
const greet = function sayHello() {
  console.log("Hello");
  // sayHello(); // Can call itself recursively
};

greet(); // Works
// sayHello(); // Error - name only available inside function
```

---

## Invocation Context

The **invocation context** refers to how and where a function is called, which determines the value of `this`.

### Example: Same Function, Different Contexts

```javascript
function showContext() {
  console.log(this);
}

// 1. Function invocation
showContext(); // window/undefined

// 2. Method invocation
const obj = { method: showContext };
obj.method(); // obj

// 3. Constructor invocation
new showContext(); // {} (new object)

// 4. Indirect invocation
showContext.call({ custom: "object" }); // { custom: "object" }
```

---

## Common Patterns

### Pattern 1: Method Borrowing

```javascript
const obj1 = {
  name: "Object 1",
  getName: function () {
    return this.name;
  },
};

const obj2 = {
  name: "Object 2",
};

// Borrow method from obj1
const name = obj1.getName.call(obj2);
console.log(name); // "Object 2"
```

### Pattern 2: Function Aliasing

```javascript
const obj = {
  name: "John",
  greet: function () {
    console.log(this.name);
  },
};

const greetFn = obj.greet; // Alias
greetFn(); // undefined (lost context)

// Solution: Bind
const boundGreet = obj.greet.bind(obj);
boundGreet(); // "John"
```

### Pattern 3: Callback Invocation

```javascript
const obj = {
  name: "John",
  process: function (callback) {
    callback(); // Function invocation - this = window/undefined
  },
};

obj.process(function () {
  console.log(this.name); // undefined
});

// Solution: Arrow function or bind
obj.process(() => {
  console.log(this.name); // "John" (if in non-strict, window.name)
});
```

---

## Summary

| Invocation Type | Syntax           | `this` Binding                                         |
| --------------- | ---------------- | ------------------------------------------------------ |
| **Function**    | `func()`         | `window`/`global` (non-strict) or `undefined` (strict) |
| **Method**      | `obj.method()`   | The object (`obj`)                                     |
| **Constructor** | `new Func()`     | New instance                                           |
| **Indirect**    | `func.call(obj)` | First argument (`obj`)                                 |
| **Arrow**       | `arrowFn()`      | Lexical (from outer scope)                             |

### Key Takeaways

1. **How a function is invoked** determines `this` (for regular functions)
2. **Where an arrow function is defined** determines `this` (for arrow functions)
3. **Method invocation** binds `this` to the object
4. **Constructor invocation** creates a new object and binds `this` to it
5. **Indirect invocation** allows explicit `this` binding
6. **Function context can be lost** when methods are detached from objects

---

> ðŸ“– **Related Topics:**
>
> - [2. Understanding this Binding.md](./2.%20Understanding%20this%20Binding.md) - Overview of `this` binding
> - [3. Default Binding.md](./3.%20Default%20Binding.md) - Default/global binding
> - [4. Implicit Binding.md](./4.%20Implicit%20Binding.md) - Method invocation binding
> - [6. new Binding.md](./6.%20new%20Binding.md) - Constructor binding
> - [5. Explicit Binding (call, apply, bind).md](<./5.%20Explicit%20Binding%20(call,%20apply,%20bind).md>) - Indirect invocation
