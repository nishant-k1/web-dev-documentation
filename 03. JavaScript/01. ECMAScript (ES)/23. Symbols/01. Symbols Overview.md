# Symbols Overview

Symbols are a unique primitive data type introduced in ES6 that provide a way to create unique, immutable identifiers.

## Key Characteristics

- **Unique**: Each Symbol is guaranteed to be unique, even if created with the same description
- **Immutable**: Symbols cannot be changed once created
- **Non-enumerable**: Symbols don't appear in standard iteration (for...in, Object.keys())
- **Primitive Type**: Symbols are primitives, not objects

## Basic Usage

```javascript
const sym1 = Symbol();
const sym2 = Symbol("description");
const sym3 = Symbol("description");

console.log(sym2 === sym3); // false - each Symbol is unique
```

---

## Symbol Methods

### `Symbol.for(key)` ‚≠ê‚≠ê‚≠ê

Searches for existing symbol in **global symbol registry** with the given key. If found, returns it. Otherwise, creates new symbol and adds it to registry.

**Key Difference:** Symbols created with `Symbol.for()` are **shared** (same key = same symbol).

```javascript
// Global symbol registry
const sym1 = Symbol.for("shared");
const sym2 = Symbol.for("shared");

console.log(sym1 === sym2); // true (same symbol!)
console.log(sym1 === Symbol("shared")); // false (different symbol)
```

**Use Cases:**

- Shared symbols across modules/contexts
- Symbol registry for framework/library internals

### `Symbol.keyFor(sym)`

Returns the **key** for a symbol from the global symbol registry. Returns `undefined` if symbol is not in registry.

```javascript
const globalSym = Symbol.for("mySymbol");
const localSym = Symbol("mySymbol");

Symbol.keyFor(globalSym); // "mySymbol"
Symbol.keyFor(localSym); // undefined (not in registry)
Symbol.keyFor(Symbol("test")); // undefined
```

**Note:** Only works with symbols created via `Symbol.for()`.

---

## Well-Known Symbols

JavaScript defines several well-known symbols used for meta-programming:

### `Symbol.iterator` ‚≠ê‚≠ê‚≠ê‚≠ê

Used to define the default iterator for an object. Used by `for...of` loops, spread operator, etc.

```javascript
const obj = {
  [Symbol.iterator]() {
    let count = 0;
    return {
      next() {
        count++;
        return count <= 3 ? { value: count, done: false } : { done: true };
      },
    };
  },
};

[...obj]; // [1, 2, 3]
```

üìñ See: [20. Iterators and Iterables](../../20.%20Iterators%20and%20Iterables/) for comprehensive details

### `Symbol.toPrimitive`

Used to define how an object converts to a primitive value.

```javascript
const obj = {
  [Symbol.toPrimitive](hint) {
    if (hint === "number") return 42;
    if (hint === "string") return "hello";
    return true;
  },
};

+obj; // 42 (number hint)
String(obj); // "hello" (string hint)
```

### `Symbol.toStringTag`

Used to customize the default string description of an object.

```javascript
class MyClass {
  get [Symbol.toStringTag]() {
    return "MyCustomClass";
  }
}

Object.prototype.toString.call(new MyClass()); // "[object MyCustomClass]"
```

### Other Well-Known Symbols

- `Symbol.hasInstance` - Customize `instanceof` behavior
- `Symbol.isConcatSpreadable` - Control array spreading in `concat()`
- `Symbol.match` - Used by `String.prototype.match()`
- `Symbol.replace` - Used by `String.prototype.replace()`
- `Symbol.search` - Used by `String.prototype.search()`
- `Symbol.split` - Used by `String.prototype.split()`
- `Symbol.species` - Used to create derived objects

---

## Common Use Cases

- Creating unique object property keys
- Defining well-known symbols (Symbol.iterator, Symbol.toStringTag, etc.)
- Preventing property name collisions in objects
- Implementing meta-programming patterns
- Shared symbols across modules (Symbol.for)
- Customizing built-in behavior (toPrimitive, toStringTag)

---

## Interview Common Questions

### Q: Difference between `Symbol()` and `Symbol.for()`?

- `Symbol()` - Always creates a **new unique** symbol
- `Symbol.for(key)` - Uses **global registry**, returns same symbol for same key

### Q: Can you get the key from a symbol created with `Symbol()`?

No, only symbols created with `Symbol.for()` can be retrieved with `Symbol.keyFor()`.

### Q: Why use Symbol as object keys?

- Prevents name collisions
- Non-enumerable (won't appear in Object.keys(), for...in)
- Unique identifiers
- Can be shared via Symbol.for() if needed
