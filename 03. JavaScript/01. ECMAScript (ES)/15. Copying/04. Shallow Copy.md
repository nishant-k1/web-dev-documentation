# Shallow Copy

Shallow copy creates a new object/array and copies only the top-level properties or elements. Nested objects or arrays are still references.

## Key Characteristics

- Only the top-level properties or elements are copied.
- Nested objects or arrays are still references.
- Creates a new object/array but only copies the top-level properties.
- If the property values are objects or arrays, the reference is copied instead of duplicating the nested structures.

## Shallow Copy for Plain Objects

### 1. Using Spread Operator `{ ... }`

```js
let obj1 = { a: 1, b: { c: 2 } };
let obj2 = { ...obj1 };

obj2.a = 10; // Only obj2 changes
obj2.b.c = 20; // Both obj1 and obj2 change (nested reference)
console.log(obj1); // { a: 1, b: { c: 20 } }
console.log(obj2); // { a: 10, b: { c: 20 } }
```

### 2. Using `Object.assign()`

```js
let obj1 = { a: 1, b: { c: 2 } };
let obj2 = Object.assign({}, obj1);

obj2.a = 10; // Only obj2 changes
obj2.b.c = 20; // Both obj1 and obj2 change (nested reference)
```

### 3. Using `Object.create()` with `Object.getOwnPropertyDescriptors()`

```js
let obj1 = { a: 1, b: { c: 2 } };
let obj2 = Object.create(
  Object.getPrototypeOf(obj1),
  Object.getOwnPropertyDescriptors(obj1)
);
```

## Shallow Copy for Arrays

### 1. Using Spread Operator `[ ... ]`

```js
const arr1 = [1, 2, 3];
const arr2 = [...arr1];
arr2.push(4);
console.log(arr1); // [1, 2, 3]
console.log(arr2); // [1, 2, 3, 4]
```

### 2. Using `Array.prototype.slice()`

```js
const arr1 = [1, 2, 3];
const arr2 = arr1.slice();
arr2.push(4);
console.log(arr1); // [1, 2, 3]
console.log(arr2); // [1, 2, 3, 4]
```

### 3. Using `Array.from()`

```js
const arr1 = [1, 2, 3];
const arr2 = Array.from(arr1);
arr2.push(4);
console.log(arr1); // [1, 2, 3]
console.log(arr2); // [1, 2, 3, 4]
```

### 4. Using `Array.prototype.concat()`

```js
const arr1 = [1, 2, 3];
const arr2 = [].concat(arr1);
arr2.push(4);
console.log(arr1); // [1, 2, 3]
console.log(arr2); // [1, 2, 3, 4]
```

## Important Notes

- **Top-level independence** - Top-level properties are independent
- **Nested references** - Nested objects/arrays still share references
- **Common in React** - Used frequently in React state updates
- **Performance** - Faster than deep copy

## When to Use

- When you only need to copy top-level properties
- When nested objects don't need to be independent
- Common in React state updates
- When performance is important and nested structures are simple

## Limitations

- **Nested objects are not copied** - Changes to nested objects affect the original
- **Not suitable for deep structures** - If you need nested independence, use deep copy
