# FP Patterns: Currying and Partial Application

---

## Currying

- Function currying is a technique in which a function with multiple arguments is transformed into a sequence of functions, each taking a single argument.
- Currying is the technique of translating the evaluation of a function that takes multiple arguments into evaluating a sequence of functions, each with single argument.
- By the use of currying we can create multiple utility functions out of this.
- Currying expects one argument at a time.

---

## Basic Currying Example

```javascript
const multiply = (a, b) => a * b;
const curriedMultiply = (a) => (b) => a * b;
curriedMultiply(5)(3); // 15
```

---

## Creating Utility Functions with Currying

```javascript
// EG: use currying to create a utility function
const multiply = (a, b) => a * b;
const curriedMultiply = (a) => (b) => a * b;

// creating utility function using currying
const curriedMultiplyBy5 = curriedMultiply(5);
curriedMultiplyBy5(3); // 15
curriedMultiplyBy5(4); // 20
```

---

## Function Currying Using bind()

Currying refers to supplying partial arguments to function parameters.

```javascript
function multiply(a, b) {
  return a * b;
}

const multiplyByTwo = multiply.bind(this, 2); // supplying 1st parameter
const multiplyByTen = multiply.bind(this, 10); // supplying 1st parameter
multiplyByTwo(4); // supplying 2nd parameter - returns 8
multiplyByTen(4); // supplying 2nd parameter - returns 40
```

---

## Advantages of Currying

- **Partial Application**: You can create specialized versions of a function by providing some of the arguments in advance, which can be very useful in situations where you want to reuse a function with varying parameters.

- **Modularity and Reusability**: Curried functions can be used to create smaller, more focused functions that can be combined to form more complex functions. This promotes code modularity and reusability.

- **Better Function Composition**: Currying can make it easier to compose functions together, which is a fundamental concept in functional programming.

- **Higher-Order Functions**: Currying is often used in conjunction with higher-order functions, allowing for powerful abstractions and code that is easier to reason about.

---

## Drawbacks of Currying

- **Complexity for Simple Cases**: In some cases, function currying can introduce unnecessary complexity, especially for functions that don't benefit from partial application.

- **Readability**: Curried functions can be harder to read and understand for those unfamiliar with this programming paradigm.

---

## Partial Application

- It is a way to partially apply a function.
- It's a process of producing a function with a smaller number of parameters.
- It means taking a function, applying some of its arguments into the function. So it remembers those parameters and then it uses closures to later on be called with all the rest of the arguments.
- In partial application the second call expects all the remaining arguments.

```javascript
const multiply = (a, b, c) => a * b * c;
const partialMultiply = multiply.bind(null, 5);
partialMultiply(4, 10); // 5 * 4 * 10 = 200
```

---

## Currying vs Partial Application

| Feature            | Currying             | Partial Application            |
| ------------------ | -------------------- | ------------------------------ |
| **Arguments**      | One at a time        | Multiple at once               |
| **Function Chain** | `fn(a)(b)(c)`        | `fn(a, b)(c)` or `fn(a)(b, c)` |
| **Use Case**       | Function composition | Pre-filling some arguments     |
| **Flexibility**    | More flexible        | Less flexible                  |

### Example: Currying

```js
const add = (a) => (b) => (c) => a + b + c;
add(1)(2)(3); // 6
```

### Example: Partial Application

```js
const add = (a, b, c) => a + b + c;
const addWithFirst = add.bind(null, 1);
addWithFirst(2, 3); // 6
```

---

## Arity

- It simply means number of arguments a function takes.
- The more parameters a function has, the harder it is to really compose it with other functions.
- Generally, we should not prefer more than 2 parameters.

---

## bind() Use Cases

### Function.prototype.bind

Purpose: Creates a new function with a specified `this` value and initial arguments.

```javascript
const obj = {
  x: 42,
  getX: function () {
    return this.x;
  },
};

const unboundGetX = obj.getX;
console.log(unboundGetX()); // undefined

const boundGetX = unboundGetX.bind(obj);
console.log(boundGetX()); // 42
```

### Using bind() for Currying/Partial Application

```js
function multiply(a, b, c) {
  return a * b * c;
}

// Partial application - fix first argument
const multiplyBy2 = multiply.bind(null, 2);
multiplyBy2(3, 4); // 2 * 3 * 4 = 24

// Partial application - fix first two arguments
const multiplyBy2And3 = multiply.bind(null, 2, 3);
multiplyBy2And3(4); // 2 * 3 * 4 = 24
```

---

## Real-World Examples

### API Request Builder

```js
const apiRequest = (method) => (url) => (data) => {
  return fetch(url, {
    method,
    body: JSON.stringify(data),
  });
};

const post = apiRequest("POST");
const postToUsers = post("/api/users");
postToUsers({ name: "John" });
```

### Event Handler Factory

```js
const createEventHandler = (eventType) => (handler) => (element) => {
  element.addEventListener(eventType, handler);
};

const onClick = createEventHandler("click");
const handleClick = onClick(() => console.log("Clicked"));
handleClick(button);
```

---

## Interview Points

- Currying transforms multi-argument functions into single-argument function chains
- Partial application fixes some arguments and returns a function expecting the rest
- Both enable function reuse and composition
- `bind()` can be used for partial application
- Currying is more flexible but can be harder to read
- Arity (number of parameters) affects composability
- Useful for creating utility functions and function factories
