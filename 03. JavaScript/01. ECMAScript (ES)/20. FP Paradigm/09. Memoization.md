# FP Patterns: Memoization

- Caching is a way to store values so you can use them later on.
- It is just a way to speed up programs and hold some piece of data in an easily accessible box.
- Memoization is a specific form of caching that involves caching the return value.
- It is simply a way to remember a solution to a problem so you don't have to calculate it again.

---

## What is Memoization?

Memoization is an optimization technique used to speed up programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again.

---

## Example 1: Without Memoization

```javascript
// Eg1: Without Memoization
function addTo80(n) {
  console.log("long time");
  return n + 80;
}
// everytime we call addTo80 function it's always going to take a long time.
addTo80(5);
addTo80(5);
addTo80(5);
// Each call executes the function again
```

---

## Example 2: With Memoization (Global Cache)

```javascript
// Eg2: With Memoization
let cache = {
  5: 85,
};
function memoizedAddTo80(n) {
  if (n in cache) {
    return cache[n];
  } else {
    cache[n] = n + 80;
    return cache[n];
  }
}

memoizedAddTo80(5);
memoizedAddTo80(5); // returns cached value
memoizedAddTo80(5);
```

---

## Example 3: With Memoization (Closure)

In Memoization, ideally we don't want to fill the cache in what we call the global scope. Ideally it is good to have the state live inside the function. We can achieve this using closure.

```javascript
// Eg3: In Memoization, ideally we don't want to fill the cache in what we call the global scope. Ideally it is good to have the state live inside the function. We can achieve this using closure.

function memoizedAddTo80() {
  let cache = {};
  return function (n) {
    if (n in cache) {
      return cache[n];
    } else {
      cache[n] = n + 80;
      return cache[n];
    }
  };
}

const memoized = memoizedAddTo80();
console.log("1", memoized(5)); // returns memoized 85
console.log("2", memoized(5)); // returns memoized 85 (from cache)
```

---

## Generic Memoization Function

```js
function memoize(fn) {
  const cache = {};
  return function (...args) {
    const key = JSON.stringify(args);
    if (key in cache) {
      return cache[key];
    }
    cache[key] = fn.apply(this, args);
    return cache[key];
  };
}

// Usage
const slowFunction = (n) => {
  // Expensive computation
  return n * 2;
};

const memoizedSlowFunction = memoize(slowFunction);
memoizedSlowFunction(5); // Computes
memoizedSlowFunction(5); // Returns from cache
```

---

## Memoization with Fibonacci

```js
function fibonacci(n) {
  if (n < 2) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}

// Without memoization - very slow for large n
fibonacci(40); // Takes a long time

// With memoization
const memoizedFibonacci = memoize(function (n) {
  if (n < 2) return n;
  return memoizedFibonacci(n - 1) + memoizedFibonacci(n - 2);
});

memoizedFibonacci(40); // Much faster
```

---

## Benefits of Memoization

1. **Performance**: Dramatically speeds up repeated function calls
2. **Efficiency**: Reduces redundant computations
3. **Scalability**: Makes expensive operations feasible
4. **User Experience**: Faster response times

---

## When to Use Memoization

✅ **Good for:**

- Expensive computations (factorials, Fibonacci, complex calculations)
- Pure functions (same input = same output)
- Functions called repeatedly with same arguments
- Recursive functions

❌ **Avoid for:**

- Functions with side effects
- Functions that depend on external state
- Functions with many different inputs (cache becomes too large)
- Simple, fast functions (overhead not worth it)

---

## React: useMemo Hook

React provides `useMemo` for memoizing computed values:

```jsx
const expensiveValue = useMemo(() => {
  return computeExpensiveValue(a, b);
}, [a, b]); // Only recompute when a or b changes
```

---

## Interview Points

- Memoization caches function results to avoid recomputation
- Best used with pure functions
- Can be implemented using closures to keep cache private
- Trade-off: memory usage vs computation time
- React's `useMemo` and `useCallback` are memoization hooks
- Useful for expensive calculations, recursive functions, and API calls
- Cache key should uniquely identify function arguments
