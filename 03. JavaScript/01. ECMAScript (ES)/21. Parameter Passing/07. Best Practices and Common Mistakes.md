# Best Practices and Common Mistakes

Following best practices helps you write predictable code and avoid bugs related to parameter passing.

---

## Best Practices

### 1. Document Mutations

If a function mutates its parameters, document it clearly.

```javascript
/**
 * Modifies the user object in place.
 * @param {Object} user - User object (will be modified)
 */
function updateUser(user) {
  user.lastLogin = new Date();
  user.loginCount++;
}

// Or use naming conventions
function mutateUser(user) {
  // Name suggests mutation
  user.updated = true;
}
```

---

### 2. Prefer Immutability

Return new objects instead of mutating parameters when possible.

```javascript
// ✅ Good - Immutable
function createUpdatedUser(user) {
  return {
    ...user,
    lastLogin: new Date(),
    loginCount: user.loginCount + 1,
  };
}

// ❌ Bad - Mutates
function updateUser(user) {
  user.lastLogin = new Date();
  user.loginCount++;
}
```

**Benefits:**

- Easier to reason about
- Better for React/Redux
- Prevents unintended side effects
- Easier to test

---

### 3. Create New Default Objects

Default object parameters are shared. Create new ones each time.

```javascript
// ❌ Bad - Shared default object
function processData(options = {}) {
  options.processed = true; // Mutates shared default
  return options;
}

// ✅ Good - Create new object each time
function processData(options) {
  options = options || {};
  options.processed = true;
  return options;
}

// ✅ Also good - Use function to create default
function processData(options = createDefaultOptions()) {
  // createDefaultOptions() called each time
  options.processed = true;
  return options;
}
```

---

### 4. Use Const for Parameters

Use `const` for parameters to prevent accidental reassignment.

```javascript
function processData(data) {
  // data is const (can't reassign)
  // data = {}; // Error in strict mode or with const

  // But can still modify properties
  data.property = "value"; // OK
}
```

---

### 5. Copy When Needed

If you need to modify but preserve the original, copy first.

```javascript
function safeModify(obj) {
  const copy = { ...obj }; // Shallow copy
  copy.property = "modified";
  return copy;
}

// For deep objects
function safeDeepModify(obj) {
  const copy = structuredClone(obj); // Deep copy
  copy.nested.property = "modified";
  return copy;
}
```

---

## Common Mistakes

### Mistake 1: Expecting Reassignment to Work

```javascript
// ❌ Wrong expectation
function replaceObject(obj) {
  obj = { new: "object" }; // Doesn't affect original
}

let original = { old: "object" };
replaceObject(original);
console.log(original); // { old: "object" } - not replaced!

// ✅ Correct approach
function replaceObject(obj) {
  // Return new object, let caller reassign
  return { new: "object" };
}

let original = { old: "object" };
original = replaceObject(original); // Reassign original variable
```

---

### Mistake 2: Mutating Shared Default Objects

```javascript
// ❌ Bad - Shared default
function addItem(list = []) {
  list.push("item");
  return list;
}

let result1 = addItem(); // ["item"]
let result2 = addItem(); // ["item", "item"] - accumulates!

// ✅ Good - New array each time
function addItem(list) {
  list = list || [];
  list.push("item");
  return list;
}
```

---

### Mistake 3: Assuming Primitives Can Be Modified

```javascript
// ❌ Wrong - Can't modify primitives
function increment(num) {
  num++; // Only affects local copy
}

let count = 10;
increment(count);
console.log(count); // 10 - not incremented!

// ✅ Correct - Return new value
function increment(num) {
  return num + 1;
}

let count = 10;
count = increment(count); // 11
```

---

### Mistake 4: Not Understanding Nested References

```javascript
// ❌ Unexpected mutation
function updateNested(data) {
  data.user.profile.name = "Updated"; // Modifies original
}

let original = {
  user: {
    profile: { name: "Original" },
  },
};

updateNested(original);
console.log(original.user.profile.name); // "Updated" - modified!

// ✅ Create deep copy if needed
function safeUpdateNested(data) {
  const copy = structuredClone(data);
  copy.user.profile.name = "Updated";
  return copy;
}
```

---

### Mistake 5: Mutating Arrays Unexpectedly

```javascript
// ❌ Mutates original array
function processItems(items) {
  return items.sort().reverse(); // Mutates items!
}

let numbers = [3, 1, 2];
let result = processItems(numbers);
console.log(numbers); // [3, 2, 1] - modified!
console.log(result); // [3, 2, 1] - same reference

// ✅ Don't mutate
function processItems(items) {
  return [...items].sort().reverse(); // New array
}

let numbers = [3, 1, 2];
let result = processItems(numbers);
console.log(numbers); // [3, 1, 2] - unchanged
console.log(result); // [3, 2, 1] - new array
```

---

### Mistake 6: Confusing Assignment with Mutation

```javascript
// Understanding the difference
let obj = { a: 1 };

function test1(o) {
  o.a = 2; // Mutation - affects original
}

function test2(o) {
  o = { a: 2 }; // Assignment - doesn't affect original
}

test1(obj);
console.log(obj); // { a: 2 } - modified

obj = { a: 1 }; // Reset
test2(obj);
console.log(obj); // { a: 1 } - unchanged
```

---

## Patterns to Follow

### Pattern 1: Immutable Updates

```javascript
// Always return new objects
function updateUser(user, updates) {
  return { ...user, ...updates };
}

let user = { name: "John", age: 25 };
let updated = updateUser(user, { age: 26 });
console.log(user); // { name: "John", age: 25 } (unchanged)
console.log(updated); // { name: "John", age: 26 } (new object)
```

---

### Pattern 2: Explicit Mutation

```javascript
// If you must mutate, make it explicit
function mutateUserInPlace(user) {
  // Clearly named to indicate mutation
  user.updated = true;
  user.timestamp = Date.now();
}

// Or use a class method
class User {
  update() {
    this.updated = true;
    this.timestamp = Date.now();
  }
}
```

---

### Pattern 3: Builder Pattern

```javascript
// Chain operations without mutation
function createUser() {
  let user = {};

  return {
    setName(name) {
      user = { ...user, name };
      return this;
    },
    setAge(age) {
      user = { ...user, age };
      return this;
    },
    build() {
      return user;
    },
  };
}

let user = createUser().setName("John").setAge(25).build();
```

---

## Debugging Tips

### Tip 1: Log Before and After

```javascript
function processData(data) {
  console.log("Before:", JSON.stringify(data));
  // ... processing ...
  console.log("After:", JSON.stringify(data));
}
```

### Tip 2: Use Object.freeze() for Testing

```javascript
let testData = Object.freeze({ value: 10 });

function process(data) {
  data.value = 20; // Will throw in strict mode
}

process(testData); // Error if trying to mutate
```

### Tip 3: Check References

```javascript
function checkReference(obj1, obj2) {
  console.log(obj1 === obj2); // true if same reference
  console.log(Object.is(obj1, obj2)); // Also checks reference
}
```

---

## Summary

### ✅ Do

- Document mutations clearly
- Prefer immutability when possible
- Create new objects for defaults
- Copy objects when you need to modify
- Use const for parameters
- Return new objects instead of mutating

### ❌ Don't

- Don't expect reassignment to affect originals
- Don't use shared default objects
- Don't assume primitives can be modified
- Don't mutate without documenting
- Don't confuse assignment with mutation
- Don't mutate arrays unexpectedly

---

## Related Topics

- [02. Pass By Value.md](./02.%20Pass%20By%20Value.md) - Primitive passing
- [03. Pass By Reference.md](./03.%20Pass%20By%20Reference.md) - Object passing
- [05. Common Patterns and Use Cases.md](./05.%20Common%20Patterns%20and%20Use%20Cases.md) - Practical patterns
- [06. Common Interview Questions.md](./06.%20Common%20Interview%20Questions.md) - Interview scenarios
