# Class Declarations (class keyword)

Class declarations are used to define classes in JavaScript. Introduced in ES6 (ES2015), classes provide a more familiar syntax for creating objects and dealing with inheritance, but they are essentially syntactic sugar over JavaScript's existing prototype-based inheritance.

## Syntax

```js
class ClassName {
  constructor(parameters) {
    // Constructor body
  }
  
  method1() {
    // Method body
  }
  
  method2() {
    // Method body
  }
}
```

## Key Characteristics

- **Scope**: Block-scoped (like `let` and `const`)
- **Hoisting**: Hoisted but in **Temporal Dead Zone (TDZ)** until the declaration line
- **Storage**: Stored in **Lexical Environment** (not Variable Environment)
- **Re-declaration**: Cannot be re-declared within the same scope
- **Access Before Declaration**: Throws a `ReferenceError` if accessed before the declaration (TDZ)
- **No Function Hoisting**: Unlike function declarations, class declarations are not fully hoisted

## Hoisting Behavior

Class declarations are hoisted, but the class body is not initialized until the declaration line:

```js
// ❌ ReferenceError - class is in TDZ
const instance = new MyClass();

class MyClass {
  constructor() {
    this.name = "Example";
  }
}

// ✅ Works - class is declared
const instance = new MyClass();
```

## Comparison with Function Declarations

| Feature | Function Declaration | Class Declaration |
|---------|---------------------|-------------------|
| Hoisting | Fully hoisted (body available) | Hoisted but in TDZ |
| Storage | Variable Environment | Lexical Environment |
| Access Before Declaration | ✅ Works | ❌ ReferenceError |
| Scope | Function-scoped | Block-scoped |
| Re-declaration | Can be re-declared (in same scope) | Cannot be re-declared |

## Class Expressions

Similar to function expressions, you can create class expressions:

```js
// Anonymous class expression
const MyClass = class {
  constructor() {}
};

// Named class expression
const MyClass = class NamedClass {
  constructor() {}
};

// Hoisting behavior follows the variable declaration
// If assigned to `var`: hoisted but undefined
// If assigned to `let`/`const`: in TDZ
```

## Class Features

### Constructor

The `constructor` method is a special method for creating and initializing objects:

```js
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
}

const person = new Person("John", 30);
```

### Methods

Methods are defined inside the class body:

```js
class Person {
  constructor(name) {
    this.name = name;
  }
  
  greet() {
    return `Hello, I'm ${this.name}`;
  }
  
  static staticMethod() {
    return "This is a static method";
  }
}
```

### Static Methods

Static methods are called on the class itself, not on instances:

```js
class MathUtils {
  static add(a, b) {
    return a + b;
  }
}

MathUtils.add(5, 3); // 8
```

### Getters and Setters

```js
class Person {
  constructor(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
  }
  
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
  
  set fullName(name) {
    [this.firstName, this.lastName] = name.split(' ');
  }
}

const person = new Person("John", "Doe");
console.log(person.fullName); // "John Doe"
person.fullName = "Jane Smith";
```

### Private Fields (ES2022)

Private fields are prefixed with `#`:

```js
class Person {
  #privateField = "private";
  
  #privateMethod() {
    return this.#privateField;
  }
  
  publicMethod() {
    return this.#privateMethod();
  }
}
```

## Inheritance

Classes support inheritance using the `extends` keyword:

```js
class Animal {
  constructor(name) {
    this.name = name;
  }
  
  speak() {
    return `${this.name} makes a sound`;
  }
}

class Dog extends Animal {
  constructor(name, breed) {
    super(name); // Call parent constructor
    this.breed = breed;
  }
  
  speak() {
    return `${this.name} barks`;
  }
}

const dog = new Dog("Buddy", "Golden Retriever");
console.log(dog.speak()); // "Buddy barks"
```

## Important Notes

1. **Strict Mode**: Class bodies are always in strict mode
2. **No Hoisting of Body**: Unlike functions, class bodies are not hoisted
3. **Must Use `new`**: Classes must be instantiated with the `new` keyword
4. **Prototype-Based**: Classes are still prototype-based under the hood
5. **No Function Hoisting**: You cannot call a class before it's declared (TDZ)
6. **Constructor Required**: If no constructor is defined, an empty one is automatically created

## Comparison with Constructor Functions

| Feature | Constructor Function | Class Declaration |
|---------|---------------------|-------------------|
| Syntax | `function Name() {}` | `class Name {}` |
| Hoisting | Fully hoisted | Hoisted but in TDZ |
| Strict Mode | Optional | Always |
| Inheritance | Manual prototype setup | `extends` keyword |
| Method Definition | `Name.prototype.method = ...` | `method() {}` in class body |
