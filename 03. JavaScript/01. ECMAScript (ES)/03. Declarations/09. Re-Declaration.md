# Re-declaration

Re-declaration refers to declaring the same identifier (name) multiple times within the same scope or across different scopes. The rules vary depending on the declaration type.

## Re-declaration within the Same Scope

### 1. Variable Declarations (`var`, `let`, `const`)

#### `var`

- ✅ **Can be re-declared** within the same scope
- Re-declaring overwrites the previous declaration
- If a `var` variable and a `function` are declared with the same identifier within the same scope, the function declaration takes precedence

```js
var x = 10;
var x = 20; // ✅ Allowed - overwrites previous declaration
console.log(x); // 20

var y = 5;
function y() {} // Function takes precedence
console.log(typeof y); // "function"
```

#### `let`

- ❌ **Cannot be re-declared** within the same scope
- Re-declaring results in a `SyntaxError`

```js
let x = 10;
let x = 20; // ❌ SyntaxError: Identifier 'x' has already been declared
```

#### `const`

- ❌ **Cannot be re-declared** within the same scope
- Similar to `let`, re-declaring causes a `SyntaxError`

```js
const x = 10;
const x = 20; // ❌ SyntaxError: Identifier 'x' has already been declared
```

### 2. Function Declarations

- ✅ **Can be re-declared** within the same scope
- The last declaration overwrites previous ones
- Function declarations are hoisted, so the last one wins

```js
function greet() {
  return "Hello";
}

function greet() {
  return "Hi"; // ✅ Allowed - overwrites previous declaration
}

console.log(greet()); // "Hi"
```

### 3. Class Declarations

- ❌ **Cannot be re-declared** within the same scope
- Re-declaring results in a `SyntaxError`

```js
class MyClass {}
class MyClass {} // ❌ SyntaxError: Identifier 'MyClass' has already been declared
```

### 4. Module Declarations (`import`)

- ❌ **Cannot be re-declared** within the same module
- Each imported identifier must be unique in the module scope

```js
import { name } from "./module.js";
import { name } from "./other.js"; // ❌ SyntaxError: Identifier 'name' has already been declared

// ✅ Solution: Use aliases
import { name as name1 } from "./module.js";
import { name as name2 } from "./other.js";
```

### 5. Generator Function Declarations (`function*`)

- ✅ **Can be re-declared** within the same scope (follows function declaration rules)
- The last declaration overwrites previous ones

```js
function* gen() {
  yield 1;
}

function* gen() {
  yield 2; // ✅ Allowed
}

const g = gen();
console.log(g.next().value); // 2
```

### 6. Async Function Declarations (`async function`)

- ✅ **Can be re-declared** within the same scope (follows function declaration rules)
- The last declaration overwrites previous ones

```js
async function fetchData() {
  return "data1";
}

async function fetchData() {
  return "data2"; // ✅ Allowed
}
```

## Re-declaration in Inner Scopes (Shadowing)

When you declare an identifier in an inner scope with the same name as one in an outer scope, it **shadows** (hides) the outer declaration within that inner scope.

### All Declaration Types Can Shadow

All declaration types (`var`, `let`, `const`, `function`, `class`, `import`, `function*`, `async function`) can shadow outer declarations:

```js
// Outer scope
let x = 10;
const y = 20;
function z() {}
class A {}

{
  // Inner scope - all shadow outer declarations
  let x = 100; // ✅ Shadows outer x
  const y = 200; // ✅ Shadows outer y
  function z() {} // ✅ Shadows outer z
  class A {} // ✅ Shadows outer A
}
```

### Important Notes on Shadowing

1. **Shadowing is allowed** - Inner scope declarations hide outer ones
2. **Different scopes** - No conflict because they're in different scopes
3. **Block scope vs Function scope** - `let`, `const`, and `class` are block-scoped; `var` and `function` are function-scoped

```js
function outer() {
  var x = 10;
  let y = 20;

  if (true) {
    var x = 100; // ✅ Shadows (same function scope)
    let y = 200; // ✅ Shadows (new block scope)
    console.log(x, y); // 100, 200
  }

  console.log(x, y); // 100, 20 (var is function-scoped, let is block-scoped)
}
```

## Interactions Between Different Declaration Types

### `var` and `function` in Same Scope

- If both are declared in the same scope, the **function declaration takes precedence**
- This is due to function hoisting

```js
var myFunc = 10;
function myFunc() {
  return "Hello";
}

console.log(typeof myFunc); // "function" (function takes precedence)
```

### `let`/`const` and `function` in Same Scope

- ❌ **Cannot coexist** - Results in `SyntaxError`
- `let`/`const` and `function` cannot share the same identifier in the same scope

```js
let myFunc = 10;
function myFunc() {} // ❌ SyntaxError: Identifier 'myFunc' has already been declared
```

### `class` and `function` in Same Scope

- ❌ **Cannot coexist** - Results in `SyntaxError`

```js
class MyClass {}
function MyClass() {} // ❌ SyntaxError: Identifier 'MyClass' has already been declared
```

### `let`/`const` and `class` in Same Scope

- ❌ **Cannot coexist** - Results in `SyntaxError`

```js
let MyClass = 10;
class MyClass {} // ❌ SyntaxError: Identifier 'MyClass' has already been declared
```

## Summary Table

| Declaration Type | Re-declare in Same Scope | Shadow in Inner Scope | Notes                                        |
| ---------------- | ------------------------ | --------------------- | -------------------------------------------- |
| `var`            | ✅ Yes                   | ✅ Yes                | Function-scoped                              |
| `let`            | ❌ No                    | ✅ Yes                | Block-scoped                                 |
| `const`          | ❌ No                    | ✅ Yes                | Block-scoped                                 |
| `function`       | ✅ Yes                   | ✅ Yes                | Function-scoped, takes precedence over `var` |
| `class`          | ❌ No                    | ✅ Yes                | Block-scoped                                 |
| `import`         | ❌ No                    | ✅ Yes                | Module-scoped                                |
| `function*`      | ✅ Yes                   | ✅ Yes                | Function-scoped (follows function rules)     |
| `async function` | ✅ Yes                   | ✅ Yes                | Function-scoped (follows function rules)     |

## Best Practices

1. **Avoid re-declaration** - Use unique names to prevent confusion
2. **Use `let`/`const`** - They prevent accidental re-declarations
3. **Be careful with shadowing** - It can make code harder to read
4. **Use descriptive names** - Reduces chance of naming conflicts
5. **Use modules** - Module scope prevents global namespace pollution
