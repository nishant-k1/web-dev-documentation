# Async Generator Function Declarations (async function\*)

Async generator functions combine the features of async functions and generator functions. They allow you to create generators that can yield values asynchronously. They are declared using the `async function*` syntax. Introduced in ES2018.

## Quick Comparison: Async Function vs Async Generator Function

**Key Difference**: An async function returns **one Promise**, while an async generator function returns **multiple values over time** (one at a time, asynchronously).

| Aspect          | `async function`           | `async function*`                                       |
| --------------- | -------------------------- | ------------------------------------------------------- |
| **Syntax**      | `async function name() {}` | `async function* name() {}`                             |
| **Returns**     | Single Promise             | AsyncGenerator object                                   |
| **Values**      | Returns once (one value)   | Yields multiple times (many values)                     |
| **Usage**       | `await functionName()`     | `for await (const value of functionName())`             |
| **When to use** | Single async operation     | Multiple async values over time (streaming, pagination) |

### Example Comparison

```js
// Async Function - Returns ONE Promise with ONE value
async function fetchUser(id) {
  const response = await fetch(`/api/user/${id}`);
  return response.json(); // Returns once
}

const user = await fetchUser(1); // Get one user

// Async Generator Function - Yields MULTIPLE values over time
async function* fetchUsers(ids) {
  for (const id of ids) {
    const response = await fetch(`/api/user/${id}`);
    yield response.json(); // Yields multiple times
  }
}

// Get multiple users, one at a time
for await (const user of fetchUsers([1, 2, 3])) {
  console.log(user); // Processes each user as it arrives
}
```

## Syntax

```js
async function* generatorName() {
  yield await asyncOperation();
  yield await asyncOperation();
  return value;
}
```

## Key Characteristics

- **Scope**: Function-scoped (like regular function declarations)
- **Hoisting**: Fully hoisted (like regular function declarations)
- **Storage**: Stored in **Variable Environment** (not Lexical Environment)
- **Return Type**: Returns an **AsyncGenerator object** (not the yielded value directly)
- **Execution**: Can be paused with `yield` and `await`, resumed with `.next()`
- **Re-declaration**: Cannot be re-declared within the same scope

## How Async Generators Work

1. When called, an async generator function returns an **AsyncGenerator object**
2. The function body doesn't execute immediately
3. Execution starts when you call `.next()` on the async generator object
4. The function runs until it hits a `yield` statement, then pauses
5. The yielded value is wrapped in a Promise and returned
6. Execution resumes on the next `.next()` call (which returns a Promise)

### Example

```js
async function* fetchPages() {
  for (let i = 1; i <= 3; i++) {
    const response = await fetch(`/api/page/${i}`);
    yield response.json();
  }
}

const gen = fetchPages();

// Async generators return Promises
gen.next().then((result) => console.log(result)); // { value: {...}, done: false }
gen.next().then((result) => console.log(result)); // { value: {...}, done: false }
gen.next().then((result) => console.log(result)); // { value: {...}, done: false }
gen.next().then((result) => console.log(result)); // { value: undefined, done: true }
```

## The `yield` and `await` Keywords

- **`yield`**: Pauses execution and returns a value (wrapped in Promise)
- **`await`**: Waits for a Promise to resolve before continuing
- **`yield*`**: Delegates to another async generator or async iterable

```js
async function* gen1() {
  yield await Promise.resolve(1);
  yield await Promise.resolve(2);
}

async function* gen2() {
  yield* gen1(); // Delegates to gen1
  yield await Promise.resolve(3);
}

const gen = gen2();
gen.next().then((r) => console.log(r)); // { value: 1, done: false }
gen.next().then((r) => console.log(r)); // { value: 2, done: false }
gen.next().then((r) => console.log(r)); // { value: 3, done: false }
```

## Hoisting Behavior

Async generator function declarations are hoisted just like regular function declarations:

```js
// âœ… Works - async generator is hoisted
const gen = myAsyncGenerator();
gen.next().then((result) => console.log(result));

async function* myAsyncGenerator() {
  yield await Promise.resolve(1);
}
```

## Using with `for await...of`

The most common way to consume async generators is with `for await...of`:

```js
async function* fetchPages() {
  for (let i = 1; i <= 5; i++) {
    const response = await fetch(`/api/page/${i}`);
    yield response.json();
  }
}

// Consume with for await...of
async function displayPages() {
  for await (const page of fetchPages()) {
    console.log(page);
  }
}
```

## Async Generator Expressions

Similar to function expressions, you can create async generator expressions:

```js
// Async generator expression assigned to const
const gen = async function* () {
  yield await fetch("/api/data");
};

// Hoisting behavior follows the variable declaration
// If assigned to `var`: hoisted but undefined
// If assigned to `let`/`const`: in TDZ
```

## Use Cases

1. **Streaming Data**: Process data as it arrives (e.g., reading files, API responses)
2. **Pagination**: Fetch pages of data incrementally
3. **Real-time Data**: Handle streams of asynchronous events
4. **Backpressure**: Control the rate of data processing
5. **Infinite Async Sequences**: Generate values asynchronously on-demand

### Example: Streaming API Responses

```js
async function* streamAPI(endpoint) {
  let page = 1;
  while (true) {
    const response = await fetch(`${endpoint}?page=${page}`);
    const data = await response.json();

    if (data.length === 0) break;

    for (const item of data) {
      yield item;
    }

    page++;
  }
}

// Process items as they arrive
async function processStream() {
  for await (const item of streamAPI("/api/items")) {
    console.log("Processing:", item);
  }
}
```

### Example: Infinite Async Counter

```js
async function* infiniteAsyncCounter() {
  let i = 0;
  while (true) {
    await new Promise((resolve) => setTimeout(resolve, 1000));
    yield i++;
  }
}

// Use with for await...of (be careful with infinite loops!)
async function count() {
  for await (const num of infiniteAsyncCounter()) {
    console.log(num);
    if (num >= 5) break; // Stop after 5
  }
}
```

### Example: Processing Multiple Async Sources

```js
async function* mergeStreams(stream1, stream2) {
  const gen1 = stream1();
  const gen2 = stream2();

  while (true) {
    const [result1, result2] = await Promise.all([gen1.next(), gen2.next()]);

    if (result1.done && result2.done) break;

    if (!result1.done) yield result1.value;
    if (!result2.done) yield result2.value;
  }
}
```

## Comparison with Regular Generators

| Feature           | Generator Function    | Async Generator Function    |
| ----------------- | --------------------- | --------------------------- |
| Syntax            | `function* name() {}` | `async function* name() {}` |
| Pause Mechanism   | `yield`               | `yield` + `await`           |
| Return Type       | Generator object      | AsyncGenerator object       |
| `.next()` Returns | `{ value, done }`     | `Promise<{ value, done }>`  |
| Consumption       | `for...of`            | `for await...of`            |
| Use Case          | Synchronous iteration | Asynchronous iteration      |

## Comparison with Async Functions

| Feature         | Async Function             | Async Generator Function        |
| --------------- | -------------------------- | ------------------------------- |
| Syntax          | `async function name() {}` | `async function* name() {}`     |
| Return Type     | Promise                    | AsyncGenerator object           |
| Pause Mechanism | `await`                    | `yield` + `await`               |
| Execution       | Runs to completion         | Can pause/resume multiple times |
| Consumption     | `.then()` or `await`       | `for await...of` or `.next()`   |

## Error Handling

Errors in async generators can be handled with try/catch:

```js
async function* riskyGenerator() {
  try {
    yield await fetchData();
    yield await fetchMoreData();
  } catch (error) {
    console.error("Error in generator:", error);
    yield null; // Yield error indicator
  }
}

// Or handle errors when consuming
async function consume() {
  try {
    for await (const value of riskyGenerator()) {
      console.log(value);
    }
  } catch (error) {
    console.error("Error consuming:", error);
  }
}
```

## Important Notes

1. **AsyncGenerator Object**: The returned object implements the AsyncIterator protocol
2. **Promise-based**: Each `.next()` call returns a Promise that resolves to `{ value, done }`
3. **Sequential Execution**: Values are yielded sequentially, even if async operations could run in parallel
4. **Memory Efficient**: Only processes one value at a time, useful for large datasets
5. **Early Return**: Using `return` in an async generator sets `done: true` and the return value becomes the final `value`
6. **State Preservation**: Async generator functions maintain their state between calls to `.next()`
