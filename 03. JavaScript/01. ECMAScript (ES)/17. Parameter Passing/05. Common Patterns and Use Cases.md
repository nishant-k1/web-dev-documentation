# Common Patterns and Use Cases

Understanding parameter passing patterns helps you write better code and avoid common pitfalls.

---

## Pattern 1: Modifying Objects in Place

### Use Case: Updating Configuration

```javascript
function updateConfig(config) {
  config.debug = true;
  config.version = "2.0";
  config.features = [...config.features, "newFeature"];
}

let appConfig = {
  debug: false,
  version: "1.0",
  features: ["feature1", "feature2"],
};

updateConfig(appConfig);
console.log(appConfig);
// { debug: true, version: "2.0", features: ["feature1", "feature2", "newFeature"] }
```

**When to use:** When you want to modify the original object.

---

## Pattern 2: Returning New Objects (Immutable)

### Use Case: Functional Updates

```javascript
function updateConfig(config) {
  return {
    ...config,
    debug: true,
    version: "2.0",
    features: [...config.features, "newFeature"],
  };
}

let appConfig = {
  debug: false,
  version: "1.0",
  features: ["feature1", "feature2"],
};

let updatedConfig = updateConfig(appConfig);
console.log(appConfig); // Original unchanged
console.log(updatedConfig); // New object with updates
```

**When to use:** When you want to preserve the original (React, Redux patterns).

---

## Pattern 3: Accumulating Values

### Use Case: Building Results

```javascript
function accumulateResults(results, newData) {
  results.total += newData.value;
  results.items.push(newData);
  results.count++;
}

let stats = { total: 0, items: [], count: 0 };

accumulateResults(stats, { value: 10 });
accumulateResults(stats, { value: 20 });
console.log(stats); // { total: 30, items: [...], count: 2 }
```

**When to use:** When building up a result object incrementally.

---

## Pattern 4: Callback Functions

### Use Case: Array Methods

```javascript
function processArray(arr, callback) {
  // callback is a reference to a function
  for (let i = 0; i < arr.length; i++) {
    callback(arr[i], i);
  }
}

let numbers = [1, 2, 3];
processArray(numbers, (item, index) => {
  console.log(`Item ${index}: ${item}`);
});
```

**Note:** Functions are passed by reference, so the callback function itself is shared.

---

## Pattern 5: Default Parameters

### Use Case: Optional Objects

```javascript
function processUser(user = {}) {
  // If no user passed, use empty object
  user.name = user.name || "Anonymous";
  user.age = user.age || 0;
  return user;
}

let user1 = processUser({ name: "John", age: 30 });
let user2 = processUser(); // Uses default {}
```

**Important:** Default objects are created once, not per call!

```javascript
// ❌ Bad - shared default object
function badExample(items = []) {
  items.push("new");
  return items;
}

badExample(); // ["new"]
badExample(); // ["new", "new"] - accumulates!

// ✅ Good - create new object each time
function goodExample(items = []) {
  items = [...items]; // Copy to avoid mutation
  items.push("new");
  return items;
}
```

---

## Pattern 6: Destructuring Parameters

### Use Case: Extracting Properties

```javascript
function processUser({ name, age, email }) {
  // Destructuring creates new variables (pass by value for primitives)
  name = name.toUpperCase();
  age = age + 1;
  console.log(name, age); // Modified copies
}

let user = { name: "john", age: 25, email: "john@example.com" };
processUser(user);
console.log(user); // { name: "john", age: 25, email: "john@example.com" } (unchanged)
```

**Note:** Destructured primitives are copies, but nested objects are still references.

```javascript
function processNested({ user: { name, profile } }) {
  name = "Changed"; // Doesn't affect original (primitive copy)
  profile.age = 100; // Affects original (object reference)
}

let data = {
  user: {
    name: "John",
    profile: { age: 25 },
  },
};

processNested(data);
console.log(data.user.name); // "John" (unchanged)
console.log(data.user.profile.age); // 100 (modified)
```

---

## Pattern 7: Rest Parameters

### Use Case: Variable Arguments

```javascript
function sum(...numbers) {
  // numbers is an array (passed by reference)
  return numbers.reduce((a, b) => a + b, 0);
}

console.log(sum(1, 2, 3, 4)); // 10
```

**Note:** Rest parameters create a new array, so modifications don't affect arguments.

---

## Pattern 8: Avoiding Mutation

### Use Case: Safe Object Updates

```javascript
// ❌ Mutates original
function unsafeUpdate(user) {
  user.lastLogin = new Date();
  return user;
}

// ✅ Doesn't mutate original
function safeUpdate(user) {
  return {
    ...user,
    lastLogin: new Date(),
  };
}

// ✅ Or use Object.assign
function safeUpdate2(user) {
  return Object.assign({}, user, {
    lastLogin: new Date(),
  });
}
```

---

## Pattern 9: Nested Object Updates

### Use Case: Deep Updates

```javascript
// ❌ Mutates nested object
function unsafeDeepUpdate(data) {
  data.user.profile.name = "Updated";
  return data;
}

// ✅ Immutable deep update
function safeDeepUpdate(data) {
  return {
    ...data,
    user: {
      ...data.user,
      profile: {
        ...data.user.profile,
        name: "Updated",
      },
    },
  };
}

// Or use a library like Immer
import { produce } from "immer";

function immerUpdate(data) {
  return produce(data, (draft) => {
    draft.user.profile.name = "Updated";
  });
}
```

---

## Pattern 10: Array Operations

### Mutating vs Non-Mutating

```javascript
// Mutating (affects original)
function mutateArray(arr) {
  arr.push(4);
  arr.pop();
  arr.sort();
  arr.reverse();
}

// Non-mutating (returns new array)
function nonMutateArray(arr) {
  return [...arr, 4].sort().reverse();
}

let numbers = [3, 1, 2];
mutateArray(numbers);
console.log(numbers); // Modified

let numbers2 = [3, 1, 2];
let result = nonMutateArray(numbers2);
console.log(numbers2); // Unchanged
console.log(result); // New array
```

---

## Pattern 11: Function Parameters as References

### Use Case: Swapping Functions

```javascript
function swapFunctions(obj) {
  const temp = obj.method1;
  obj.method1 = obj.method2;
  obj.method2 = temp;
}

let calculator = {
  method1: function add(a, b) {
    return a + b;
  },
  method2: function subtract(a, b) {
    return a - b;
  },
};

swapFunctions(calculator);
// Methods are swapped in original object
```

---

## Pattern 12: Callback with Context

### Use Case: Preserving `this`

```javascript
class Counter {
  constructor() {
    this.count = 0;
  }

  increment() {
    this.count++;
  }

  setupButton(button) {
    // Pass method reference
    button.onclick = this.increment.bind(this);
    // Or use arrow function
    button.onclick = () => this.increment();
  }
}
```

---

## Best Practices Summary

1. **Document mutations** - If a function mutates parameters, document it
2. **Prefer immutability** - Return new objects when possible
3. **Use destructuring carefully** - Understand what gets copied vs referenced
4. **Avoid shared default objects** - Create new objects in defaults
5. **Be explicit** - Make it clear if you're mutating or creating new objects

---

## Related Topics

- [02. Pass By Value.md](./02.%20Pass%20By%20Value.md) - Primitive passing
- [03. Pass By Reference.md](./03.%20Pass%20By%20Reference.md) - Object passing
- [13. Copying](../13.%20Copying/) - How to create copies
- [12. Comparing](../12.%20Comparing/) - How to compare values
