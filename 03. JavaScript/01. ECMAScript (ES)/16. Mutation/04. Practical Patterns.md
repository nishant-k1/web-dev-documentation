# Practical Patterns: Avoiding Mutation

Real-world patterns for avoiding mutation in modern JavaScript development.

---

## React State Updates (Immutable Updates)

React requires immutable state updates to trigger re-renders correctly.

### âŒ Mutating (React Anti-Pattern - DON'T DO THIS)

```js
function updateUser(state, newAge) {
  state.users[0].age = newAge; // âŒ Mutates original state
  return state; // React won't detect change (same reference)
}
```

### âœ… Immutable Update (React Pattern - CORRECT)

```js
function updateUser(state, newAge) {
  return {
    ...state,
    users: state.users.map((user, index) =>
      index === 0 ? { ...user, age: newAge } : user
    ),
  };
}
```

### âœ… Using Spread Operator for Shallow Copy

```js
// Adding property
setState({ ...prevState, newProperty: value });

// Updating property
setState({ ...prevState, existingProperty: newValue });

// Removing property
const { removedProp, ...rest } = prevState;
setState(rest);
```

### âœ… Updating Nested Objects Immutably

```js
setState({
  ...prevState,
  user: {
    ...prevState.user,
    profile: {
      ...prevState.user.profile,
      age: 26,
    },
  },
});
```

### âœ… Updating Arrays Immutably

```js
// Adding item
setState({ ...prevState, items: [...prevState.items, newItem] });

// Removing item
setState({
  ...prevState,
  items: prevState.items.filter((item) => item.id !== idToRemove),
});

// Updating item
setState({
  ...prevState,
  items: prevState.items.map((item) =>
    item.id === idToUpdate ? { ...item, ...updates } : item
  ),
});
```

---

## Redux Immutable Updates

Redux reducers must return new state objects, never mutate existing state.

### Redux Reducer Pattern

```js
function reducer(state = initialState, action) {
  switch (action.type) {
    case "ADD_ITEM":
      return {
        ...state,
        items: [...state.items, action.payload], // Immutable add
      };

    case "UPDATE_ITEM":
      return {
        ...state,
        items: state.items.map((item) =>
          item.id === action.id ? { ...item, ...action.updates } : item
        ),
      };

    case "REMOVE_ITEM":
      return {
        ...state,
        items: state.items.filter((item) => item.id !== action.id), // Immutable remove
      };

    case "TOGGLE_ITEM":
      return {
        ...state,
        items: state.items.map((item) =>
          item.id === action.id ? { ...item, active: !item.active } : item
        ),
      };

    default:
      return state;
  }
}
```

### Using Immer with Redux Toolkit

```js
import { createSlice } from "@reduxjs/toolkit";
import { produce } from "immer";

const slice = createSlice({
  name: "items",
  initialState: [],
  reducers: {
    addItem: (state, action) => {
      state.push(action.payload); // âœ… Looks like mutation, but Immer handles it immutably
    },
  },
});
```

---

## Functional Programming Patterns

### Pure Functions

Functions that don't mutate input, always return new values.

```js
// Pure function - doesn't mutate input
function addItemToList(list, newItem) {
  return [...list, newItem]; // Returns new array
}

// Pure function - transforms without mutation
function updateProperty(obj, key, value) {
  return { ...obj, [key]: value }; // Returns new object
}

// Pure function - filters without mutation
function filterActive(users) {
  return users.filter((user) => user.active); // Returns new array
}
```

### Composing Immutable Operations

```js
// Chain immutable operations
const updated = users
  .filter((user) => user.active)
  .map((user) => ({ ...user, status: "verified" }))
  .sort((a, b) => a.name.localeCompare(b.name));
```

### Transforming Objects

```js
// Map object values
const doubled = Object.fromEntries(
  Object.entries(obj).map(([key, value]) => [key, value * 2])
);

// Filter object properties
const filtered = Object.fromEntries(
  Object.entries(obj).filter(([key, value]) => value > 10)
);

// Transform object keys
const renamed = Object.fromEntries(
  Object.entries(obj).map(([key, value]) => [`new_${key}`, value])
);
```

---

## When Mutation is Acceptable

Mutation is OK in certain scenarios:

### 1. Local Variables (Not Shared)

```js
function processData(data) {
  const local = [...data]; // Copy first
  local.sort(); // âœ… Mutate local copy (fine, not shared)
  return local;
}
```

### 2. Building Objects/Arrays from Scratch

```js
function buildConfig() {
  const config = {}; // New object
  config.apiUrl = "https://api.example.com"; // âœ… Mutation OK
  config.timeout = 5000; // âœ… Mutation OK
  return config; // New object, mutation is fine
}
```

### 3. Performance-Critical Code

```js
// Sometimes mutation is faster for very large datasets
function processLargeArray(arr) {
  // For very large arrays, in-place mutation might be faster
  arr.sort(); // âœ… OK if arr is local and won't be reused
  return arr;
}
```

### 4. Array Methods That Mutate (When Appropriate)

```js
const items = [1, 2, 3, 4, 5];
items.sort(); // âœ… OK if items is local
items.reverse(); // âœ… OK if items is local
```

**Rule of Thumb:** Mutation is acceptable when:

- The variable is local and not shared
- You're building a new object/array from scratch
- Performance is critical and mutation is faster
- You understand the implications

---

## Related Topics

ðŸ“– See: [Common Pitfalls](./05.%20Common%20Pitfalls.md) - Mistakes to avoid
ðŸ“– See: [Copying](../../14.%20Copying/) - Copying techniques
ðŸ“– See: [Comparing](../../13.%20Comparing/) - Comparison methods
