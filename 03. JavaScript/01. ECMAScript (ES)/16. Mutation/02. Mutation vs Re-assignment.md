# Mutation vs Re-assignment

Understanding the difference between mutation and re-assignment is crucial for JavaScript development.

---

## 1. Mutation

**Definition:** Changing the contents of the value itself (usually for objects or arrays) without changing the reference.

### Characteristics

1. Changes the internals of the object the variable refers to, not the reference itself
2. The variable still points to the same memory location
3. Only applies to Reference Data Types (Arrays, Objects, Functions, Date, RegExp)
4. Does NOT apply to Primitive Data Types (primitives are immutable)
5. `var`, `let` and `const` all offer mutation

### Example

```js
let a = [1, 2, 3];
a.push(4); // mutation: The variable a still points to the same array, but that array's contents have changed.
console.log(a); // [1, 2, 3, 4]
```

---

## 2. Re-assignment

**Definition:** Assigning a new value or reference to a variable.

### Characteristics

1. Changes the reference a variable holds
2. The variable now points to a different memory location
3. Applies to both primitives and non-primitives
4. `var` and `let` offer re-assignment
5. `const` does NOT offer re-assignment

### Example

```js
let a = [1, 2, 3];
a = [4, 5]; // re-assignment: The variable a now points to a completely new array.
console.log(a); // [4, 5]
```

---

## Key Differences

| Aspect              | Mutation               | Re-assignment                 |
| ------------------- | ---------------------- | ----------------------------- |
| **Changes**         | Contents of the object | Reference of the variable     |
| **Memory Location** | Same reference         | New reference                 |
| **Applies To**      | Non-primitives only    | Primitives and non-primitives |
| **const behavior**  | ‚úÖ Allowed             | ‚ùå Not allowed                |

---

## Visual Comparison

```js
// Mutation
let obj1 = { name: "John" };
let obj2 = obj1; // Both reference same object
obj1.name = "Jane"; // Mutation: changes the object
console.log(obj2.name); // "Jane" (both affected - same reference)

// Re-assignment
let arr1 = [1, 2, 3];
let arr2 = arr1; // Both reference same array
arr1 = [4, 5]; // Re-assignment: arr1 now points to NEW array
console.log(arr2); // [1, 2, 3] (arr2 still points to original)
```

---

## When Each is Used

### Use Mutation When:

- Modifying an existing object/array in place
- Performance is critical (mutating is faster than creating new)
- Building objects/arrays from scratch locally
- Working with local variables that aren't shared

### Use Re-assignment When:

- You want to completely replace the value
- Working with primitives (they're immutable, so you must re-assign)
- Creating new instances
- Following functional programming principles (immutability)

---

## Related Topics

üìñ See: [Ways to Mutate Objects and Arrays](./01.%20Mutation%20Overview.md)

üìñ See: [Ways to Prevent Mutation](./03.%20Preventing%20Mutation.md)

üìñ See: [Assignment](../../12.%20Assignments/) for assignment details

üìñ See: [Copying](../../14.%20Copying/) for creating copies without mutation
