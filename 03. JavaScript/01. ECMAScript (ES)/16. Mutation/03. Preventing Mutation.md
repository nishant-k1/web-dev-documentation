# Preventing Mutation

Various techniques exist to prevent mutation of objects and arrays in JavaScript.

---

## 1. Object.freeze()

Makes an object fully immutable (shallow - nested objects can still be mutated).

```js
const obj = { name: "John", age: 30 };
Object.freeze(obj);

obj.age = 35; // ‚ùå Fails silently in non-strict mode, throws in strict mode
console.log(obj.age); // 30 (unchanged)

// Nested objects are NOT frozen
const nested = { user: { name: "John" } };
Object.freeze(nested);
nested.user.name = "Jane"; // ‚ö†Ô∏è Still works! (shallow freeze)
```

**Deep Freeze Implementation:**

```js
function deepFreeze(obj) {
  // Retrieve property names
  Object.getOwnPropertyNames(obj).forEach((prop) => {
    const value = obj[prop];
    // Freeze recursively if value is an object
    if (value && typeof value === "object") {
      deepFreeze(value);
    }
  });
  // Freeze self
  return Object.freeze(obj);
}
```

üìñ See: [Object.freeze() details](../../04.%20Data%20Types/12.%20Objects.md#-4-immutability--control) for more information

---

## 2. Use Shallow Copies to Avoid Mutating Originals

Create new objects/arrays instead of mutating originals.

### For Objects:

```js
// Spread operator (most common)
const newObj = { ...obj };

// Object.assign()
const newObj = Object.assign({}, obj);

// Object.create() with descriptors (preserves getters/setters)
const newObj = Object.create(
  Object.getPrototypeOf(obj),
  Object.getOwnPropertyDescriptors(obj)
);
```

### For Arrays:

```js
// Spread operator
const newArr = [...arr];

// Array.slice()
const newArr = arr.slice();

// Array.from()
const newArr = Array.from(arr);

// Array.concat()
const newArr = [].concat(arr);
```

üìñ For comprehensive cloning methods, see [15. Copying](../../14.%20Copying/)
üìñ See: [Shallow Copy](../../14.%20Copying/04.%20Shallow%20Copy.md) for detailed shallow copy methods

---

## 3. Use Deep Copies When Needed

For nested structures, create deep copies to ensure complete independence.

```js
// Modern deep copy (ES2022) - Recommended
const deepCopy = structuredClone(obj);

// JSON method (limitations: no functions, Dates, etc.)
const deepCopy = JSON.parse(JSON.stringify(obj)); // ‚ö†Ô∏è Limitations

// Custom recursive implementation
function deepCopy(obj) {
  if (obj === null || typeof obj !== "object") return obj;
  if (obj instanceof Date) return new Date(obj.getTime());
  if (Array.isArray(obj)) return obj.map((item) => deepCopy(item));

  const copy = {};
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      copy[key] = deepCopy(obj[key]);
    }
  }
  return copy;
}
```

üìñ See: [Deep Copy](../../14.%20Copying/05.%20Deep%20Copy.md) for complete deep cloning guide

---

## 4. Use Immutable Libraries

### Immer

Allows writing "mutating" syntax that produces immutable results.

```js
import { produce } from "immer";

const baseState = { user: { name: "Bob" } };
const nextState = produce(baseState, (draft) => {
  draft.user.name = "Alice"; // "Mutating" syntax
});
console.log(baseState.user.name); // "Bob" (original unchanged)
console.log(nextState.user.name); // "Alice" (new object created)
```

### Immutable.js

Provides persistent immutable data structures.

```js
import { Map } from "immutable";

const originalMap = Map({ key: "value" });
const newMap = originalMap.set("key", "newValue");
console.log(originalMap.get("key")); // "value" (original unchanged)
console.log(newMap.get("key")); // "newValue" (new instance)
```

---

## 5. Important: const Does NOT Prevent Mutation

Many developers mistakenly think `const` prevents mutation. It only prevents re-assignment.

```js
const obj = { name: "John" };
obj.name = "Jane"; // ‚úÖ Allowed - mutation is fine
console.log(obj.name); // "Jane"

const arr = [1, 2, 3];
arr.push(4); // ‚úÖ Allowed - mutation is fine
console.log(arr); // [1, 2, 3, 4]

// ‚ùå Re-assignment is NOT allowed
obj = { name: "Bob" }; // TypeError: Assignment to constant variable
arr = [5, 6]; // TypeError: Assignment to constant variable
```

**Summary:**

- `const` prevents re-assignment ‚úÖ
- `const` does NOT prevent mutation ‚ùå
- To prevent mutation, use `Object.freeze()` or create copies

---

## Best Practices

1. **For React/Redux:** Always use immutable updates (shallow/deep copies)
2. **For Performance:** Consider mutation when building local objects/arrays
3. **For Shared Data:** Always create copies to avoid unintended side effects
4. **For Configuration:** Use `Object.freeze()` to prevent accidental changes
5. **For Complex Data:** Use libraries like Immer for easier immutable updates

---

## Related Topics

üìñ See: [Copying](../../14.%20Copying/) - Comprehensive copying guide
üìñ See: [Practical Patterns](./04.%20Practical%20Patterns.md) - React/Redux patterns
üìñ See: [Common Pitfalls](./05.%20Common%20Pitfalls.md) - Mistakes to avoid
