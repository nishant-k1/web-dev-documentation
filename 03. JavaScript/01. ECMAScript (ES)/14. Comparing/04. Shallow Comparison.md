# Shallow Comparison

Shallow comparison checks if two objects/arrays have same references for the first-level properties/elements, but does not recursively check nested structures.
If the first-level property has a different reference, shallow comparison fails, even if the values inside look the same.

## Key Characteristics

- **Top-Level Object References**: The objects being compared (e.g., `obj1` and `obj2`) can be distinct objects in memory (i.e., `obj1 !== obj2`).
- **First-Level Properties**:
  1. For primitive values (e.g., numbers, strings, booleans), the values must be strictly equal (`===`).
  2. For non-primitive values (e.g., objects, arrays), the properties must point to the same reference in memory, not just have equivalent content.
- **No Deep Check**: Shallow equality does not recurse into nested objects to compare their contents; it only checks if the references of nested objects are identical.

## Example

```js
const obj1 = { a: 1, b: { x: 10 }, c: "hello" };
const obj2 = { a: 1, b: { x: 10 }, c: "hello" };
const obj3 = { a: 1, b: obj1.b, c: "hello" }; // b points to the same object as obj1.b

// obj1 and obj2 are NOT shallowly equal because obj1.b and obj2.b are different references
console.log(shallowEqual(obj1, obj2)); // false

// obj1 and obj3 ARE shallowly equal because obj1.b and obj3.b point to the same object
console.log(shallowEqual(obj1, obj3)); // true
```

## Implementation

### Basic Shallow Equality Function

```js
function shallowEqual(obj1, obj2) {
  const keys1 = Object.keys(obj1);
  const keys2 = Object.keys(obj2);

  if (keys1.length !== keys2.length) return false;

  for (let key of keys1) {
    if (obj2[key] !== obj1[key]) return false;
  }

  return true;
}
```

### Enhanced Shallow Equality (Handles Arrays)

```js
function shallowEqual(obj1, obj2) {
  // Handle arrays
  if (Array.isArray(obj1) && Array.isArray(obj2)) {
    if (obj1.length !== obj2.length) return false;
    for (let i = 0; i < obj1.length; i++) {
      if (obj1[i] !== obj2[i]) return false;
    }
    return true;
  }

  // Handle objects
  const keys1 = Object.keys(obj1);
  const keys2 = Object.keys(obj2);

  if (keys1.length !== keys2.length) return false;

  for (const key of keys1) {
    if (!keys2.includes(key) || obj1[key] !== obj2[key]) {
      return false;
    }
  }

  return true;
}
```

## Key Points

- **First-level properties must have same reference and value** - Even if the first-level property references are different while value is same, then the objects are not shallow equal.
- **Nested objects compared by reference** - If two objects have the same nested structure but different references, they are NOT shallow equal.
- **Primitives compared by value** - First-level primitive properties are compared by value using `===`.
- **Not reliable for nested objects** - Shallow comparison does not check nested object contents.

## Use Cases

- **React component props comparison** - React's shallow comparison for props
- **State management** - Checking if state object changed at first level
- **Performance optimization** - Faster than deep comparison

## Important Notes

- Shallow comparison is faster than deep comparison
- Common in React for determining re-renders
- Does not account for deep equality
- Two objects with identical nested structure but different references will not match
