# Deep Comparison

Deep comparison recursively compares the properties of objects and arrays, including all nested structures, to determine if they have equivalent content.

Deep comparison passes even if properties at any level have different references, as long as the values and structure are identical.

## Key Characteristics

- Compares the properties of objects recursively, including nested objects and arrays.
- Checks both structure and values at all levels.
- Requires a helper function or library (like Lodash's `isEqual`).

## Using Libraries

### Lodash `_.isEqual`

Offers a reliable `isEqual` method for deep comparison.

```js
import { isEqual } from "lodash";

const obj1 = { x: 1, y: { z: 2 } };
const obj2 = { x: 1, y: { z: 2 } };

isEqual(obj1, obj2); // ✅ true - deep and robust
```

**Advantages:**

- ✅ Handles edge cases (functions, dates, circular references)
- ✅ Robust and well-tested
- ✅ Works with complex nested structures

**Disadvantages:**

- ❌ Requires a dependency

### Other Libraries

- **deepdash** - Extended Lodash with deep operations
- **fast-deep-equal** - Fast deep equality check
- **deep-equal** - Simple deep equality

## JSON Stringify Comparison: ⚠️ Use With Caution ❌

Converts objects to JSON strings and compares them.

```js
const a = { x: 1, y: 2 };
const b = { x: 1, y: 2 };

console.log(JSON.stringify(a) === JSON.stringify(b)); // true
```

**Advantages:**

- ✅ Simple and quick
- ✅ No dependencies

**Disadvantages:**

- ❌ Loses functions, Dates, undefined, NaN, RegExp, Map, Set, etc.
- ❌ Throws on circular references
- ❌ Only works with JSON-serializable data
- ❌ Ignores property order differences
- ❌ Not reliable for complex objects

## Custom Deep Equality Implementation

```js
function deepEqual(obj1, obj2) {
  // Primitive comparison
  if (obj1 === obj2) return true;

  // Type check
  if (typeof obj1 !== typeof obj2) return false;

  // null check
  if (obj1 === null || obj2 === null) return obj1 === obj2;

  // Array comparison
  if (Array.isArray(obj1) && Array.isArray(obj2)) {
    if (obj1.length !== obj2.length) return false;
    for (let i = 0; i < obj1.length; i++) {
      if (!deepEqual(obj1[i], obj2[i])) return false;
    }
    return true;
  }

  // Object comparison
  if (typeof obj1 === "object" && typeof obj2 === "object") {
    const keys1 = Object.keys(obj1);
    const keys2 = Object.keys(obj2);

    if (keys1.length !== keys2.length) return false;

    for (let key of keys1) {
      if (!keys2.includes(key)) return false;
      if (!deepEqual(obj1[key], obj2[key])) return false;
    }

    return true;
  }

  return false;
}
```

## Use Cases

- **Complex data structure comparison** - When you need to compare nested objects/arrays
- **Testing** - Comparing expected vs actual results
- **Data validation** - Checking if data structures match
- **State comparison** - When shallow comparison isn't sufficient

## Important Notes

1. **Performance** - Deep comparison is slower than shallow comparison
2. **Circular references** - Custom implementations may fail with circular references (use libraries)
3. **Edge cases** - Functions, Dates, and special objects require special handling
4. **Best practice** - Use well-tested libraries like Lodash for production code

## Best Practices

1. **Use Lodash `isEqual`** for production code
2. **Avoid JSON.stringify** unless you're certain about data structure
3. **Consider performance** - Deep comparison can be expensive for large objects
4. **Handle edge cases** - Functions, Dates, and circular references need special handling
