# Hoisting

> üìñ **Parent Topic:** [04. Execution Context Life Cycle and Call Stack](../17. Execution Context/04. Execution Context Life Cycle and Call Stack.md)

- `When hoisting occurs, the declaration of a variable, function or class  is moved to the top of its scope (Global, Module, Function, Block), allowing you to use it before it is initialized. Only declarations are hoisted, not their initialization.`

- When we talk about hoisting, we‚Äôre referring to the behavior of moving variable and function declarations to the top of scope of the execution context (during the creation phase of an execution context) not their initialization.

- Variables and function declarations are moved to the top of their respective contexts during the execution context creation phase.

- Hoisting is JavaScript's default behavior of moving declarations (variables and functions) to the top of their respective scopes/execution context (global or functional) during the creation phase of the Execution Context.

- `Hoisting happens during the creation phase of an execution context`, which could be either:

  - Global Execution Context (for global scope).
  - Function Execution Context (for function scope).

- Hoisting moves declarations (variables and functions) to the top of the scope of the execution context they belong to:

  - In the Global Execution Context (GEC), declarations are hoisted to the top of the global scope.
  - In a Function Execution Context (FEC), declarations are hoisted to the top of the function's scope.
  - Initialization does not happen during hoisting; it's done when the execution reaches the variable's or function's definition in the code.

- This allows you to use variables and functions before they are declared in the code.

## Hoisting Lifecycle

1. **Creation Phase**:

   - Memory is allocated for variables and functions.
   - Function declarations are fully hoisted, meaning their entire definition is available at the top of the scope.
   - Variables declared with `var are hoisted` but initialized with undefined.
   - Variables declared with `let and const are hoisted` but remain uninitialized (in the `Temporal Dead Zone`).

2. **Execution Phase**:

   - Code is executed line-by-line.
   - Accessing variables before their declaration can lead to undefined (for var) or a ReferenceError (for let and const).

## Hoisting Types

1. **Function Hoisting**

   - `Functions declared using the function keyword are fully hoisted`. This means you can invoke the function before its declaration.

2. Class Hoisting (behave like let and const hoisting)

   - `Class declarations are NOT fully hoisted! They behave like let/const - they're in the Temporal Dead Zone (TDZ).`

3. **Variable Hoisting**

   - **var hoisting**: Variables declared with var are hoisted but initialized to `undefined`.
   - **let and const hoisting**:
     - Variables declared with `let and const are hoisted` but remain uninitialized (in the `Temporal Dead Zone`).
     - Variables declared with `let` and `const` are also `hoisted` but remain uninitialized until the code executes their declaration.
     - Accessing them before their declaration results in a `ReferenceError`.
     - `let` and `const` are hoisted to the top of their scope but are in a `Temporal Dead Zone (TDZ)` until the code execution reaches their declaration.
   - **Function Expression Hoisting**
     - Function expressions (both regular and arrow functions) are treated like variables.
     - Only the variable is hoisted, not the function definition.
     - Invoking the function before its definition results in a `TypeError`
   - **Class Hoisting**
     - Classes are also hoisted but remain uninitialized (in the `Temporal Dead Zone`), similar to let and const.
     - Accessing a class before its declaration results in a `ReferenceError`.

| Declaration Type       | Hoisted?      | Initialized as    | Usable Before Declaration? |
| ---------------------- | ------------- | ----------------- | -------------------------- |
| `var`                  | ‚úÖ            | `undefined`       | ‚úÖ (but `undefined`)       |
| `let`                  | ‚úÖ            | TDZ               | ‚ùå                         |
| `const`                | ‚úÖ            | TDZ               | ‚ùå                         |
| `function` declaration | ‚úÖ            | Full function     | ‚úÖ                         |
| `class` declaration    | ‚úÖ            | TDZ               | ‚ùå                         |
| Function parameters    | ‚úÖ            | Value/`undefined` | ‚úÖ                         |
| `import`               | ‚úÖ            | Full value        | ‚úÖ                         |
| Function expression    | Variable only | Depends           | ‚ùå                         |
| Arrow function         | Variable only | Depends           | ‚ùå                         |
| Class expression       | Variable only | Depends           | ‚ùå                         |

---

## üî• Temporal Dead Zone (TDZ) - Deep Dive

The TDZ is the period between entering a scope and the variable's declaration being processed. During TDZ, accessing the variable throws a `ReferenceError`.

### What is TDZ?

```javascript
{
  // TDZ for 'x' starts here (entering the block)

  console.log(x); // ‚ùå ReferenceError: Cannot access 'x' before initialization

  let x = 10; // TDZ ends here

  console.log(x); // ‚úÖ 10
}
```

### üî• TDZ Interview Trap 1: `typeof` is NOT Safe

```javascript
// With undeclared variables, typeof is safe
console.log(typeof undeclaredVar); // "undefined" ‚úÖ No error

// But with TDZ variables, typeof THROWS!
{
  console.log(typeof x); // ‚ùå ReferenceError!
  let x = 10;
}
```

### üî• TDZ Interview Trap 2: TDZ in Function Parameters

```javascript
// Default parameters can reference earlier parameters
function works(a, b = a) {
  console.log(a, b);
}
works(5); // 5, 5 ‚úÖ

// But NOT later parameters (TDZ!)
function fails(a = b, b) {
  console.log(a, b);
}
fails(undefined, 5); // ‚ùå ReferenceError: Cannot access 'b' before initialization
```

### üî• TDZ Interview Trap 3: TDZ in Same Line

```javascript
let x = x; // ‚ùå ReferenceError!
// The right-hand side 'x' is evaluated first, but x is still in TDZ

const y = someFunction();
function someFunction() {
  return y; // ‚ùå ReferenceError if called before y is initialized
}
```

### üî• TDZ Interview Trap 4: TDZ with Closures

```javascript
let callbacks = [];

for (let i = 0; i < 3; i++) {
  callbacks.push(() => i);
}

console.log(callbacks[0]()); // 0 ‚úÖ
console.log(callbacks[1]()); // 1 ‚úÖ
console.log(callbacks[2]()); // 2 ‚úÖ

// Each iteration creates a NEW 'i' (block scoped)
// vs var which would give 3, 3, 3
```

### üî• TDZ Interview Trap 5: Class TDZ

```javascript
const instance = new MyClass(); // ‚ùå ReferenceError!

class MyClass {
  constructor() {
    this.name = "test";
  }
}

// Classes are hoisted but NOT initialized (TDZ applies)
```

### üî• TDZ Interview Trap 6: const in Switch

```javascript
switch (x) {
  case 1:
    const y = 10; // This 'y' is scoped to entire switch block
    break;
  case 2:
    console.log(y); // ‚ùå ReferenceError - y is in TDZ
    const y = 20; // ‚ùå SyntaxError - y already declared
    break;
}

// Solution: Use blocks
switch (x) {
  case 1: {
    const y = 10; // Scoped to this block only
    break;
  }
  case 2: {
    const y = 20; // Different 'y', no conflict
    break;
  }
}
```

---

## üî• Hoisting Interview Traps

### Trap 1: var vs let/const in Same Scope

```javascript
console.log(a); // undefined (var is hoisted)
console.log(b); // ‚ùå ReferenceError (let is in TDZ)
console.log(c); // ‚ùå ReferenceError (const is in TDZ)

var a = 1;
let b = 2;
const c = 3;
```

### Trap 2: Function Declaration vs Expression

```javascript
foo(); // ‚úÖ "Function declaration" - fully hoisted
bar(); // ‚ùå TypeError: bar is not a function

function foo() {
  console.log("Function declaration");
}

var bar = function () {
  console.log("Function expression");
};

// bar is hoisted as 'undefined', so calling it throws TypeError
```

### Trap 3: Function Declaration Inside Blocks

```javascript
console.log(typeof foo); // "function" in non-strict, varies in strict

if (true) {
  function foo() {
    return 1;
  }
}

console.log(foo()); // 1 in non-strict mode

// ‚ö†Ô∏è Behavior varies between strict/non-strict and browsers!
// Avoid function declarations inside blocks
```

### Trap 4: Named Function Expression Hoisting

```javascript
console.log(typeof foo); // "undefined" - only the variable is hoisted
console.log(typeof bar); // ‚ùå ReferenceError - bar is the function's internal name

var foo = function bar() {
  console.log(typeof bar); // "function" - bar is available inside
};

foo();
console.log(typeof bar); // "undefined" - bar is NOT available outside
```

### Trap 5: Re-declaration with var vs let

```javascript
var x = 1;
var x = 2; // ‚úÖ No error - var allows re-declaration
console.log(x); // 2

let y = 1;
let y = 2; // ‚ùå SyntaxError: Identifier 'y' has already been declared
```

### Trap 6: Hoisting Order - Variables vs Functions

```javascript
console.log(typeof foo); // "function" - function wins!

var foo = "variable";

function foo() {
  return "function";
}

console.log(typeof foo); // "string" - variable assignment overrides

// Function declarations are hoisted ABOVE variable declarations
// But variable ASSIGNMENTS happen during execution
```

---

## Interview-Ready Summary

**Hoisting happens in 2 phases:**

1. **Creation Phase**:

   - `var` ‚Üí hoisted and initialized to `undefined`
   - `let/const` ‚Üí hoisted but NOT initialized (TDZ)
   - `function` declarations ‚Üí fully hoisted with body
   - `class` ‚Üí hoisted but NOT initialized (TDZ)

2. **Execution Phase**:
   - Assignments and initializations happen
   - TDZ ends when declaration is reached

**Key statement for interviews:**

> "All declarations are hoisted, but `let`, `const`, and `class` remain in a Temporal Dead Zone until their declaration is executed. Accessing them before that throws a ReferenceError, not undefined like `var`."
