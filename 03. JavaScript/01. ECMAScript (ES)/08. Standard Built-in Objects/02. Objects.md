# âœ… Must-Know `Object` Methods & Properties (JavaScript Interview Perspective)

A list of high-impact, frequently asked `Object` methods and properties every JavaScript developer should know.

---

## ðŸ”· 1. Object Creation & Prototypes

| Method / Property                   | Purpose                                               |
| ----------------------------------- | ----------------------------------------------------- |
| `Object.create(proto, props?)`      | Creates a new object with the given prototype         |
| `Object.assign(target, ...srcs)`    | Copies enumerable own props (shallow copy)            |
| `Object.setPrototypeOf(obj, proto)` | Sets the prototype of an object (rarely used, slower) |
| `Object.getPrototypeOf(obj)`        | Gets the prototype (same as `__proto__`)              |

```js
const base = {
  greet() {
    console.log("hi");
  },
};
const obj = Object.create(base);
```

---

## ðŸ”· 2. Object Inspection

**enumerable**: A property is enumerable if it can be listed or looped over using for...in or similar operations.

| Method / Property          | Purpose                                                  |
| -------------------------- | -------------------------------------------------------- |
| `Object.keys(obj)`         | Returns array of enumerable own property names (strings) |
| `Object.values(obj)`       | Returns array of enumerable own property values          |
| `Object.entries(obj)`      | Returns array of `[key, value]` pairs                    |
| `Object.hasOwn(obj, prop)` | Safer modern version of `hasOwnProperty`                 |
| `obj.hasOwnProperty(prop)` | Returns true if prop is direct (not inherited)           |

```js
Object.keys({ a: 1, b: 2 }); // ['a', 'b']
```

---

## ðŸ”· 3. Property Descriptors

| Method                                        | Purpose                                                |
| --------------------------------------------- | ------------------------------------------------------ |
| `Object.defineProperty(obj, key, descriptor)` | Defines a single property with full descriptor control |
| `Object.defineProperties(obj, descriptors)`   | Defines multiple properties                            |
| `Object.getOwnPropertyDescriptor(obj, prop)`  | Gets property descriptor                               |
| `Object.getOwnPropertyDescriptors(obj)`       | Gets all descriptors (used for deep copy sometimes)    |

```js
Object.defineProperty(obj, "age", {
  value: 30,
  writable: false,
  enumerable: true,
});
```

---

## ðŸ”· 3.5. Property Accessors (Getters/Setters)

Property accessors allow you to define properties that use getter and setter functions instead of direct value storage. This enables computed properties, validation, and controlled property access.

### Accessor Properties vs Data Properties

**Data Property:**

- Stores a value directly
- Defined with `value` and `writable` descriptor

**Accessor Property:**

- Uses getter and/or setter functions
- Defined with `get` and/or `set` descriptor
- No `value` or `writable` descriptor

```js
// Data property
const obj1 = {};
Object.defineProperty(obj1, "name", {
  value: "John",
  writable: true,
  enumerable: true,
});

// Accessor property (getter)
const obj2 = {};
Object.defineProperty(obj2, "name", {
  get() {
    return "John";
  },
  enumerable: true,
});
```

### Using Object Literal Syntax

The simplest way to define accessors is using object literal syntax:

```js
const person = {
  firstName: "John",
  lastName: "Doe",

  // Getter
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  },

  // Setter
  set fullName(value) {
    const parts = value.split(" ");
    this.firstName = parts[0];
    this.lastName = parts[1];
  },
};

console.log(person.fullName); // "John Doe"
person.fullName = "Jane Smith";
console.log(person.firstName); // "Jane"
console.log(person.lastName); // "Smith"
```

### Using Object.defineProperty()

```js
const obj = {};
let _value = 0;

Object.defineProperty(obj, "count", {
  get() {
    return _value;
  },
  set(newValue) {
    if (newValue < 0) {
      throw new Error("Count cannot be negative");
    }
    _value = newValue;
  },
  enumerable: true,
  configurable: true,
});

obj.count = 5;
console.log(obj.count); // 5
obj.count = -1; // Error: Count cannot be negative
```

### Common Use Cases

#### 1. Computed Properties

```js
const rectangle = {
  width: 10,
  height: 20,
  get area() {
    return this.width * this.height;
  },
  get perimeter() {
    return 2 * (this.width + this.height);
  },
};

console.log(rectangle.area); // 200
// No setter - area is read-only and computed
```

#### 2. Validation

```js
const user = {
  _email: "",
  get email() {
    return this._email;
  },
  set email(value) {
    if (!value.includes("@")) {
      throw new Error("Invalid email format");
    }
    this._email = value;
  },
};

user.email = "john@example.com"; // âœ… Valid
user.email = "invalid"; // âŒ Error: Invalid email format
```

#### 3. Private Data Encapsulation

```js
const bankAccount = {
  _balance: 0,
  get balance() {
    return this._balance;
  },
  deposit(amount) {
    if (amount > 0) {
      this._balance += amount;
    }
  },
  withdraw(amount) {
    if (amount > 0 && amount <= this._balance) {
      this._balance -= amount;
    }
  },
};

console.log(bankAccount.balance); // 0
bankAccount.deposit(100);
console.log(bankAccount.balance); // 100
// Cannot directly set balance (no setter)
```

#### 4. Lazy Loading / Memoization

```js
const expensiveObject = {
  _cachedValue: null,
  get expensiveValue() {
    if (this._cachedValue === null) {
      console.log("Computing expensive value...");
      this._cachedValue = performExpensiveCalculation();
    }
    return this._cachedValue;
  },
};
```

#### 5. Reactive Properties

```js
const observable = {
  _value: null,
  _listeners: [],
  get value() {
    return this._value;
  },
  set value(newValue) {
    this._value = newValue;
    this._listeners.forEach((listener) => listener(newValue));
  },
  subscribe(listener) {
    this._listeners.push(listener);
  },
};
```

### Getter-Only Properties

Properties with only a getter are read-only:

```js
const obj = {
  get readOnly() {
    return "Cannot be changed";
  },
};

console.log(obj.readOnly); // "Cannot be changed"
obj.readOnly = "New value"; // Silently ignored in non-strict mode
// TypeError in strict mode
```

### Setter-Only Properties

Less common, but useful for validation or side effects:

```js
const logger = {
  _logs: [],
  set log(message) {
    this._logs.push({ message, timestamp: Date.now() });
    console.log(`[LOG] ${message}`);
  },
  getLogs() {
    return this._logs;
  },
};

logger.log = "User logged in";
logger.log = "Data saved";
console.log(logger.getLogs()); // Array of log entries
```

### In Classes

Getters and setters work seamlessly in ES6 classes:

```js
class Temperature {
  constructor(celsius) {
    this._celsius = celsius;
  }

  get celsius() {
    return this._celsius;
  }

  set celsius(value) {
    if (value < -273.15) {
      throw new Error("Temperature below absolute zero");
    }
    this._celsius = value;
  }

  get fahrenheit() {
    return this._celsius * 1.8 + 32;
  }

  set fahrenheit(value) {
    this._celsius = (value - 32) / 1.8;
  }
}

const temp = new Temperature(25);
console.log(temp.fahrenheit); // 77
temp.fahrenheit = 86;
console.log(temp.celsius); // 30
```

### Property Descriptor for Accessors

When you get the descriptor of an accessor property:

```js
const obj = {
  get prop() {
    return "value";
  },
  set prop(value) {
    // ...
  },
};

const descriptor = Object.getOwnPropertyDescriptor(obj, "prop");
console.log(descriptor);
// {
//   get: [Function: get prop],
//   set: [Function: set prop],
//   enumerable: true,
//   configurable: true
// }
// Note: No 'value' or 'writable' properties
```

### Important Notes About Accessors

1. **Cannot have both `value` and `get`/`set`:** A property descriptor cannot have both data property attributes (`value`, `writable`) and accessor attributes (`get`, `set`).

   ```js
   // âŒ Invalid
   Object.defineProperty(obj, "prop", {
     value: 10,
     get() {
       return 20;
     },
   }); // TypeError
   ```

2. **Getter/Setter are functions:** They are called as methods, but accessed as properties (no parentheses).

   ```js
   obj.fullName; // Calls getter
   obj.fullName = "New"; // Calls setter
   ```

3. **`this` binding:** Getters and setters are bound to the object they belong to, so `this` refers to the object.

4. **Inheritance:** Accessors work with prototype inheritance:

```js
const parent = {
  get value() {
    return this._value || 0;
  },
  set value(val) {
    this._value = val;
  },
};

const child = Object.create(parent);
child.value = 10;
console.log(child.value); // 10
```

### When to Use Getters/Setters

**âœ… Use When:**

- You need computed/derived properties
- You need validation before setting values
- You want to maintain data integrity
- You need to trigger side effects on property access
- You want to hide implementation details

**âŒ Avoid When:**

- Simple data storage (just use regular properties)
- Performance-critical code (getters have function call overhead)
- Over-engineering simple objects

---

## ðŸ”· 4. Immutability & Control

| Method                          | Purpose                                                     |
| ------------------------------- | ----------------------------------------------------------- |
| `Object.freeze(obj)`            | Makes object fully immutable (shallow)                      |
| `Object.seal(obj)`              | Prevents adding/removing props, but values can still change |
| `Object.preventExtensions(obj)` | Prevents new properties from being added                    |
| `Object.isFrozen(obj)`          | Checks if object is frozen                                  |
| `Object.isSealed(obj)`          | Checks if object is sealed                                  |
| `Object.isExtensible(obj)`      | Checks if object can be extended                            |

### Comparison: Freeze vs Seal vs PreventExtensions

| Method                | Add Properties | Delete Properties | Modify Properties | Effect Level              |
| --------------------- | -------------- | ----------------- | ----------------- | ------------------------- |
| **Normal Object**     | âœ… Yes         | âœ… Yes            | âœ… Yes            | Fully mutable             |
| **preventExtensions** | âŒ No          | âœ… Yes            | âœ… Yes            | Prevents new properties   |
| **seal**              | âŒ No          | âŒ No             | âœ… Yes            | Prevents structure change |
| **freeze**            | âŒ No          | âŒ No             | âŒ No             | Fully immutable           |

### Examples

```js
// Normal object
let obj1 = { name: "John", age: 30 };
obj1.city = "NYC"; // âœ… Can add
delete obj1.age; // âœ… Can delete
obj1.name = "Jane"; // âœ… Can modify

// preventExtensions - Can't add, but can delete and modify
let obj2 = { name: "John", age: 30 };
Object.preventExtensions(obj2);
obj2.city = "NYC"; // âŒ Cannot add (silently fails or throws in strict mode)
delete obj2.age; // âœ… Can delete
obj2.name = "Jane"; // âœ… Can modify

// seal - Can't add or delete, but can modify
let obj3 = { name: "John", age: 30 };
Object.seal(obj3);
obj3.city = "NYC"; // âŒ Cannot add
delete obj3.age; // âŒ Cannot delete (silently fails or throws in strict mode)
obj3.name = "Jane"; // âœ… Can modify

// freeze - Can't add, delete, or modify (fully immutable)
let obj4 = { name: "John", age: 30 };
Object.freeze(obj4);
obj4.city = "NYC"; // âŒ Cannot add
delete obj4.age; // âŒ Cannot delete
obj4.name = "Jane"; // âŒ Cannot modify (silently fails or throws in strict mode)
```

### Important Notes About Immutability Methods

1. **Shallow Only:** All three methods work **shallowly** - nested objects are not affected:

   ```js
   const obj = { nested: { value: 10 } };
   Object.freeze(obj);
   obj.nested.value = 20; // âœ… Still works! (nested object not frozen)
   obj.nested = {}; // âŒ Cannot replace (top level frozen)
   ```

2. **Strict Mode:** In strict mode, attempts to modify frozen/sealed objects throw errors. In non-strict mode, they fail silently.

3. **Cannot Reverse:** Once frozen/sealed/prevented, you cannot reverse the operation. You'd need to create a new object.

4. **Use Cases:**

   - **preventExtensions:** When you want to prevent new properties but allow modification
   - **seal:** When you want a fixed structure but allow value changes
   - **freeze:** When you want complete immutability (common in React/Redux)

---

## ðŸ”· 5. Utilities & Meta

| Method                        | Purpose                                              |
| ----------------------------- | ---------------------------------------------------- |
| `Object.fromEntries(entries)` | Converts `[key, value]` array into object            |
| `Object.groupBy(array, fn)`   | Groups array elements by key (ES2024)                |
| `Object.is(val1, val2)`       | Like `===` but correctly handles `NaN`, `+0` vs `-0` |
| `Object.toString.call(value)` | Gets accurate type info (like `[object Array]`)      |

```js
// Object.fromEntries - Convert Map/Array to Object
const entries = [
  ["a", 1],
  ["b", 2],
];
Object.fromEntries(entries); // { a: 1, b: 2 }

const map = new Map([
  ["x", 10],
  ["y", 20],
]);
Object.fromEntries(map); // { x: 10, y: 20 }

// Object.groupBy (ES2024) - Group array by key
const inventory = [
  { name: "asparagus", type: "vegetables", quantity: 5 },
  { name: "bananas", type: "fruit", quantity: 0 },
  { name: "goat", type: "meat", quantity: 23 },
];

Object.groupBy(inventory, ({ type }) => type);
// {
//   vegetables: [{ name: "asparagus", type: "vegetables", quantity: 5 }],
//   fruit: [{ name: "bananas", type: "fruit", quantity: 0 }],
//   meat: [{ name: "goat", type: "meat", quantity: 23 }]
// }

// Object.is - Precise equality check
Object.is(NaN, NaN); // true
Object.is(+0, -0); // false
Object.is(42, 42); // true
Object.is("foo", "foo"); // true
Object.is([], []); // false (different references)
Object.is(null, null); // true
```

---

## ðŸ§  Interview Highlights & Common Questions

### ðŸ”¸ How to clone an object?

```js
// Shallow clone
const shallow1 = Object.assign({}, obj);
const shallow2 = { ...obj };

// Deep clone
const deep1 = structuredClone(obj); // âœ… Modern (ES2022)
const deep2 = JSON.parse(JSON.stringify(obj)); // âš ï¸ Limitations

// Clone with descriptors
const clone = Object.create(
  Object.getPrototypeOf(obj),
  Object.getOwnPropertyDescriptors(obj)
);
```

ðŸ“– For comprehensive cloning methods, see [15. Copying](../../14.%20Copying/)

### ðŸ”¸ How to check if an object is empty?

```js
// Method 1: Object.keys()
Object.keys(obj).length === 0;

// Method 2: Object.entries()
Object.entries(obj).length === 0;

// Method 3: for...in loop
function isEmpty(obj) {
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) return false;
  }
  return true;
}

// Method 4: JSON.stringify (works for plain objects)
JSON.stringify(obj) === "{}";
```

### ðŸ”¸ How to merge two objects deeply?

```js
// Shallow merge
const merged = { ...obj1, ...obj2 };
const merged = Object.assign({}, obj1, obj2);

// Deep merge (custom implementation needed or use library like Lodash)
function deepMerge(target, source) {
  const output = { ...target };
  for (const key in source) {
    if (isObject(source[key]) && isObject(target[key])) {
      output[key] = deepMerge(target[key], source[key]);
    } else {
      output[key] = source[key];
    }
  }
  return output;
}
```

### ðŸ”¸ How to compare two objects?

```js
// Shallow comparison
JSON.stringify(obj1) === JSON.stringify(obj2); // âš ï¸ Order matters

// Deep comparison (custom)
function deepEqual(obj1, obj2) {
  if (obj1 === obj2) return true;
  if (typeof obj1 !== "object" || typeof obj2 !== "object") return false;
  if (obj1 === null || obj2 === null) return false;

  const keys1 = Object.keys(obj1);
  const keys2 = Object.keys(obj2);
  if (keys1.length !== keys2.length) return false;

  for (let key of keys1) {
    if (!keys2.includes(key)) return false;
    if (!deepEqual(obj1[key], obj2[key])) return false;
  }
  return true;
}
```

### ðŸ”¸ How to remove undefined/null properties?

```js
// Remove undefined/null
const cleaned = Object.fromEntries(
  Object.entries(obj).filter(([_, v]) => v != null)
);

// Remove specific values
const cleaned = Object.fromEntries(
  Object.entries(obj).filter(([_, v]) => v !== undefined)
);
```

### ðŸ”¸ How to get all keys including non-enumerable?

```js
Object.getOwnPropertyNames(obj); // Own properties (includes non-enumerable)
Object.keys(obj); // Own enumerable properties only
Reflect.ownKeys(obj); // Own properties including Symbols
Object.getOwnPropertySymbols(obj); // Symbol properties only
```

### ðŸ”¸ Non-enumerable property

```js
Object.defineProperty(obj, "hidden", {
  value: 123,
  enumerable: false,
});

// Won't show in Object.keys() or for...in
Object.keys(obj); // []
for (let key in obj) console.log(key); // (nothing)
```

### ðŸ”¸ `in` vs `hasOwnProperty()` vs `Object.hasOwn()`

```js
const obj = { a: 1 };
Object.prototype.b = 2;

"a" in obj; // true (checks prototype chain)
"b" in obj; // true (checks prototype chain)

obj.hasOwnProperty("a"); // true (own property only)
obj.hasOwnProperty("b"); // false (inherited property)

Object.hasOwn(obj, "a"); // true âœ… (safer, newer ES2022)
Object.hasOwn(obj, "b"); // false
```

### ðŸ”¸ `for...in` vs `Object.keys()` vs `Object.entries()`

```js
const obj = { a: 1, b: 2 };
Object.prototype.c = 3;

// for...in - includes inherited enumerable props
for (let key in obj) {
  console.log(key); // a, b, c (includes inherited)
}

// Object.keys() - own enumerable props only
Object.keys(obj); // ['a', 'b']

// Object.entries() - own enumerable [key, value] pairs
Object.entries(obj); // [['a', 1], ['b', 2]]
```

### ðŸ”¸ Deep freeze implementation

```js
function deepFreeze(obj) {
  // Retrieve property names
  Object.getOwnPropertyNames(obj).forEach((prop) => {
    const value = obj[prop];
    // Freeze recursively if value is an object
    if (value && typeof value === "object") {
      deepFreeze(value);
    }
  });
  // Freeze self
  return Object.freeze(obj);
}

const obj = { a: { b: 2 } };
deepFreeze(obj);
obj.a.b = 3; // Throws error in strict mode or silently fails
```

### ðŸ”¸ Object transformation patterns

```js
// Map object values
const doubled = Object.fromEntries(
  Object.entries(obj).map(([key, value]) => [key, value * 2])
);

// Filter object properties
const filtered = Object.fromEntries(
  Object.entries(obj).filter(([key, value]) => value > 10)
);

// Transform object keys
const renamed = Object.fromEntries(
  Object.entries(obj).map(([key, value]) => [`new_${key}`, value])
);
```

---

## âœ… Quick Reference Cheat Sheet

```js
Object.create(proto);
Object.assign(target, source);
Object.defineProperty(obj, key, descriptor);
Object.getOwnPropertyDescriptor(obj, key);
Object.freeze(obj);
Object.seal(obj);
Object.keys(obj);
Object.values(obj);
Object.entries(obj);
Object.fromEntries(arr);
Object.getPrototypeOf(obj);
Object.setPrototypeOf(obj, proto);
obj.hasOwnProperty("key");
Object.hasOwn(obj, "key"); // âœ… safer and newer
```

---

---

## ðŸ”· 6. Object Cloning Patterns

### Shallow Clone Methods

```js
// Method 1: Spread operator (most common)
const clone = { ...obj };

// Method 2: Object.assign()
const clone = Object.assign({}, obj);

// Method 3: Object.create() with descriptors (preserves getters/setters)
const clone = Object.create(
  Object.getPrototypeOf(obj),
  Object.getOwnPropertyDescriptors(obj)
);
```

### Deep Clone Methods

```js
// Method 1: structuredClone() (ES2022 - recommended)
const deepClone = structuredClone(obj);

// Method 2: JSON method (limitations: no functions, Dates, etc.)
const deepClone = JSON.parse(JSON.stringify(obj));

// Method 3: Custom recursive implementation
function deepClone(obj) {
  if (obj === null || typeof obj !== "object") return obj;
  if (obj instanceof Date) return new Date(obj.getTime());
  if (Array.isArray(obj)) return obj.map((item) => deepClone(item));

  const clone = {};
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      clone[key] = deepClone(obj[key]);
    }
  }
  return clone;
}
```

ðŸ“– For comprehensive cloning guide, see [15. Copying](../../14.%20Copying/)

---

ðŸ’¡ **Tip:** In interviews, show deep understanding by explaining how these methods relate to **enumerability, descriptors, prototype chaining, immutability**, and **cloning**.
