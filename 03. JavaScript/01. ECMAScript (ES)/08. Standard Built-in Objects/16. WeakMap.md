# ‚úÖ Must-Know `WeakMap` Object

`WeakMap` is a collection of key-value pairs where **keys must be objects** and are weakly referenced. ES6 feature.

---

## Key Characteristics

- ‚úÖ **Object keys only** (no primitives)
- ‚úÖ **Weak references** - doesn't prevent GC
- ‚ùå **Not iterable** - no `forEach`, `for...of`, `keys()`, `values()`, `entries()`
- ‚ùå **No size property** - cannot get count
- ‚úÖ **Automatic cleanup** - entries removed when keys are GC'd

---

## Creating WeakMap

```js
// Empty WeakMap
const weakMap = new WeakMap();

// From array of [key, value] pairs (keys must be objects)
const obj1 = { id: 1 };
const obj2 = { id: 2 };
const weakMap = new WeakMap([
  [obj1, "value1"],
  [obj2, "value2"],
]);

// Cannot use primitives as keys
const weakMap = new WeakMap([["key", "value"]]); // TypeError
```

---

## WeakMap Methods

| Method                    | Description            | Returns                |
| ------------------------- | ---------------------- | ---------------------- |
| `weakMap.set(key, value)` | Sets value for key     | `WeakMap`              |
| `weakMap.get(key)`        | Gets value for key     | `value` or `undefined` |
| `weakMap.has(key)`        | Checks if key exists   | `boolean`              |
| `weakMap.delete(key)`     | Removes key-value pair | `boolean`              |

**Note:** No `clear()` or `size` property!

---

## Common Use Cases

### 1. Private Data Storage

```js
const privateData = new WeakMap();

class User {
  constructor(name) {
    privateData.set(this, { name, secret: "hidden" });
  }

  getName() {
    return privateData.get(this).name;
  }

  getSecret() {
    return privateData.get(this).secret; // Only accessible with 'this'
  }
}

const user = new User("John");
user.secret; // undefined (cannot access directly)
user.getSecret(); // "hidden" (accessible via method)
```

### 2. Metadata Without Memory Leaks

```js
const metadata = new WeakMap();

function attachMetadata(obj, data) {
  metadata.set(obj, data);
}

function getMetadata(obj) {
  return metadata.get(obj);
}

// When obj is GC'd, metadata entry is automatically removed
```

### 3. Caching Without Preventing GC

```js
const cache = new WeakMap();

function computeExpensive(obj) {
  if (cache.has(obj)) {
    return cache.get(obj);
  }
  const result = /* expensive computation */;
  cache.set(obj, result);
  return result;
}
```

### 4. DOM Element Metadata

```js
const elementData = new WeakMap();

function attachData(element, data) {
  elementData.set(element, data);
}

// When DOM element is removed, entry is automatically cleaned up
// No memory leak!
```

---

## WeakMap vs Map

| Feature      | WeakMap                | Map             |
| ------------ | ---------------------- | --------------- |
| **Keys**     | Objects only           | Any type        |
| **Iterable** | ‚ùå No                  | ‚úÖ Yes          |
| **Size**     | ‚ùå No                  | ‚úÖ Yes          |
| **GC**       | ‚úÖ Weak (auto cleanup) | ‚ùå Strong       |
| **Use Case** | Private data, metadata | Key-value store |

---

## Important Notes

### ‚ö†Ô∏è Only Object Keys

```js
const weakMap = new WeakMap();
weakMap.set("string", "value"); // TypeError: Invalid value used as weak map key
weakMap.set(1, "value"); // TypeError
weakMap.set({}, "value"); // ‚úÖ OK
```

### ‚ö†Ô∏è Cannot Iterate

```js
const weakMap = new WeakMap([[obj1, "value1"]]);

// These don't exist:
weakMap.forEach(); // TypeError
for (const [key, value] of weakMap) {
} // TypeError
weakMap.keys(); // TypeError
weakMap.size; // undefined
```

### ‚úÖ Automatic Cleanup

```js
let obj = { id: 1 };
const weakMap = new WeakMap([[obj, "data"]]);

weakMap.has(obj); // true

// Clear strong reference
obj = null;

// Eventually, obj is GC'd and entry is automatically removed
// (Prevents memory leaks!)
```

---

## Interview Common Questions

### Q: What is WeakMap?

A key-value collection where keys must be objects and are weakly referenced. Entries are automatically removed when keys are garbage collected.

### Q: Why use WeakMap over Map?

When you want to associate data with objects without preventing their garbage collection. Perfect for private data, metadata, and preventing memory leaks.

### Q: Can WeakMap have primitive keys?

No, only objects. Attempting to use primitives as keys throws TypeError.

### Q: Can you iterate over WeakMap?

No. WeakMap is not iterable - no `forEach`, `for...of`, `keys()`, `values()`, or `entries()` methods.

### Q: Use case for WeakMap?

Private data storage in classes, DOM element metadata, caching without memory leaks.

---

üìñ **See Also:**

- [03. Special Types (Map, Set, WeakMap, WeakSet)](<../../04.%20Data%20Types/03.%20Special%20Types%20(Map,%20Set,%20WeakMap,%20WeakSet).md>) for comprehensive WeakMap documentation
- [17. Map.md](./17.%20Map.md) for Map
