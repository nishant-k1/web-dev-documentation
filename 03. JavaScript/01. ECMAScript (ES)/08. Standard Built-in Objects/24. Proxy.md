# ‚úÖ Must-Know `Proxy` Object

`Proxy` enables you to create a wrapper around an object that intercepts and customizes fundamental operations (property access, assignment, enumeration, etc.). ES6 feature.

---

## Creating Proxy

```js
const target = {};
const handler = {
  get(target, prop) {
    return prop in target ? target[prop] : "default";
  },
};

const proxy = new Proxy(target, handler);
proxy.name; // "default" (intercepted!)
```

---

## Proxy Traps (Handler Methods)

Common traps for intercepting operations:

### `get(target, prop, receiver)` ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

Intercepts property access.

```js
const handler = {
  get(target, prop) {
    console.log(`Accessing property: ${prop}`);
    return target[prop] ?? "default";
  },
};

const proxy = new Proxy({ name: "John" }, handler);
proxy.name; // Logs: "Accessing property: name", Returns: "John"
proxy.age; // Logs: "Accessing property: age", Returns: "default"
```

### `set(target, prop, value, receiver)` ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

Intercepts property assignment.

```js
const handler = {
  set(target, prop, value) {
    if (prop === "age" && (value < 0 || value > 150)) {
      throw new Error("Invalid age");
    }
    target[prop] = value;
    return true; // Indicates success
  },
};

const proxy = new Proxy({}, handler);
proxy.age = 25; // OK
proxy.age = 200; // Error: Invalid age
```

### `has(target, prop)` ‚≠ê‚≠ê‚≠ê

Intercepts `in` operator.

```js
const handler = {
  has(target, prop) {
    return prop.startsWith("_") ? false : prop in target;
  },
};

const proxy = new Proxy({ name: "John", _secret: "hidden" }, handler);
"name" in proxy; // true
"_secret" in proxy; // false (hidden)
```

### `deleteProperty(target, prop)` ‚≠ê‚≠ê‚≠ê

Intercepts `delete` operator.

```js
const handler = {
  deleteProperty(target, prop) {
    if (prop.startsWith("_")) {
      return false; // Prevent deletion
    }
    delete target[prop];
    return true;
  },
};
```

### `ownKeys(target)` ‚≠ê‚≠ê‚≠ê

Intercepts `Object.keys()`, `Object.getOwnPropertyNames()`, etc.

```js
const handler = {
  ownKeys(target) {
    return Object.keys(target).filter((key) => !key.startsWith("_"));
  },
};

const proxy = new Proxy({ name: "John", _secret: "hidden" }, handler);
Object.keys(proxy); // ['name'] (excludes _secret)
```

### `apply(target, thisArg, argumentsList)` ‚≠ê‚≠ê‚≠ê

Intercepts function calls.

```js
const handler = {
  apply(target, thisArg, argumentsList) {
    console.log("Function called with:", argumentsList);
    return target.apply(thisArg, argumentsList);
  },
};

function sum(a, b) {
  return a + b;
}

const proxy = new Proxy(sum, handler);
proxy(1, 2); // Logs: "Function called with: [1, 2]", Returns: 3
```

---

## Common Use Cases

### 1. Property Validation

```js
const validator = {
  set(target, prop, value) {
    if (prop === "email" && !value.includes("@")) {
      throw new Error("Invalid email");
    }
    if (prop === "age" && (typeof value !== "number" || value < 0)) {
      throw new Error("Invalid age");
    }
    target[prop] = value;
    return true;
  },
};

const user = new Proxy({}, validator);
user.email = "john@example.com"; // OK
user.age = 25; // OK
user.email = "invalid"; // Error: Invalid email
```

### 2. Default Values

```js
const withDefaults = {
  get(target, prop) {
    return prop in target ? target[prop] : `default_${prop}`;
  },
};

const obj = new Proxy({ name: "John" }, withDefaults);
obj.name; // "John"
obj.age; // "default_age"
```

### 3. Logging/Debugging

```js
const logger = {
  get(target, prop) {
    console.log(`Getting ${prop}`);
    return target[prop];
  },
  set(target, prop, value) {
    console.log(`Setting ${prop} = ${value}`);
    target[prop] = value;
    return true;
  },
};
```

### 4. Reactivity (Vue-style)

```js
function reactive(target) {
  const handler = {
    set(target, prop, value) {
      target[prop] = value;
      console.log(`Property ${prop} changed, triggering update`);
      // Trigger re-render here
      return true;
    },
  };
  return new Proxy(target, handler);
}

const state = reactive({ count: 0 });
state.count = 1; // Logs: "Property count changed, triggering update"
```

---

## Proxy Traps Reference

| Trap                       | Intercepts                          | Returns                 |
| -------------------------- | ----------------------------------- | ----------------------- |
| `get`                      | Property access                     | Any value               |
| `set`                      | Property assignment                 | Boolean                 |
| `has`                      | `in` operator                       | Boolean                 |
| `deleteProperty`           | `delete` operator                   | Boolean                 |
| `ownKeys`                  | `Object.keys()`, etc.               | Array of strings        |
| `getOwnPropertyDescriptor` | `Object.getOwnPropertyDescriptor()` | Descriptor or undefined |
| `defineProperty`           | `Object.defineProperty()`           | Boolean                 |
| `preventExtensions`        | `Object.preventExtensions()`        | Boolean                 |
| `getPrototypeOf`           | `Object.getPrototypeOf()`           | Object or null          |
| `isExtensible`             | `Object.isExtensible()`             | Boolean                 |
| `setPrototypeOf`           | `Object.setPrototypeOf()`           | Boolean                 |
| `apply`                    | Function call                       | Any value               |
| `construct`                | `new` operator                      | Object                  |

---

## Important Notes

### ‚ö†Ô∏è Not All Operations Are Proxied

Some operations bypass Proxy:

- `typeof` operator
- `instanceof` operator
- Some built-in methods

### ‚úÖ Use Reflect for Consistency

Use `Reflect` methods in Proxy handlers to maintain default behavior:

```js
const handler = {
  get(target, prop) {
    // Custom logic
    return Reflect.get(target, prop); // Default behavior
  },
};
```

---

## Interview Common Questions

### Q: What is Proxy?

A wrapper that intercepts operations on objects (property access, assignment, etc.) allowing customization of behavior.

### Q: Common use cases for Proxy?

- Property validation
- Default values
- Logging/debugging
- Reactivity (Vue, MobX)
- Access control

### Q: How does Proxy relate to Reflect?

`Reflect` provides methods that correspond to Proxy traps. Use `Reflect` methods in Proxy handlers to maintain default behavior.

---

üìñ **See Also:**

- [27. Reflect.md](./27.%20Reflect.md) for Reflect API
- [32. Proxy and Reflect API/](../../32.%20Proxy%20and%20Reflect%20API/) for comprehensive Proxy documentation with all traps and advanced patterns
