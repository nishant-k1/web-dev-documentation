# ‚úÖ Must-Know `WeakRef` Object (ES2021)

`WeakRef` lets you hold a weak reference to an object, allowing it to be garbage collected even if the WeakRef still references it.

---

## Creating WeakRef

```js
const obj = { data: "important" };
const weakRef = new WeakRef(obj);

// Access the target
const target = weakRef.deref(); // Returns obj or undefined if GC'd
console.log(target?.data); // "important"
```

---

## WeakRef Methods

### `deref()`

Returns the target object if it still exists, or `undefined` if it was garbage collected.

```js
const obj = { value: 42 };
const weakRef = new WeakRef(obj);

// Get the target object (or undefined if garbage collected)
const target = weakRef.deref();

if (target) {
  console.log(target.value); // 42
} else {
  console.log("Object was garbage collected");
}
```

---

## When Target is Garbage Collected

```js
let obj = { data: "test" };
const weakRef = new WeakRef(obj);

// Clear strong reference
obj = null;

// At some point, GC may collect the object
// After GC, deref() returns undefined
setTimeout(() => {
  const target = weakRef.deref();
  console.log(target); // undefined (if GC'd) or { data: "test" } (if not)
}, 1000);
```

---

## Common Use Cases

### 1. Cache Implementation

```js
class WeakCache {
  constructor() {
    this.cache = new Map();
  }

  get(key) {
    const ref = this.cache.get(key);
    if (!ref) return undefined;

    const value = ref.deref();
    if (value === undefined) {
      // Entry was garbage collected, remove from cache
      this.cache.delete(key);
      return undefined;
    }

    return value;
  }

  set(key, value) {
    this.cache.set(key, new WeakRef(value));
  }
}

// Usage
const cache = new WeakCache();
cache.set("user1", { id: 1, name: "John" });
const user = cache.get("user1"); // { id: 1, name: "John" }
```

### 2. Preventing Memory Leaks

```js
// Store references without preventing GC
const listeners = new Map();

function addListener(element, callback) {
  const weakRef = new WeakRef(element);
  listeners.set(weakRef, callback);
}

function cleanupListeners() {
  for (const [ref, callback] of listeners.entries()) {
    if (ref.deref() === undefined) {
      // Element was GC'd, remove listener
      listeners.delete(ref);
    }
  }
}
```

### 3. Observing Object Lifecycle

```js
function trackObject(obj) {
  const weakRef = new WeakRef(obj);

  // Periodically check if object still exists
  const interval = setInterval(() => {
    if (weakRef.deref() === undefined) {
      console.log("Object was garbage collected");
      clearInterval(interval);
    }
  }, 1000);
}
```

---

## Important Notes

### ‚ö†Ô∏è Unpredictable Timing

GC timing is **non-deterministic**. You cannot rely on when objects will be collected:

```js
const obj = { data: "test" };
const weakRef = new WeakRef(obj);
obj = null;

// This might be undefined or might still have the object
// Depends on when GC runs
const target = weakRef.deref();
```

### ‚ö†Ô∏è Not for Critical Cleanup

Don't use WeakRef for critical cleanup - use FinalizationRegistry instead.

### ‚úÖ Use Cases

- Caching large objects
- Tracking objects without preventing GC
- Implementing weak maps/sets (though `WeakMap`/`WeakSet` are better)

---

## WeakRef vs WeakMap

| Feature      | WeakRef                 | WeakMap                       |
| ------------ | ----------------------- | ----------------------------- |
| **Purpose**  | Single object reference | Key-value pairs               |
| **Keys**     | N/A                     | Objects only                  |
| **Access**   | `deref()` method        | `get()` method                |
| **Use Case** | Simple weak reference   | Associating data with objects |

---

## Interview Common Questions

### Q: What is WeakRef?

A weak reference that doesn't prevent garbage collection. `deref()` returns the object if it still exists, or `undefined` if it was GC'd.

### Q: When would you use WeakRef?

- Caching large objects without preventing GC
- Tracking objects without memory leaks
- Implementing weak data structures

### Q: Difference between WeakRef and WeakMap?

**WeakRef:**

- Single object reference
- Can check if object exists
- More flexible

**WeakMap:**

- Key-value pairs (keys must be objects)
- Automatically removes entries when keys are GC'd
- Better for associating data with objects

---

üìñ **See Also:**

- [23. FinalizationRegistry.md](./23.%20FinalizationRegistry.md) for cleanup callbacks
- [18. WeakMap.md](./18.%20WeakMap.md) for WeakMap
- [16. WeakSet.md](./16.%20WeakSet.md) for WeakSet
