# âœ… Must-Know `Promise` Object â­â­â­â­â­

`Promise` is a built-in object for handling asynchronous operations. **Most frequently asked in interviews!**

---

## What is a Promise?

A Promise is an object that represents the eventual completion or failure of an asynchronous operation. It has three states:

- **Pending**: Initial state, neither fulfilled nor rejected
- **Fulfilled**: Operation completed successfully
- **Rejected**: Operation failed

---

## Creating Promises

### Constructor

```js
const promise = new Promise((resolve, reject) => {
  // Async operation
  if (success) {
    resolve(value); // Fulfilled
  } else {
    reject(error); // Rejected
  }
});
```

### Helper Methods

```js
Promise.resolve(value); // Creates fulfilled promise
Promise.reject(reason); // Creates rejected promise
```

---

## Instance Methods

### `then(onFulfilled, onRejected?)` â­â­â­â­â­

Handles fulfillment or rejection.

```js
promise.then(
  (value) => {
    // Fulfilled handler
  },
  (error) => {
    // Rejected handler (optional)
  }
);
```

### `catch(onRejected)` â­â­â­â­â­

Handles rejection (shorthand for `.then(null, onRejected)`).

```js
promise.catch((error) => {
  // Error handling
});
```

### `finally(onFinally)` â­â­â­

Runs regardless of fulfillment or rejection.

```js
promise.finally(() => {
  // Cleanup code (always runs)
});
```

---

## Promise Static Methods â­â­â­â­â­

### `Promise.all(promises)` - Wait for All

Waits for **all promises to resolve**, or rejects if **any promise rejects** (fail-fast).

```js
const p1 = Promise.resolve(1);
const p2 = Promise.resolve(2);
const p3 = Promise.resolve(3);

Promise.all([p1, p2, p3]).then((values) => {
  console.log(values); // [1, 2, 3]
});

// If any rejects, entire Promise.all rejects
Promise.all([p1, Promise.reject("Error"), p3]).catch((error) => {
  console.error(error); // "Error"
});
```

**Use Cases:**

- Fetching multiple API endpoints in parallel
- All operations must succeed
- Fail-fast behavior

---

### `Promise.race(promises)` - First to Settle

Returns promise that resolves or rejects **as soon as the first promise settles**.

```js
const p1 = new Promise((resolve) => setTimeout(() => resolve("First"), 1000));
const p2 = new Promise((resolve) => setTimeout(() => resolve("Second"), 500));

Promise.race([p1, p2]).then((value) => {
  console.log(value); // "Second" (faster)
});
```

**Use Cases:**

- Timeout patterns
- First response wins
- Racing multiple data sources

---

### `Promise.allSettled(promises)` â­ (ES2020)

Waits for **all promises to settle**, **never rejects**.

```js
const p1 = Promise.resolve(1);
const p2 = Promise.reject("Error");
const p3 = Promise.resolve(3);

Promise.allSettled([p1, p2, p3]).then((results) => {
  console.log(results);
  // [
  //   { status: 'fulfilled', value: 1 },
  //   { status: 'rejected', reason: 'Error' },
  //   { status: 'fulfilled', value: 3 }
  // ]
});
```

**Use Cases:**

- Need results from all promises, even if some fail
- Batch operations where partial success is acceptable

---

### `Promise.any(promises)` â­ (ES2021)

Returns promise that resolves when **first promise resolves**, or rejects if **all promises reject**.

```js
const p1 = Promise.reject("Error 1");
const p2 = Promise.resolve("Success");
const p3 = Promise.reject("Error 2");

Promise.any([p1, p2, p3]).then((value) => {
  console.log(value); // "Success" (first to resolve)
});

// If all reject
Promise.any([Promise.reject("Error 1"), Promise.reject("Error 2")]).catch(
  (error) => {
    console.error(error); // AggregateError: All promises were rejected
  }
);
```

**Use Cases:**

- First success wins
- Fallback strategies
- Redundant data sources

---

### `Promise.resolve(value)`

Creates a resolved promise.

```js
Promise.resolve(42).then((value) => console.log(value)); // 42
```

---

### `Promise.reject(reason)`

Creates a rejected promise.

```js
Promise.reject("Error").catch((error) => console.error(error)); // "Error"
```

---

### `Promise.withResolvers()` â­ (ES2024)

Returns an object with `{promise, resolve, reject}` to resolve/reject the promise externally.

```js
const { promise, resolve, reject } = Promise.withResolvers();

// Resolve or reject later
setTimeout(() => resolve("Success"), 1000);

promise.then((value) => {
  console.log(value); // "Success" after 1 second
});
```

**Use Cases:**

- When you need to expose resolve/reject to external code
- Event-driven promise resolution
- Converting callback-based APIs to Promises

```js
// Example: Convert callback to Promise with external control
function createPromise() {
  const { promise, resolve, reject } = Promise.withResolvers();

  // Expose resolve/reject to caller
  return { promise, resolve, reject };
}

const { promise, resolve } = createPromise();
// Caller can resolve whenever needed
resolve("Done");
```

---

## Comparison Table

| Method                 | Behavior         | Rejects When              | Use Case           |
| ---------------------- | ---------------- | ------------------------- | ------------------ |
| **Promise.all**        | Waits for all    | **Any promise rejects**   | All must succeed   |
| **Promise.race**       | First to settle  | **First promise rejects** | First result wins  |
| **Promise.allSettled** | Waits for all    | **Never rejects**         | Need all results   |
| **Promise.any**        | First to resolve | **All promises reject**   | First success wins |

---

## Common Patterns

### Timeout Pattern

```js
function withTimeout(promise, timeoutMs) {
  const timeout = new Promise((_, reject) =>
    setTimeout(() => reject(new Error("Timeout")), timeoutMs)
  );
  return Promise.race([promise, timeout]);
}
```

### Parallel Execution

```js
// Execute multiple promises in parallel
const [users, posts, comments] = await Promise.all([
  fetchUsers(),
  fetchPosts(),
  fetchComments(),
]);
```

### Sequential Execution

```js
// Execute promises sequentially
const user = await fetchUser();
const posts = await fetchUserPosts(user.id);
const comments = await fetchPostComments(posts[0].id);
```

### Promise Chaining â­â­â­â­â­

Chaining `.then()` methods to handle sequences of async operations.

```js
fetch("/api/user")
  .then((response) => response.json())
  .then((user) => {
    return fetch(`/api/posts/${user.id}`);
  })
  .then((response) => response.json())
  .then((posts) => {
    console.log(posts);
  })
  .catch((error) => {
    console.error("Error in chain:", error);
  });
```

**Key Points:**

- Each `.then()` returns a new Promise
- Return value becomes the input to next `.then()`
- Single `.catch()` handles errors from any step
- Chain continues even if intermediate steps return non-promises

---

## Promise Execution Order (Microtask Queue) â­â­â­

Promises use the **microtask queue**, which has higher priority than the regular task queue (macrotasks).

```js
console.log("1");

setTimeout(() => console.log("2"), 0); // Macrotask

Promise.resolve().then(() => console.log("3")); // Microtask

console.log("4");

// Output: 1, 4, 3, 2
// Microtasks (3) run before macrotasks (2)
```

**Execution Order:**

1. Synchronous code
2. Microtasks (Promises, queueMicrotask)
3. Macrotasks (setTimeout, setInterval, I/O)

---

## Error Handling

### Unhandled Promise Rejections

When a Promise rejects and there's no `.catch()` handler, it becomes an **unhandled rejection**.

```js
// Browser
window.addEventListener("unhandledrejection", (event) => {
  console.error("Unhandled rejection:", event.reason);
  event.preventDefault(); // Prevent default console error
});

// Node.js
process.on("unhandledRejection", (reason, promise) => {
  console.error("Unhandled rejection:", reason);
});
```

**Best Practice:** Always add `.catch()` to promise chains:

```js
// âœ… Good
promise.then(handleSuccess).catch(handleError); // Always handle errors

// âŒ Bad - unhandled rejection possible
promise.then(handleSuccess);
```

### Error Propagation

Errors in promise chains propagate to the nearest `.catch()`:

```js
Promise.resolve()
  .then(() => {
    throw new Error("Error 1");
  })
  .then(() => {
    // Skipped due to error above
  })
  .catch((error) => {
    console.error(error); // Catches "Error 1"
    return "recovered";
  })
  .then((value) => {
    console.log(value); // "recovered" (chain continues after catch)
  });
```

---

## Interview Common Questions

### Q: Difference between Promise.all and Promise.race?

**Promise.all:**

- Waits for ALL promises to resolve
- Rejects if ANY promise rejects (fail-fast)
- Returns array of all results

**Promise.race:**

- Returns first promise to settle (resolve OR reject)
- Doesn't wait for others
- Returns value from first settled promise

### Q: When to use Promise.allSettled?

When you need results from all promises regardless of failures. Unlike Promise.all, it doesn't fail-fast.

### Q: What does Promise.race([]) return?

A promise that **stays pending forever** (no promises to race).

### Q: Implement a timeout pattern?

```js
function withTimeout(promise, timeoutMs) {
  const timeout = new Promise((_, reject) =>
    setTimeout(() => reject(new Error("Timeout")), timeoutMs)
  );
  return Promise.race([promise, timeout]);
}
```

### Q: Promise execution order - what logs first?

```js
console.log("1");
Promise.resolve().then(() => console.log("2"));
setTimeout(() => console.log("3"), 0);
console.log("4");
// Output: 1, 4, 2, 3
// Microtasks (2) run before macrotasks (3)
```

### Q: How does Promise chaining work?

Each `.then()` returns a new Promise. The return value becomes the resolved value for the next `.then()`. If you return a Promise, the chain waits for it to resolve.

### Q: How to handle errors in Promise chains?

Use `.catch()` at the end of the chain. Errors propagate down the chain until caught. After `.catch()`, the chain can continue if you return a value.

```js
promise
  .then(step1)
  .then(step2)
  .catch((error) => {
    // Catches errors from step1 or step2
    return defaultValue; // Chain continues
  })
  .then(step3); // Executes after catch if catch returns value
```

---

ðŸ“– **See Also:**

- [29. Handling Async Js/03. Promises.md](../../29.%20Handling%20Async%20Js/03.%20Promises.md) for comprehensive Promise documentation with async/await, examples, and advanced patterns
