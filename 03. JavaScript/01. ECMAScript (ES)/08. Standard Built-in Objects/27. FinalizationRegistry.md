# ‚úÖ Must-Know `FinalizationRegistry` Object (ES2021)

`FinalizationRegistry` allows you to register cleanup callbacks that are called when objects are garbage collected.

---

## Creating FinalizationRegistry

```js
const registry = new FinalizationRegistry((heldValue) => {
  console.log("Cleanup:", heldValue);
});

const obj = { data: "test" };
registry.register(obj, "cleanup-value");

// When obj is GC'd, cleanup callback runs with "cleanup-value"
```

---

## Registering Objects

```js
const registry = new FinalizationRegistry((heldValue) => {
  console.log("Object cleaned up:", heldValue);
});

const obj = { id: 1, data: "important" };

// Register object with held value
registry.register(obj, "obj-1");

// Unregister before GC (optional)
obj = null;
// Later: "Object cleaned up: obj-1" (when GC'd)
```

---

## Unregistering

```js
const registry = new FinalizationRegistry((value) => {
  console.log("Cleaned:", value);
});

const obj = { data: "test" };
const token = {};

// Register with token
registry.register(obj, "value-1", token);

// Unregister (prevents cleanup callback)
registry.unregister(token);
```

### With Unregister Token

```js
const registry = new FinalizationRegistry((heldValue) => {
  console.log("Cleanup:", heldValue);
});

const obj = { data: "test" };
const token = { id: "unique-token" };

// Register with token for later unregistration
registry.register(obj, "cleanup-value", token);

// Later: unregister to prevent cleanup
registry.unregister(token); // Cleanup won't run
```

---

## Common Use Cases

### 1. Resource Cleanup

```js
class FileHandle {
  constructor(filename) {
    this.filename = filename;
    this.handle = openFile(filename); // Hypothetical API

    // Register for cleanup
    FileHandle.registry.register(this, filename);
  }

  static registry = new FinalizationRegistry((filename) => {
    console.log(`Cleaning up file: ${filename}`);
    closeFile(filename); // Hypothetical cleanup
  });
}

// Usage
let file = new FileHandle("data.txt");
file = null; // Eventually: "Cleaning up file: data.txt"
```

### 2. Monitoring Object Lifecycle

```js
const registry = new FinalizationRegistry((metadata) => {
  console.log(`Object ${metadata.id} was garbage collected`);
  // Log to monitoring service
});

function createTrackedObject(id, data) {
  const obj = { id, data };
  registry.register(obj, { id, timestamp: Date.now() });
  return obj;
}
```

### 3. Cache Invalidation

```js
class WeakCacheWithCleanup {
  constructor() {
    this.cache = new Map();
    this.registry = new FinalizationRegistry((key) => {
      // Remove from cache when object is GC'd
      this.cache.delete(key);
      console.log(`Cache entry ${key} cleaned up`);
    });
  }

  set(key, value) {
    this.cache.set(key, new WeakRef(value));
    this.registry.register(value, key);
  }

  get(key) {
    const ref = this.cache.get(key);
    return ref?.deref();
  }
}
```

### 4. Database Connection Cleanup

```js
const connectionRegistry = new FinalizationRegistry((connectionId) => {
  console.log(`Cleaning up connection: ${connectionId}`);
  // Close connection, release resources
});

class DatabaseConnection {
  constructor(id) {
    this.id = id;
    this.connection = openConnection(id);
    connectionRegistry.register(this, id);
  }
}
```

---

## Important Considerations

### ‚ö†Ô∏è Unpredictable Timing

Cleanup callbacks run when GC happens, which is **non-deterministic**:

```js
const registry = new FinalizationRegistry(() => {
  console.log("Cleanup!");
});

let obj = { data: "test" };
registry.register(obj, "value");
obj = null;

// Cleanup might happen immediately, later, or never
// Don't rely on specific timing!
```

### ‚ö†Ô∏è Not for Critical Cleanup

Don't use FinalizationRegistry for:

- File handles (use try-finally or explicit close)
- Network connections (use explicit close)
- Critical resources (use explicit cleanup)

Use explicit cleanup methods instead:

```js
// ‚ùå Bad: Relying on FinalizationRegistry
class File {
  constructor(path) {
    this.path = path;
    registry.register(this, path);
  }
}

// ‚úÖ Good: Explicit cleanup
class File {
  constructor(path) {
    this.path = path;
  }

  close() {
    // Explicit cleanup
  }
}
```

### ‚ö†Ô∏è Cleanup Order Not Guaranteed

Multiple objects may be collected together, and cleanup order is not guaranteed.

### ‚úÖ Appropriate Use Cases

- Logging/monitoring
- Cache cleanup
- Non-critical resource tracking
- Statistics/metrics

---

## FinalizationRegistry Methods

| Method                                                   | Description                   |
| -------------------------------------------------------- | ----------------------------- |
| `registry.register(target, heldValue, unregisterToken?)` | Register object for cleanup   |
| `registry.unregister(unregisterToken)`                   | Unregister to prevent cleanup |

---

## Interview Common Questions

### Q: What is FinalizationRegistry?

A registry that calls cleanup callbacks when registered objects are garbage collected.

### Q: Can you rely on FinalizationRegistry for critical cleanup?

**No!** GC timing is non-deterministic. Use explicit cleanup methods (try-finally, close methods) for critical resources.

### Q: How to prevent cleanup callback from running?

Use `unregister()` with the token:

```js
const token = {};
registry.register(obj, "value", token);
registry.unregister(token); // Prevents cleanup
```

---

üìñ **See Also:**

- [22. WeakRef.md](./22.%20WeakRef.md) for weak references
- [29. Error Handling & Debugging](../../29.%20Error%20Handling%20&%20Debugging/) for proper error handling
