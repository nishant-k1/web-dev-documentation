# âœ… Must-Know `DataView` Object

`DataView` provides a flexible way to read/write different numeric types from an ArrayBuffer with explicit control over byte order.

---

## Creating DataView

```js
// From entire buffer
const buffer = new ArrayBuffer(16);
const view = new DataView(buffer);

// From buffer with offset
const view2 = new DataView(buffer, 4); // Start at byte 4

// From buffer with offset and length
const view3 = new DataView(buffer, 4, 8); // Start at 4, 8 bytes long
```

---

## Reading Values

```js
const buffer = new ArrayBuffer(16);
const view = new DataView(buffer);

// Write some values
view.setInt32(0, 0x12345678, true); // Little-endian
view.setFloat32(4, 3.14159, true);

// Read values
const int32 = view.getInt32(0, true); // 0x12345678
const float32 = view.getFloat32(4, true); // 3.14159
```

---

## Reading Methods

| Method                                | Bytes | Description             |
| ------------------------------------- | ----- | ----------------------- |
| `getInt8(offset)`                     | 1     | Signed 8-bit integer    |
| `getUint8(offset)`                    | 1     | Unsigned 8-bit integer  |
| `getInt16(offset, littleEndian?)`     | 2     | Signed 16-bit integer   |
| `getUint16(offset, littleEndian?)`    | 2     | Unsigned 16-bit integer |
| `getInt32(offset, littleEndian?)`     | 4     | Signed 32-bit integer   |
| `getUint32(offset, littleEndian?)`    | 4     | Unsigned 32-bit integer |
| `getFloat32(offset, littleEndian?)`   | 4     | 32-bit float            |
| `getFloat64(offset, littleEndian?)`   | 8     | 64-bit float            |
| `getBigInt64(offset, littleEndian?)`  | 8     | 64-bit signed BigInt    |
| `getBigUint64(offset, littleEndian?)` | 8     | 64-bit unsigned BigInt  |

---

## Writing Methods

| Method                                       | Bytes | Description             |
| -------------------------------------------- | ----- | ----------------------- |
| `setInt8(offset, value)`                     | 1     | Signed 8-bit integer    |
| `setUint8(offset, value)`                    | 1     | Unsigned 8-bit integer  |
| `setInt16(offset, value, littleEndian?)`     | 2     | Signed 16-bit integer   |
| `setUint16(offset, value, littleEndian?)`    | 2     | Unsigned 16-bit integer |
| `setInt32(offset, value, littleEndian?)`     | 4     | Signed 32-bit integer   |
| `setUint32(offset, value, littleEndian?)`    | 4     | Unsigned 32-bit integer |
| `setFloat32(offset, value, littleEndian?)`   | 4     | 32-bit float            |
| `setFloat64(offset, value, littleEndian?)`   | 8     | 64-bit float            |
| `setBigInt64(offset, value, littleEndian?)`  | 8     | 64-bit signed BigInt    |
| `setBigUint64(offset, value, littleEndian?)` | 8     | 64-bit unsigned BigInt  |

---

## Endianness Control

```js
const buffer = new ArrayBuffer(4);
const view = new DataView(buffer);

const value = 0x12345678;

// Write with little-endian (default)
view.setInt32(0, value, true);
console.log(view.getUint8(0).toString(16)); // "78" (LSB first)

// Write with big-endian
view.setInt32(0, value, false);
console.log(view.getUint8(0).toString(16)); // "12" (MSB first)
```

---

## DataView Properties

```js
const buffer = new ArrayBuffer(16);
const view = new DataView(buffer, 4, 8);

view.buffer; // ArrayBuffer (underlying buffer)
view.byteOffset; // 4 (offset in buffer)
view.byteLength; // 8 (length of view)
```

---

## Common Use Cases

### 1. Binary Protocol Implementation

```js
function parsePacket(buffer) {
  const view = new DataView(buffer);

  // Read header (little-endian)
  const packetId = view.getUint32(0, true);
  const packetLength = view.getUint16(4, true);
  const packetType = view.getUint8(6);

  // Read payload (starts at byte 7)
  const payload = new Uint8Array(buffer, 7, packetLength);

  return { packetId, packetLength, packetType, payload };
}
```

### 2. File Format Parsing

```js
async function parseImageHeader(file) {
  const buffer = await file.slice(0, 54).arrayBuffer(); // Read first 54 bytes
  const view = new DataView(buffer);

  // BMP file header
  const signature = String.fromCharCode(view.getUint8(0), view.getUint8(1));
  const fileSize = view.getUint32(2, true);
  const width = view.getInt32(18, true);
  const height = view.getInt32(22, true);

  return { signature, fileSize, width, height };
}
```

### 3. Converting Between Number Types

```js
function floatToBytes(float) {
  const buffer = new ArrayBuffer(4);
  const view = new DataView(buffer);
  view.setFloat32(0, float, true);
  return new Uint8Array(buffer);
}

function bytesToFloat(bytes) {
  const buffer = bytes.buffer;
  const view = new DataView(buffer);
  return view.getFloat32(0, true);
}

// Usage
const bytes = floatToBytes(3.14159);
const float = bytesToFloat(bytes);
console.log(float); // 3.14159
```

### 4. Network Byte Order (Big-Endian)

```js
// Network protocols often use big-endian
function createNetworkPacket(id, data) {
  const buffer = new ArrayBuffer(4 + data.length);
  const view = new DataView(buffer);

  // Write ID in big-endian (network byte order)
  view.setUint32(0, id, false);

  // Copy data
  const uint8 = new Uint8Array(buffer, 4);
  uint8.set(data);

  return buffer;
}
```

---

## DataView vs Typed Arrays

| Feature         | DataView                 | Typed Arrays             |
| --------------- | ------------------------ | ------------------------ |
| **Flexibility** | Can read/write any type  | Fixed type per array     |
| **Byte Order**  | Explicit control         | Uses platform endianness |
| **Offset**      | Specified per read/write | Fixed view of buffer     |
| **Performance** | Slightly slower          | Faster (optimized)       |
| **Use Case**    | Mixed types, protocols   | Homogeneous data, arrays |

### When to Use DataView

- Reading/writing different types at different offsets
- Need explicit control over byte order
- Parsing binary file formats
- Network protocol implementation

### When to Use Typed Arrays

- Working with homogeneous data
- Performance-critical operations
- Array-like operations (map, filter, etc.)
- Image processing, WebGL buffers

---

## Interview Common Questions

### Q: Difference between DataView and Typed Arrays?

**DataView:**

- Flexible: read/write any type at any offset
- Explicit byte order control
- Better for mixed-type binary protocols

**Typed Arrays:**

- Fixed type, array-like interface
- Faster performance
- Better for homogeneous numeric data

### Q: What is endianness?

The byte order of multi-byte numbers:

- **Little-endian**: LSB first (0x12345678 stored as 78 56 34 12)
- **Big-endian**: MSB first (0x12345678 stored as 12 34 56 78)

JavaScript/DataView can control this explicitly.

---

ðŸ“– **See Also:**

- [11. ArrayBuffer.md](./11.%20ArrayBuffer.md) for ArrayBuffer operations
- [10. Typed Arrays.md](./10.%20Typed%20Arrays.md) for typed array views
