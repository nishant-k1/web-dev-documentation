# ‚úÖ Must-Know `Reflect` Object

`Reflect` is a built-in object that provides methods for interceptable JavaScript operations. These methods correspond to Proxy handler methods. ES6 feature.

---

## Why Reflect?

- Provides methods that mirror Proxy traps
- Better error handling (returns boolean/values instead of throwing)
- More consistent API for object operations
- Works seamlessly with Proxy

---

## Reflect Methods

### `Reflect.get(target, prop, receiver?)` ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

Gets property value.

```js
const obj = { name: "John" };
Reflect.get(obj, "name"); // "John"

// Works with getters
const obj2 = {
  _value: 42,
  get value() {
    return this._value;
  },
};
Reflect.get(obj2, "value"); // 42
```

### `Reflect.set(target, prop, value, receiver?)` ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

Sets property value.

```js
const obj = {};
Reflect.set(obj, "name", "John");
obj.name; // "John"

// Returns boolean (unlike assignment)
const result = Reflect.set(obj, "age", 25); // true (success)
```

### `Reflect.has(target, prop)` ‚≠ê‚≠ê‚≠ê

Checks if property exists (like `in` operator).

```js
const obj = { name: "John" };
Reflect.has(obj, "name"); // true
Reflect.has(obj, "age"); // false
```

### `Reflect.deleteProperty(target, prop)` ‚≠ê‚≠ê‚≠ê

Deletes property (like `delete` operator).

```js
const obj = { name: "John", age: 30 };
Reflect.deleteProperty(obj, "age"); // true
obj.age; // undefined
```

### `Reflect.ownKeys(target)` ‚≠ê‚≠ê‚≠ê

Returns array of own property keys.

```js
const obj = { name: "John", age: 30 };
Reflect.ownKeys(obj); // ['name', 'age']
```

### `Reflect.defineProperty(target, prop, descriptor)` ‚≠ê‚≠ê‚≠ê

Defines property (like `Object.defineProperty()`).

```js
const obj = {};
Reflect.defineProperty(obj, "name", {
  value: "John",
  writable: false,
});
obj.name; // "John"
obj.name = "Jane"; // Error (not writable)
```

### `Reflect.getOwnPropertyDescriptor(target, prop)` ‚≠ê‚≠ê‚≠ê

Gets property descriptor.

```js
const obj = { name: "John" };
Reflect.getOwnPropertyDescriptor(obj, "name");
// { value: 'John', writable: true, enumerable: true, configurable: true }
```

### `Reflect.preventExtensions(target)` ‚≠ê‚≠ê

Prevents extensions (like `Object.preventExtensions()`).

```js
const obj = { name: "John" };
Reflect.preventExtensions(obj);
obj.age = 30; // Fails silently (or throws in strict mode)
```

### `Reflect.isExtensible(target)` ‚≠ê‚≠ê

Checks if object is extensible.

```js
const obj = { name: "John" };
Reflect.isExtensible(obj); // true
Reflect.preventExtensions(obj);
Reflect.isExtensible(obj); // false
```

### `Reflect.getPrototypeOf(target)` ‚≠ê‚≠ê

Gets prototype (like `Object.getPrototypeOf()`).

```js
const obj = {};
Reflect.getPrototypeOf(obj); // Object.prototype
```

### `Reflect.setPrototypeOf(target, proto)` ‚≠ê‚≠ê

Sets prototype (like `Object.setPrototypeOf()`).

```js
const obj = {};
const proto = { greet: () => "Hello" };
Reflect.setPrototypeOf(obj, proto);
obj.greet(); // "Hello"
```

### `Reflect.apply(func, thisArg, args)` ‚≠ê‚≠ê‚≠ê

Calls function (like `Function.prototype.apply()`).

```js
function greet(name, age) {
  return `Hello, ${name}, age ${age}`;
}

Reflect.apply(greet, null, ["John", 30]); // "Hello, John, age 30"
```

### `Reflect.construct(constructor, args, newTarget?)` ‚≠ê‚≠ê‚≠ê

Creates instance (like `new` operator).

```js
class User {
  constructor(name) {
    this.name = name;
  }
}

const user = Reflect.construct(User, ["John"]);
user.name; // "John"
```

---

## Using Reflect with Proxy

Reflect methods are designed to work with Proxy handlers:

```js
const handler = {
  get(target, prop) {
    // Custom logic
    if (prop === "secret") {
      return "Access denied";
    }
    // Use Reflect to maintain default behavior
    return Reflect.get(target, prop);
  },
  set(target, prop, value) {
    // Validation
    if (prop === "age" && value < 0) {
      return false; // Reject
    }
    // Use Reflect to maintain default behavior
    return Reflect.set(target, prop, value);
  },
};

const proxy = new Proxy({}, handler);
```

---

## Reflect vs Object Methods

| Reflect Method             | Object Method                | Difference                      |
| -------------------------- | ---------------------------- | ------------------------------- |
| `Reflect.get()`            | Direct access                | Works with getters properly     |
| `Reflect.set()`            | Assignment                   | Returns boolean                 |
| `Reflect.defineProperty()` | `Object.defineProperty()`    | Returns boolean (doesn't throw) |
| `Reflect.deleteProperty()` | `delete` operator            | Returns boolean                 |
| `Reflect.getPrototypeOf()` | `Object.getPrototypeOf()`    | Same behavior                   |
| `Reflect.setPrototypeOf()` | `Object.setPrototypeOf()`    | Returns boolean (doesn't throw) |
| `Reflect.has()`            | `in` operator                | Same behavior                   |
| `Reflect.apply()`          | `Function.prototype.apply()` | Same behavior                   |
| `Reflect.construct()`      | `new` operator               | More flexible                   |

---

## Common Use Cases

### 1. Proxy Handler Implementation

```js
const handler = {
  get(target, prop) {
    return Reflect.get(target, prop) ?? "default";
  },
  set(target, prop, value) {
    if (prop === "age" && value < 0) {
      return false; // Reject
    }
    return Reflect.set(target, prop, value);
  },
};
```

### 2. Safer Property Operations

```js
// Reflect.set returns boolean (doesn't throw)
const obj = Object.freeze({ name: "John" });
Reflect.set(obj, "age", 30); // false (silently fails)
// vs Object.defineProperty which throws

// Reflect.deleteProperty returns boolean
Reflect.deleteProperty(obj, "name"); // false (property frozen)
```

### 3. Dynamic Operations

```js
function safeSet(obj, prop, value) {
  if (Reflect.isExtensible(obj)) {
    return Reflect.set(obj, prop, value);
  }
  return false;
}
```

---

## Interview Common Questions

### Q: What is Reflect?

A built-in object providing methods for interceptable JavaScript operations. Methods correspond to Proxy traps.

### Q: Why use Reflect instead of Object methods?

- Better error handling (returns boolean instead of throwing)
- Consistent API
- Works seamlessly with Proxy
- Some operations work better with getters/setters

### Q: How does Reflect relate to Proxy?

Reflect methods correspond to Proxy traps. Use Reflect in Proxy handlers to maintain default behavior while adding custom logic.

---

üìñ **See Also:**

- [26. Proxy.md](./26.%20Proxy.md) for Proxy object
- [32. Proxy and Reflect API/](../../32.%20Proxy%20and%20Reflect%20API/) for comprehensive Proxy and Reflect documentation
