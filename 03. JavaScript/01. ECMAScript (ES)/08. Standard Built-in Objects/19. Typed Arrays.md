# âœ… Must-Know Typed Arrays

Typed Arrays provide a way to access raw binary data efficiently. They're array-like objects but work with binary data rather than JavaScript objects.

---

## Why Typed Arrays?

- **Performance**: Much faster than regular arrays for numeric operations
- **Binary Data**: Handle binary data from files, networks, WebGL, Canvas, etc.
- **Memory Efficiency**: Fixed-size, contiguous memory
- **Type Safety**: Each typed array handles a specific numeric type

---

## Typed Array Types

| Typed Array         | Size (bytes) | Range                          | Description                   |
| ------------------- | ------------ | ------------------------------ | ----------------------------- |
| `Int8Array`         | 1            | -128 to 127                    | 8-bit signed integer          |
| `Uint8Array`        | 1            | 0 to 255                       | 8-bit unsigned integer        |
| `Uint8ClampedArray` | 1            | 0 to 255                       | Clamped to 0-255 (for images) |
| `Int16Array`        | 2            | -32,768 to 32,767              | 16-bit signed integer         |
| `Uint16Array`       | 2            | 0 to 65,535                    | 16-bit unsigned integer       |
| `Int32Array`        | 4            | -2^31 to 2^31-1                | 32-bit signed integer         |
| `Uint32Array`       | 4            | 0 to 2^32-1                    | 32-bit unsigned integer       |
| `Float32Array`      | 4            | Â±3.4e38, ~7 digits precision   | 32-bit floating point         |
| `Float64Array`      | 8            | Â±1.7e308, ~15 digits precision | 64-bit floating point         |
| `BigInt64Array`     | 8            | -2^63 to 2^63-1                | 64-bit signed BigInt          |
| `BigUint64Array`    | 8            | 0 to 2^64-1                    | 64-bit unsigned BigInt        |

---

## Creating Typed Arrays

### 1. From Length

```js
// Creates array with specified length (filled with zeros)
const arr = new Int8Array(10); // 10 elements, all 0
console.log(arr.length); // 10
```

### 2. From Array/Iterable

```js
// From regular array
const arr = new Int8Array([1, 2, 3, 4, 5]);
console.log(arr); // Int8Array(5) [1, 2, 3, 4, 5]

// From another typed array
const source = new Uint8Array([1, 2, 3]);
const arr = new Int16Array(source);
console.log(arr); // Int16Array(3) [1, 2, 3]
```

### 3. From ArrayBuffer

```js
// Create buffer (16 bytes)
const buffer = new ArrayBuffer(16);

// Create typed array view of buffer
const int8View = new Int8Array(buffer); // Views all 16 bytes
const int16View = new Int16Array(buffer); // Views as 8 16-bit integers
const int32View = new Int32Array(buffer); // Views as 4 32-bit integers
```

### 4. From Buffer with Offset

```js
const buffer = new ArrayBuffer(16);
const view1 = new Int32Array(buffer, 0, 2); // Start at 0, 2 elements
const view2 = new Int32Array(buffer, 8, 2); // Start at byte 8, 2 elements
```

---

## Common Operations

### Accessing Elements

```js
const arr = new Uint8Array([10, 20, 30]);

// Access by index
console.log(arr[0]); // 10
console.log(arr[1]); // 20

// Set values
arr[0] = 100;
console.log(arr); // Uint8Array(3) [100, 20, 30]
```

### Array Methods

Typed arrays support many Array methods:

```js
const arr = new Int32Array([1, 2, 3, 4, 5]);

// map, filter, reduce, forEach, etc.
const doubled = arr.map((x) => x * 2);
console.log(doubled); // Int32Array(5) [2, 4, 6, 8, 10]

// find, findIndex
const found = arr.find((x) => x > 3); // 4

// slice (creates new typed array)
const sliced = arr.slice(1, 3); // Int32Array(2) [2, 3]

// But some methods return regular arrays
const regular = arr.filter((x) => x > 2); // Regular Array, not TypedArray
```

### Properties

```js
const arr = new Uint8Array([1, 2, 3]);

arr.length; // 3 (number of elements)
arr.byteLength; // 3 (bytes: 3 elements Ã— 1 byte each)
arr.byteOffset; // 0 (offset in underlying buffer)
arr.buffer; // ArrayBuffer (underlying buffer)
arr.BYTES_PER_ELEMENT; // 1 (bytes per element for Uint8Array)
```

---

## Uint8ClampedArray (Special Case)

Clamps values to 0-255 range (used for image data):

```js
const arr = new Uint8ClampedArray(3);

arr[0] = 300; // Clamped to 255
arr[1] = -50; // Clamped to 0
arr[2] = 100; // Stays 100

console.log(arr); // Uint8ClampedArray(3) [255, 0, 100]
```

---

## Working with ArrayBuffer

### Multiple Views of Same Buffer

```js
// Create 16-byte buffer
const buffer = new ArrayBuffer(16);

// Different views of same memory
const view8 = new Uint8Array(buffer); // 16 elements
const view16 = new Uint16Array(buffer); // 8 elements
const view32 = new Uint32Array(buffer); // 4 elements

// Modifying one view affects others
view32[0] = 0x12345678;
console.log(view8[0]); // 0x78 (little-endian)
console.log(view8[1]); // 0x56
console.log(view8[2]); // 0x34
console.log(view8[3]); // 0x12
```

### Endianness

JavaScript uses **little-endian** by default (least significant byte first).

```js
const buffer = new ArrayBuffer(4);
const view32 = new Uint32Array(buffer);
const view8 = new Uint8Array(buffer);

view32[0] = 0x12345678;

// Little-endian (LSB first)
console.log(view8[0].toString(16)); // "78"
console.log(view8[1].toString(16)); // "56"
console.log(view8[2].toString(16)); // "34"
console.log(view8[3].toString(16)); // "12"
```

---

## Common Use Cases

### 1. Image Processing

```js
// Canvas image data is Uint8ClampedArray
const canvas = document.createElement("canvas");
const ctx = canvas.getContext("2d");
const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

// imageData.data is Uint8ClampedArray
// Each pixel: [R, G, B, A, R, G, B, A, ...]
const data = imageData.data;
for (let i = 0; i < data.length; i += 4) {
  data[i] = 255 - data[i]; // Invert red channel
  data[i + 1] = 255 - data[i + 1]; // Invert green channel
  data[i + 2] = 255 - data[i + 2]; // Invert blue channel
  // Alpha channel (i + 3) unchanged
}
ctx.putImageData(imageData, 0, 0);
```

### 2. Binary Data Handling

```js
// Reading binary file
async function readBinaryFile(file) {
  const arrayBuffer = await file.arrayBuffer();
  const uint8Array = new Uint8Array(arrayBuffer);

  // Process bytes
  for (let i = 0; i < uint8Array.length; i++) {
    // Process each byte
    console.log(uint8Array[i]);
  }
}
```

### 3. WebGL Buffers

```js
// Create vertex buffer
const vertices = new Float32Array([
  0.0,
  0.0,
  0.0, // x, y, z
  1.0,
  0.0,
  0.0,
  0.5,
  1.0,
  0.0,
]);

// Create WebGL buffer
const buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
```

### 4. Network Protocols

```js
// Creating binary packet
function createPacket(id, data) {
  const buffer = new ArrayBuffer(4 + data.length);
  const view = new DataView(buffer);

  view.setUint32(0, id, true); // Little-endian
  const uint8 = new Uint8Array(buffer, 4);
  uint8.set(data);

  return buffer;
}
```

### 5. Performance-Critical Operations

```js
// Much faster than regular arrays for numeric operations
const size = 1000000;
const regular = Array(size).fill(0);
const typed = new Float32Array(size);

// Typed array operations are faster
for (let i = 0; i < size; i++) {
  typed[i] = Math.sin(i); // Faster
}
```

---

## Converting to/from Regular Arrays

```js
const typed = new Int8Array([1, 2, 3]);

// Typed array â†’ Regular array
const regular1 = Array.from(typed); // [1, 2, 3]
const regular2 = [...typed]; // [1, 2, 3]

// Regular array â†’ Typed array
const regular = [1, 2, 3, 4, 5];
const typed1 = new Int8Array(regular); // Int8Array(5) [1, 2, 3, 4, 5]
const typed2 = Int8Array.from(regular); // Same
```

---

## Limitations

### âŒ Cannot Resize

```js
const arr = new Int8Array(5);
arr.length = 10; // Error: Cannot set length property
arr.push(6); // Error: push is not a function (some engines)
```

### âŒ Some Array Methods Missing

- `push`, `pop`, `shift`, `unshift`, `splice` - Not available
- `sort` - Available but may return regular array
- `concat` - Returns regular array, not typed array

### âŒ Different Behavior

```js
const arr = new Int8Array([100, 200, 300]);

// Values are clamped/truncated
console.log(arr); // Int8Array(3) [100, -56, 44]
// 200 wraps to -56 (signed), 300 wraps to 44
```

---

## Interview Common Questions

### Q: What are Typed Arrays?

Array-like objects for efficiently handling binary data. They provide type-specific views of ArrayBuffer with fixed-size, contiguous memory.

### Q: Difference between Uint8Array and Uint8ClampedArray?

- `Uint8Array`: Values wrap around (300 becomes 44)
- `Uint8ClampedArray`: Values clamped to 0-255 (300 becomes 255)

Use `Uint8ClampedArray` for image data.

### Q: How do Typed Arrays relate to ArrayBuffer?

ArrayBuffer is raw binary data. Typed Arrays are views that interpret this data as arrays of specific types (Int8, Uint8, Float32, etc.).

### Q: Why use Typed Arrays over regular Arrays?

- **Performance**: Faster numeric operations
- **Memory**: More efficient (contiguous, fixed-size)
- **Binary Data**: Handle raw binary data from files, networks, WebGL

### Q: Can you have multiple views of the same ArrayBuffer?

Yes! Multiple typed arrays can view the same ArrayBuffer, interpreting the same bytes differently (e.g., as Int8Array or Float32Array).

---

## Quick Reference

```js
// Create
const arr = new Uint8Array(10); // 10 elements
const arr2 = new Int32Array([1, 2, 3]); // From array
const arr3 = new Float32Array(buffer, offset, length); // From buffer

// Access
arr[0] = 100;
const value = arr[0];

// Properties
arr.length; // Elements
arr.byteLength; // Bytes
arr.buffer; // Underlying ArrayBuffer

// Methods (similar to Array)
arr.map(), arr.filter(), arr.reduce(), arr.forEach(), arr.find(), arr.slice();
```

---

ðŸ“– **See Also:**

- [11. ArrayBuffer.md](./11.%20ArrayBuffer.md) for ArrayBuffer operations
- [12. DataView.md](./12.%20DataView.md) for DataView operations
- [03. Arrays.md](./03.%20Arrays.md) for regular array operations
