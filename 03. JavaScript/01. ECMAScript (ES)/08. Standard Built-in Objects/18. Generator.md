# ‚úÖ Must-Know `Generator` Object

Generator objects are returned by generator functions and implement both the **iterator** and **iterable** protocols.

---

## Creating Generator Objects

Generator objects are created by calling generator functions (functions declared with `function*`).

```js
function* generatorFunction() {
  yield 1;
  yield 2;
  yield 3;
}

const generator = generatorFunction(); // Returns Generator object
```

---

## Generator Object Methods

### `next(value?)` ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

Resumes execution and returns the next yielded value.

```js
const gen = generatorFunction();

gen.next(); // { value: 1, done: false }
gen.next(); // { value: 2, done: false }
gen.next(); // { value: 3, done: false }
gen.next(); // { value: undefined, done: true }
```

### `return(value?)` ‚≠ê‚≠ê‚≠ê

Returns the given value and finishes the generator.

```js
const gen = generatorFunction();
gen.next(); // { value: 1, done: false }
gen.return("finished"); // { value: "finished", done: true }
gen.next(); // { value: undefined, done: true } (can't resume)
```

### `throw(error)` ‚≠ê‚≠ê‚≠ê

Throws an error into the generator.

```js
function* generatorFunction() {
  try {
    yield 1;
    yield 2;
  } catch (error) {
    console.error("Caught:", error);
  }
}

const gen = generatorFunction();
gen.next(); // { value: 1, done: false }
gen.throw(new Error("Something went wrong")); // Caught: Error: Something went wrong
```

---

## Generator Properties

```js
const gen = generatorFunction();

// Generator implements iterator protocol
gen[Symbol.iterator]; // Function (generator is iterable)

// Can be used with for...of
for (const value of gen) {
  console.log(value); // 1, 2, 3
}
```

---

## Common Use Cases

### 1. Custom Iterators

```js
function* range(start, end) {
  for (let i = start; i <= end; i++) {
    yield i;
  }
}

for (const num of range(1, 5)) {
  console.log(num); // 1, 2, 3, 4, 5
}
```

### 2. Infinite Sequences

```js
function* fibonacci() {
  let [prev, curr] = [0, 1];
  while (true) {
    yield curr;
    [prev, curr] = [curr, prev + curr];
  }
}

const fib = fibonacci();
fib.next().value; // 1
fib.next().value; // 1
fib.next().value; // 2
fib.next().value; // 3
```

### 3. Lazy Evaluation

```js
function* lazyMap(array, fn) {
  for (const item of array) {
    yield fn(item);
  }
}

const numbers = [1, 2, 3, 4, 5];
const doubled = lazyMap(numbers, (x) => x * 2);

// Values computed on-demand
doubled.next().value; // 2 (computed now)
doubled.next().value; // 4 (computed now)
```

### 4. Async Generators (Advanced)

```js
async function* asyncGenerator() {
  yield await fetch("/api/data1");
  yield await fetch("/api/data2");
}

for await (const data of asyncGenerator()) {
  console.log(data);
}
```

---

## Generator as Iterator

Generator objects are iterators, so they can be used with:

```js
const gen = generatorFunction();

// for...of
for (const value of gen) {
  console.log(value);
}

// Spread operator
[...gen]; // [1, 2, 3]

// Array.from
Array.from(gen); // [1, 2, 3]

// Destructuring
const [first, second] = gen;
```

---

## Important Notes

### ‚ö†Ô∏è One-Time Use

```js
const gen = generatorFunction();

for (const value of gen) {
  console.log(value); // 1, 2, 3
}

// Generator is exhausted
for (const value of gen) {
  console.log(value); // Nothing (already done)
}
```

### ‚úÖ Can Pass Values to `next()`

```js
function* generatorFunction() {
  const x = yield 1;
  const y = yield x + 2;
  yield y + 3;
}

const gen = generatorFunction();
gen.next(); // { value: 1, done: false }
gen.next(10); // { value: 12, done: false } (x = 10)
gen.next(20); // { value: 23, done: false } (y = 20)
```

---

## Interview Common Questions

### Q: What is a Generator object?

An object returned by generator functions that implements the iterator protocol. It can be paused and resumed.

### Q: How do generators differ from regular functions?

Generators can pause execution with `yield` and resume later. Regular functions run to completion.

### Q: Can generators be used with for...of?

Yes! Generators are iterable, so they work with `for...of`, spread operator, and destructuring.

---

üìñ **See Also:**

- [25. Generators/](../../25.%20Generators/) for comprehensive generator documentation with advanced patterns and async generators
- [21. Iterators and Iterables](../../21.%20Iterators%20and%20Iterables/) for iteration protocols
