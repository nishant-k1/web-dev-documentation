# ‚úÖ Must-Know `BigInt` (Big Integer)

`BigInt` is a built-in object that provides a way to represent whole numbers larger than `Number.MAX_SAFE_INTEGER` (2^53 - 1). Introduced in ES2020.

---

## Why BigInt?

JavaScript's `Number` type uses 64-bit floating point representation, which can only safely represent integers up to `Number.MAX_SAFE_INTEGER` (9,007,199,254,740,991).

```js
// Number limitations
const maxSafe = Number.MAX_SAFE_INTEGER; // 9007199254740991
console.log(maxSafe + 1 === maxSafe + 2); // true (precision loss!)

// BigInt solves this
const bigNum = BigInt(Number.MAX_SAFE_INTEGER) + 1n;
const bigNum2 = BigInt(Number.MAX_SAFE_INTEGER) + 2n;
console.log(bigNum === bigNum2); // false (correct!)
```

---

## Creating BigInt Values

### Literal Notation ‚≠ê (Recommended)

Append `n` to the end of an integer:

```js
const big1 = 1234567890123456789012345678901234567890n;
const big2 = 42n;
const big3 = -999n;
```

### BigInt Constructor

```js
// From number
const big1 = BigInt(123); // 123n
const big2 = BigInt(Number.MAX_SAFE_INTEGER); // 9007199254740991n

// From string
const big3 = BigInt("123456789012345678901234567890"); // 123456789012345678901234567890n

// From boolean
const big4 = BigInt(true); // 1n
const big5 = BigInt(false); // 0n

// Cannot use decimals
BigInt(3.14); // TypeError: Cannot convert 3.14 to a BigInt
BigInt("3.14"); // SyntaxError: Cannot convert 3.14 to a BigInt
```

---

## BigInt Operations

### Arithmetic Operations

```js
const a = 123n;
const b = 456n;

// Addition
console.log(a + b); // 579n

// Subtraction
console.log(b - a); // 333n

// Multiplication
console.log(a * b); // 56088n

// Division (returns BigInt, truncates)
console.log(10n / 3n); // 3n (not 3.333...)

// Exponentiation
console.log(2n ** 10n); // 1024n

// Modulo
console.log(10n % 3n); // 1n

// Unary minus
console.log(-a); // -123n
```

### Comparison Operations

```js
const big = 100n;
const num = 100;

// Can compare with numbers
console.log(big > 50); // true
console.log(big < 200); // true
console.log(big == 100); // true (loose equality)
console.log(big === 100); // false (strict equality - different types)

// Cannot mix in arithmetic
big + 50; // TypeError: Cannot mix BigInt and other types
```

### Bitwise Operations

```js
const a = 0b1010n; // 10n
const b = 0b1100n; // 12n

console.log(a & b); // 8n  (AND)
console.log(a | b); // 14n (OR)
console.log(a ^ b); // 6n  (XOR)
console.log(~a); // -11n (NOT)
console.log(a << 2n); // 40n (left shift)
console.log(a >> 1n); // 5n  (right shift)
```

---

## BigInt Methods

### `BigInt()` Constructor

```js
BigInt(value); // Converts value to BigInt
```

### `BigInt.asIntN()` ‚≠ê (ES2020)

Clamps a BigInt value to a signed integer with the given number of bits.

```js
// Clamp to 64-bit signed integer
const big = 2n ** 63n + 100n; // Very large number
const clamped = BigInt.asIntN(64, big);
console.log(clamped); // -9223372036854775508n (wrapped)
```

### `BigInt.asUintN()` ‚≠ê (ES2020)

Clamps a BigInt value to an unsigned integer with the given number of bits.

```js
// Clamp to 32-bit unsigned integer
const big = 2n ** 32n + 100n; // Larger than 32 bits
const clamped = BigInt.asUintN(32, big);
console.log(clamped); // 100n (wrapped)
```

---

## Type Checking

```js
const big = 123n;

// typeof
typeof big; // "bigint"

// Constructor check
big instanceof BigInt; // false (BigInt is a primitive, not an object)

// Check if value is BigInt
function isBigInt(value) {
  return typeof value === "bigint";
}
```

---

## Conversions

### BigInt ‚Üí String

```js
const big = 12345678901234567890n;

big.toString(); // "12345678901234567890"
String(big); // "12345678901234567890"
big + ""; // "12345678901234567890" (coerced)

// With radix
big.toString(16); // "ab54a98ceb1f0ad2" (hexadecimal)
big.toString(2); // Binary representation
```

### BigInt ‚Üí Number

```js
const big = 123n;

Number(big); // 123
parseInt(big); // TypeError: Cannot convert a BigInt value to a number

// Loss of precision warning
const huge = 2n ** 60n;
Number(huge); // 1152921504606846976 (may lose precision!)
```

### Number ‚Üí BigInt

```js
BigInt(123); // 123n
BigInt(3.14); // TypeError: Cannot convert 3.14 to a BigInt
BigInt("123"); // 123n
```

### JSON Serialization

```js
const obj = { id: 123n, name: "John" };

JSON.stringify(obj); // TypeError: Do not know how to serialize a BigInt

// Custom replacer
JSON.stringify(obj, (key, value) =>
  typeof value === "bigint" ? value.toString() : value
); // '{"id":"123","name":"John"}'

// Custom reviver
const json = '{"id":"12345678901234567890","name":"John"}';
JSON.parse(json, (key, value) => (key === "id" ? BigInt(value) : value)); // { id: 12345678901234567890n, name: "John" }
```

---

## Important Limitations & Notes

### ‚ùå Cannot Mix with Numbers

```js
1n + 2; // TypeError: Cannot mix BigInt and other types
1n * 2; // TypeError
Math.max(1n, 2n); // TypeError: Cannot convert a BigInt value to a number
```

### ‚ùå No Decimals

```js
BigInt(3.14);     // TypeError
1.5n;             // SyntaxError
10n / 3n;         // 3n (truncated, not 3.333...)
```

### ‚ùå Limited JSON Support

BigInt cannot be directly serialized to JSON. Must use replacer/reviver.

### ‚ùå No Math Object Methods

```js
Math.sqrt(16n); // TypeError
Math.max(1n, 2n); // TypeError
Math.pow(2n, 10n); // TypeError
```

Use BigInt operations instead:

```js
16n ** (1n / 2n); // Approximate sqrt (returns BigInt)
2n ** 10n; // 1024n (exponentiation)
```

### ‚úÖ Can Compare with Numbers

```js
1n < 2; // true
1n == 1; // true (loose equality)
1n === 1; // false (strict equality - different types)
```

---

## Common Use Cases

### 1. Large Number Calculations

```js
// Calculating large factorials
function factorial(n) {
  if (n === 0n || n === 1n) return 1n;
  return n * factorial(n - 1n);
}

console.log(factorial(100n)); // Very large number

// Calculating Fibonacci numbers
function fibonacci(n) {
  let a = 0n,
    b = 1n;
  for (let i = 0n; i < n; i++) {
    [a, b] = [b, a + b];
  }
  return a;
}
```

### 2. IDs and Timestamps

```js
// Twitter-style snowflake IDs
const snowflakeId = 12345678901234567890n;

// Large timestamps (nanoseconds precision)
const nanoTimestamp = BigInt(Date.now()) * 1000000n;
```

### 3. Cryptography

```js
// Large prime numbers
const largePrime = 982451653n; // Or much larger

// Modular arithmetic
const result = 2n ** 1000n % largePrime;
```

### 4. Bit Manipulation

```js
// Working with 64-bit integers
const int64 = BigInt.asIntN(64, 2n ** 63n - 1n);
const uint32 = BigInt.asUintN(32, 2n ** 32n - 1n);
```

---

## Performance Considerations

- BigInt operations are generally slower than Number operations
- Use BigInt only when you need integers larger than `Number.MAX_SAFE_INTEGER`
- For most applications, regular `Number` is sufficient and faster

---

## Interview Common Questions

### Q: When would you use BigInt?

When you need to work with integers larger than `Number.MAX_SAFE_INTEGER` (2^53 - 1), such as:

- Large IDs (Twitter snowflake IDs, database IDs)
- Cryptography
- Scientific calculations
- Financial calculations requiring precision

### Q: Can BigInt and Number be mixed?

No, you cannot mix BigInt and Number in arithmetic operations. You must convert one to the other type first.

### Q: How do you convert BigInt to JSON?

Use a custom replacer function in `JSON.stringify()`:

```js
JSON.stringify(obj, (key, value) =>
  typeof value === "bigint" ? value.toString() : value
);
```

### Q: What's the difference between `Number.MAX_SAFE_INTEGER` and BigInt?

`Number.MAX_SAFE_INTEGER` is the largest integer that can be safely represented as a JavaScript Number (2^53 - 1). BigInt can represent arbitrarily large integers.

---

## Quick Reference

| Operation         | Example                 | Result           |
| ----------------- | ----------------------- | ---------------- |
| Create            | `123n` or `BigInt(123)` | `123n`           |
| Add               | `10n + 5n`              | `15n`            |
| Multiply          | `10n * 3n`              | `30n`            |
| Divide            | `10n / 3n`              | `3n` (truncated) |
| Compare           | `10n > 5`               | `true`           |
| Convert to string | `123n.toString()`       | `"123"`          |
| Convert to number | `Number(123n)`          | `123`            |
| Type check        | `typeof 123n`           | `"bigint"`       |

---

üìñ **See Also:**

- [04. Data Types/01. Primitives.md](../../04.%20Data%20Types/01.%20Primitives.md) for primitive types overview
- [06. Type Checking/01. Type Checking Guide.md](../../06.%20Type%20Checking/01.%20Type%20Checking%20Guide.md) for type checking methods

