# ‚úÖ Must-Know `Symbol` Object

`Symbol` is a primitive type that creates **unique, immutable identifiers**. ES6 feature.

---

## Creating Symbols

### Basic Symbol

```js
const sym1 = Symbol();
const sym2 = Symbol("description");
const sym3 = Symbol("description");

console.log(sym2 === sym3); // false (each Symbol is unique!)
```

### Symbol.for() - Global Registry

```js
const sym1 = Symbol.for("shared");
const sym2 = Symbol.for("shared");

console.log(sym1 === sym2); // true (same symbol from registry!)
```

### Symbol.keyFor() - Get Key

```js
const globalSym = Symbol.for("mySymbol");
Symbol.keyFor(globalSym); // "mySymbol"

const localSym = Symbol("mySymbol");
Symbol.keyFor(localSym); // undefined (not in registry)
```

---

## Symbol Characteristics

- ‚úÖ **Unique**: Each Symbol is guaranteed unique
- ‚úÖ **Immutable**: Cannot be changed
- ‚úÖ **Non-enumerable**: Don't appear in `Object.keys()`, `for...in`
- ‚úÖ **Primitive**: Symbols are primitives, not objects

---

## Common Use Cases

### 1. Unique Property Keys

```js
const id = Symbol("id");
const obj = {
  name: "John",
  [id]: 123, // Symbol as key
};

obj[id]; // 123
Object.keys(obj); // ['name'] (id not included)
```

### 2. Preventing Property Collisions

```js
// Library code
const internalId = Symbol("internal");
obj[internalId] = "secret";

// User code can't accidentally access or overwrite it
obj.internalId; // undefined
```

### 3. Well-Known Symbols

JavaScript uses symbols for meta-programming:

```js
Symbol.iterator; // Used by for...of
Symbol.toPrimitive; // Custom type conversion
Symbol.toStringTag; // Custom toString behavior
Symbol.hasInstance; // Custom instanceof
```

---

## Well-Known Symbols

### `Symbol.iterator` ‚≠ê‚≠ê‚≠ê

Used by `for...of`, spread operator.

```js
const obj = {
  [Symbol.iterator]() {
    let count = 0;
    return {
      next() {
        return count < 3 ? { value: count++, done: false } : { done: true };
      },
    };
  },
};

[...obj]; // [0, 1, 2]
```

### `Symbol.toPrimitive`

Custom type conversion.

```js
const obj = {
  [Symbol.toPrimitive](hint) {
    if (hint === "number") return 42;
    if (hint === "string") return "hello";
    return true;
  },
};

+obj; // 42
String(obj); // "hello"
```

### `Symbol.toStringTag`

Custom toString description.

```js
class MyClass {
  get [Symbol.toStringTag]() {
    return "MyCustomClass";
  }
}

Object.prototype.toString.call(new MyClass()); // "[object MyCustomClass]"
```

---

## Symbol Properties

```js
const sym = Symbol("description");

sym.description; // "description" (read-only)
typeof sym; // "symbol"
```

---

## Important Notes

### ‚úÖ Symbols Are Unique

```js
Symbol("id") === Symbol("id"); // false (always unique)
Symbol.for("id") === Symbol.for("id"); // true (from registry)
```

### ‚úÖ Symbols Are Non-Enumerable

```js
const id = Symbol("id");
const obj = { name: "John", [id]: 123 };

Object.keys(obj); // ['name']
Object.getOwnPropertySymbols(obj); // [Symbol(id)]
Reflect.ownKeys(obj); // ['name', Symbol(id)]
```

### ‚ö†Ô∏è Symbols Don't Stringify

```js
const sym = Symbol("id");
JSON.stringify({ [sym]: 123 }); // '{}' (Symbol keys omitted)
```

---

## Interview Common Questions

### Q: What is Symbol?

A primitive type that creates unique, immutable identifiers. Used for property keys and meta-programming.

### Q: Difference between `Symbol()` and `Symbol.for()`?

- `Symbol()`: Always creates new unique symbol
- `Symbol.for()`: Uses global registry, returns same symbol for same key

### Q: What are well-known symbols?

Symbols defined by JavaScript for meta-programming (iterator, toPrimitive, toStringTag, etc.).

---

üìñ **See Also:**

- [24. Symbols/](../../24.%20Symbols/) for comprehensive Symbol documentation with well-known symbols and advanced features
