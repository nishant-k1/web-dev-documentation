# Pure Functions

A function is **pure** if it satisfies two conditions:

1. **Deterministic**: Always produces the same output for the same input
2. **No side effects**: Does not modify or depend on state outside its scope

---

## Definition

A pure function:
- Takes input via parameters
- Returns output via return statement
- Does not depend on external state
- Does not modify external state
- Always returns the same output for the same input

---

## Examples

### Pure Function

```js
// Pure: Same input â†’ same output, no side effects
function add(a, b) {
  return a + b;
}

add(2, 3); // Always returns 5
```

### Impure Function

```js
let counter = 0;

// Impure: Depends on external state
function impureAdd(x) {
  counter++; // Side effect: modifies external state
  return x + counter;
}

impureAdd(5); // Returns 6
impureAdd(5); // Returns 7 (different output for same input!)
```

---

## Characteristics

### 1. Deterministic

Same input always produces same output:

```js
// Pure
const multiply = (a, b) => a * b;
multiply(2, 3); // Always 6

// Impure
const randomMultiply = (a, b) => a * b * Math.random();
randomMultiply(2, 3); // Different result each time
```

### 2. No Side Effects

Does not modify anything outside its scope:

```js
// Pure: Creates new array
function addItem(arr, item) {
  return [...arr, item];
}

// Impure: Modifies original array
function addItemImpure(arr, item) {
  arr.push(item); // Mutates external state
  return arr;
}
```

### 3. No External Dependencies

Does not depend on external state:

```js
// Pure: All inputs are parameters
function calculateTotal(items) {
  return items.reduce((sum, item) => sum + item.price, 0);
}

// Impure: Depends on global variable
let taxRate = 0.1;
function calculateTotalWithTax(items) {
  return items.reduce((sum, item) => sum + item.price, 0) * (1 + taxRate);
}
```

---

## Benefits

1. **Predictable** - Same input always gives same output
2. **Testable** - Easy to test in isolation
3. **Debuggable** - No hidden dependencies
4. **Reusable** - Can be used anywhere
5. **Cacheable** - Results can be memoized
6. **Parallelizable** - Safe for concurrent execution

---

## What Breaks Purity?

A function becomes impure if it:

- Modifies external variables
- Reads from external variables (that can change)
- Performs I/O operations (console.log, fetch, etc.)
- Uses non-deterministic sources (Math.random(), Date.now())
- Mutates parameters (if they're objects/arrays)

> ðŸ“– **For detailed information on side effects:** See [06. Side Effects.md](./06.%20Side%20Effects.md)

---

## Pure Functions in Practice

### Redux Reducers

Redux reducers must be pure functions:

```js
// Pure reducer
function counterReducer(state = { count: 0 }, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { count: state.count + 1 }; // New object
    case 'DECREMENT':
      return { count: state.count - 1 }; // New object
    default:
      return state;
  }
}
```

**Why shallow copy in Redux?**
- Performance: Deep copying is slow for large state
- Only clone what changes: `{ ...state, user: { ...state.user, name: 'New' } }`
- Other references remain unchanged

### React Components

Functional components should be pure when possible:

```js
// Pure component: Same props â†’ same output
function UserCard({ name, age }) {
  return (
    <div>
      <h2>{name}</h2>
      <p>Age: {age}</p>
    </div>
  );
}
```

---

## Can Everything Be Pure?

**No.** Programs need side effects to be useful:

- `console.log()` - Side effect (I/O)
- `fetch()` - Side effect (network)
- DOM manipulation - Side effect
- File operations - Side effect

**The Goal of FP:**
- Not to eliminate side effects completely
- But to **minimize and isolate** them
- Keep most code pure
- Isolate side effects to specific areas

**Strategy:**
- Core logic: Pure functions
- Side effects: Isolated in specific modules/functions
- When bugs occur, check side effect areas first

---

## Best Practices

### âœ… Do

- Keep functions small and focused
- Use parameters for all inputs
- Return values instead of modifying state
- Create new objects/arrays instead of mutating

### âŒ Don't

- Access global variables
- Modify parameters (especially objects/arrays)
- Perform I/O inside pure functions
- Use random/time-based values

---

## Interview Points

- Pure functions are deterministic and have no side effects
- They make code predictable, testable, and easier to reason about
- Redux reducers must be pure functions
- The goal of FP is to minimize side effects, not eliminate them
- Pure functions enable memoization and parallelization

---

> ðŸ“– **Related Topics:**
>
> - [06. Side Effects.md](./06.%20Side%20Effects.md) - Understanding what breaks purity
> - [07. Immutability.md](./07.%20Immutability.md) - Creating new data instead of mutating
> - [14. FP in React.md](./14.%20FP%20in%20React.md) - Using pure functions in React
