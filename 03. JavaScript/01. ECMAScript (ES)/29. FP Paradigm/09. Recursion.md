# Recursion

Recursion is a programming technique where a function calls itself to solve problems. In functional programming, recursion is often preferred over iterative loops for its declarative nature.

---

## What is Recursion?

A recursive function:
- Has a **base case** (stopping condition)
- Calls itself with modified parameters
- Moves toward the base case with each call

---

## Basic Example

```js
// Recursive factorial
const factorial = (n) => {
  // Base case
  if (n <= 1) return 1;
  
  // Recursive case
  return n * factorial(n - 1);
};

factorial(5); // 120
// factorial(5) = 5 * factorial(4)
// factorial(4) = 4 * factorial(3)
// factorial(3) = 3 * factorial(2)
// factorial(2) = 2 * factorial(1)
// factorial(1) = 1 (base case)
```

---

## Recursion vs Iteration

### Recursive Approach
```js
const sum = (arr) => {
  if (arr.length === 0) return 0;
  return arr[0] + sum(arr.slice(1));
};
```

### Iterative Approach
```js
const sum = (arr) => {
  let total = 0;
  for (let i = 0; i < arr.length; i++) {
    total += arr[i];
  }
  return total;
};
```

**Recursion benefits:**
- More declarative (describes what, not how)
- Natural fit for tree/graph structures
- Can be more readable for certain problems

**Iteration benefits:**
- Generally more performant
- No stack overflow risk
- Lower memory usage

---

## Tail Recursion

Tail recursion occurs when the recursive call is the last operation in the function. Some languages optimize this to avoid stack overflow.

```js
// Not tail recursive (multiplication after recursive call)
const factorial = (n) => {
  if (n <= 1) return 1;
  return n * factorial(n - 1); // ❌ Not tail recursive
};

// Tail recursive version
const factorialTail = (n, acc = 1) => {
  if (n <= 1) return acc;
  return factorialTail(n - 1, n * acc); // ✅ Tail recursive
};
```

**Note:** JavaScript doesn't have tail call optimization in most engines, so deep recursion can still cause stack overflow.

---

## Common Recursive Patterns

### 1. List Processing
```js
const map = (arr, fn) => {
  if (arr.length === 0) return [];
  return [fn(arr[0]), ...map(arr.slice(1), fn)];
};
```

### 2. Tree Traversal
```js
const countNodes = (tree) => {
  if (!tree) return 0;
  return 1 + countNodes(tree.left) + countNodes(tree.right);
};
```

### 3. Divide and Conquer
```js
const binarySearch = (arr, target, left = 0, right = arr.length - 1) => {
  if (left > right) return -1;
  
  const mid = Math.floor((left + right) / 2);
  if (arr[mid] === target) return mid;
  
  if (arr[mid] > target) {
    return binarySearch(arr, target, left, mid - 1);
  } else {
    return binarySearch(arr, target, mid + 1, right);
  }
};
```

---

## Recursion with Pure Functions

Recursion works well with pure functions for predictable, testable code:

```js
// Pure recursive function
const fibonacci = (n) => {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
};

// Same input always produces same output
fibonacci(7); // Always returns 13
```

---

## When to Use Recursion

**Use recursion when:**
- Working with tree/graph structures
- Problem naturally divides into smaller subproblems
- Code readability is more important than performance
- Problem size is guaranteed to be small

**Avoid recursion when:**
- Deep recursion is likely (use iteration)
- Performance is critical
- Stack overflow is a concern
- Problem is simple enough for iteration

---

## Best Practices

1. **Always define a base case** - Prevents infinite recursion
2. **Ensure progress toward base case** - Each call should move closer
3. **Consider stack depth** - Deep recursion can cause stack overflow
4. **Use memoization** - Cache results for expensive recursive calls
5. **Prefer tail recursion** - When possible, for potential optimization

---

## Summary

Recursion is a powerful technique in functional programming that:
- Provides declarative solutions
- Works naturally with pure functions
- Fits tree/graph problems well
- Should be used carefully to avoid stack overflow

