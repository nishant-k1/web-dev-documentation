# Components of Functional Programming

Functional Programming is built on several core components. Understanding these components is essential for mastering FP.

---

## Overview Table

| Component                  | Description                           | Example                |
| -------------------------- | ------------------------------------- | ---------------------- |
| **First-Class Functions**  | Functions treated as values           | `const fn = () => {}`  |
| **Pure Functions**         | No side effects, deterministic        | `(x) => x * 2`         |
| **Higher-Order Functions** | Functions that take/return functions  | `arr.map(fn)`          |
| **Closures**               | Functions that capture outer scope    | `() => { return x; }`  |
| **Immutability**           | Data cannot be changed after creation | `newArr = [...arr, 4]` |
| **Function Composition**   | Combining functions                   | `f(g(x))`              |
| **Currying**               | Transforming multi-arg functions      | `a => b => a + b`      |
| **Recursion**              | Functions calling themselves          | `f(n) = n * f(n-1)`    |

---

## 1. First-Class Functions

Functions are treated as first-class citizens, meaning they can be:
- Assigned to variables
- Passed as arguments
- Returned from functions
- Stored in data structures

**Example:**
```js
const greet = (name) => `Hello ${name}`;
const sayHello = greet;
sayHello("World"); // "Hello World"
```

> ðŸ“– **For details:** See [04. First-Class Functions.md](./04.%20First-Class%20Functions.md)

---

## 2. Pure Functions

Functions that:
- Always produce the same output for the same input
- Have no side effects
- Don't depend on or modify external state

**Key Property: Referential Transparency**
- An expression can be replaced with its value without changing program behavior
- Pure functions enable referential transparency

**Example:**
```js
// Pure function (referentially transparent)
const multiply = (a, b) => a * b;
multiply(2, 3); // Always returns 6
// Can be replaced with: const result = 6;

// Impure function (not referentially transparent)
let counter = 0;
const impureAdd = (x) => {
  counter++; // Side effect
  return x + counter;
};
```

> ðŸ“– **For details:** See [05. Pure Functions.md](./05.%20Pure%20Functions.md)

---

## 3. Higher-Order Functions (HOFs)

Functions that:
- Take other functions as arguments, OR
- Return functions as results, OR
- Both

**Example:**
```js
// HOF that takes a function
const map = (arr, fn) => arr.map(fn);

// HOF that returns a function
const createMultiplier = (factor) => (num) => num * factor;
const double = createMultiplier(2);
```

> ðŸ“– **For details:** See [08. Higher-Order Functions and Callbacks.md](./08.%20Higher-Order%20Functions%20and%20Callbacks.md)

---

## 4. Closures

Functions that capture and remember variables from their outer (lexical) scope, even after the outer function has returned.

**Example:**
```js
function createCounter() {
  let count = 0; // Captured by closure
  return function() {
    return ++count;
  };
}

const counter = createCounter();
counter(); // 1
counter(); // 2
```

> ðŸ“– **For details:** See [16. Execution Context, Hoisting, Scope and Closures/12. 4. Closures.md](../15.%20Execution%20Context,%20Hoisting,%20Scope%20and%20Closures/12.%204.%20Closures.md)

---

## 5. Immutability

Data structures that cannot be changed after creation. Instead of modifying existing data, new data structures are created.

**Key Principle: No Shared State**
- Avoiding shared mutable state reduces bugs
- Each function operates on its own data without affecting other parts

**Example:**
```js
// âŒ Mutation (not FP)
const arr = [1, 2, 3];
arr.push(4); // Modifies original

// âœ… Immutability (FP)
const arr = [1, 2, 3];
const newArr = [...arr, 4]; // Creates new array
```

> ðŸ“– **For details:** See [07. Immutability.md](./07.%20Immutability.md)

---

## 6. Function Composition

Combining simple functions to build more complex operations. The output of one function becomes the input of the next.

**Example:**
```js
const add1 = (x) => x + 1;
const multiply2 = (x) => x * 2;

// Composition: multiply2(add1(5))
const addThenMultiply = (x) => multiply2(add1(x));
addThenMultiply(5); // 12
```

> ðŸ“– **For details:** See [11. Function Composition.md](./11.%20Function%20Composition.md)

---

## 7. Currying

Transforming a function that takes multiple arguments into a sequence of functions, each taking a single argument.

**Example:**
```js
// Regular function
const add = (a, b, c) => a + b + c;

// Curried function
const curriedAdd = (a) => (b) => (c) => a + b + c;
curriedAdd(1)(2)(3); // 6

// Partial application
const add1 = curriedAdd(1);
const add1And2 = add1(2);
add1And2(3); // 6
```

> ðŸ“– **For details:** See [12. Currying and Partial Application.md](./12.%20Currying%20and%20Partial%20Application.md)

---

## 8. Recursion

A function calling itself to solve problems, often as an alternative to iterative loops.

**Example:**
```js
// Recursive factorial
const factorial = (n) => {
  if (n <= 1) return 1;
  return n * factorial(n - 1);
};

factorial(5); // 120
```

**Benefits:**
- More declarative than loops
- Natural fit for tree/graph structures
- Can be more readable for certain problems

**Considerations:**
- Can cause stack overflow for deep recursion
- May be less performant than iteration
- Tail call optimization can help (in some languages)

---

## How Components Work Together

These components are not isolatedâ€”they work together to create powerful FP patterns:

1. **First-Class Functions** enable **HOFs** and **Closures**
2. **Pure Functions** work with **Immutability** for predictable code
3. **HOFs** enable **Function Composition**
4. **Currying** facilitates **Function Composition**
5. **Closures** enable **Currying** and **HOFs**
6. **Recursion** works with **Pure Functions** for declarative solutions

**Example: Combining Components**

```js
// First-Class Function + HOF + Closure + Immutability
const createFilter = (predicate) => {
  return (arr) => arr.filter(predicate); // Closure captures predicate
};

// Pure Function
const isEven = (n) => n % 2 === 0;

// Composition
const filterEvens = createFilter(isEven);
const numbers = [1, 2, 3, 4, 5];
const evens = filterEvens(numbers); // [2, 4] - new array, original unchanged
```

---

## Summary

| Component | Purpose | Key Benefit |
|-----------|---------|-------------|
| **First-Class Functions** | Foundation | Functions as values |
| **Pure Functions** | Predictability | Same input â†’ same output |
| **HOFs** | Abstraction | Reusable patterns |
| **Closures** | Encapsulation | Data privacy |
| **Immutability** | Safety | No accidental mutations |
| **Function Composition** | Modularity | Build complex from simple |
| **Currying** | Flexibility | Partial application |
| **Recursion** | Declarative | Natural problem solving |

---

> ðŸ“– **Next Steps:**
>
> - Start with [03. First-Class Functions.md](./03.%20First-Class%20Functions.md) to understand the foundation
> - Then explore [04. Pure Functions.md](./04.%20Pure%20Functions.md) for core principles
> - Continue through the files in order for a complete understanding

