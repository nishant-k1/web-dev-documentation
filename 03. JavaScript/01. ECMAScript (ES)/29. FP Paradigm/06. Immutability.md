# Immutability

Immutability means that once data is created, it **cannot be changed**. Instead of modifying existing data, you create new data structures with the desired changes.

---

## What is Immutability?

**Immutable data** cannot be modified after creation. To "change" immutable data, you create a new version with the desired changes.

---

## Example: Mutation vs Immutability

### âŒ Mutation (Not Immutable)

```js
const user = { name: "John", age: 25 };
user.age = 26; // Modifies original object
console.log(user); // { name: "John", age: 26 }
```

### âœ… Immutability

```js
const user = { name: "John", age: 25 };
const updatedUser = { ...user, age: 26 }; // Creates new object
console.log(user); // { name: "John", age: 25 } (unchanged)
console.log(updatedUser); // { name: "John", age: 26 }
```

---

## JavaScript and Immutability

### Primitives are Immutable

JavaScript primitives (`string`, `number`, `boolean`, etc.) are immutable:

```js
let str = "hello";
str.toUpperCase(); // Returns new string "HELLO"
console.log(str); // "hello" (unchanged)

let num = 5;
num.toString(); // Returns new string "5"
console.log(num); // 5 (unchanged)
```

### Objects and Arrays are Mutable

JavaScript objects and arrays are mutable by default:

```js
// âŒ Mutation
const arr = [1, 2, 3];
arr.push(4); // Modifies original array
console.log(arr); // [1, 2, 3, 4]

// âœ… Immutability
const arr = [1, 2, 3];
const newArr = [...arr, 4]; // Creates new array
console.log(arr); // [1, 2, 3] (unchanged)
console.log(newArr); // [1, 2, 3, 4]
```

---

## Techniques for Immutability

### 1. Spread Operator

**Objects:**
```js
const user = { name: "John", age: 25 };
const updatedUser = { ...user, age: 26 }; // New object
```

**Arrays:**
```js
const arr = [1, 2, 3];
const newArr = [...arr, 4]; // New array
```

### 2. Array Methods (Non-Mutating)

These methods return new arrays:

```js
const arr = [1, 2, 3, 4, 5];

arr.map(x => x * 2);    // [2, 4, 6, 8, 10] - new array
arr.filter(x => x > 2); // [3, 4, 5] - new array
arr.slice(0, 2);        // [1, 2] - new array
arr.concat([6]);        // [1, 2, 3, 4, 5, 6] - new array
```

### 3. Object.assign()

```js
const user = { name: "John", age: 25 };
const updatedUser = Object.assign({}, user, { age: 26 });
```

### 4. Deep Cloning (for nested structures)

```js
// Modern approach
const deepCopy = structuredClone(obj);

// Alternative (has limitations)
const deepCopy = JSON.parse(JSON.stringify(obj));
```

---

## Benefits of Immutability

1. **Predictability** - Data doesn't change unexpectedly
2. **Debugging** - Easier to track changes and find bugs
3. **Concurrency** - Safe for parallel processing
4. **Time Travel** - Can track state history (Redux DevTools)
5. **Referential Equality** - Easier to detect changes (React optimization)

---

## Immutability in React

React relies on immutability for efficient updates:

```js
// âŒ Mutation (React won't detect change)
function updateUser(users, id, newName) {
  const user = users.find(u => u.id === id);
  user.name = newName; // Mutation
  return users;
}

// âœ… Immutability (React detects change)
function updateUser(users, id, newName) {
  return users.map(user =>
    user.id === id ? { ...user, name: newName } : user
  );
}
```

---

## Common Patterns

### Updating Nested Objects

```js
const state = {
  user: {
    name: "John",
    profile: {
      age: 25
    }
  }
};

// Update nested property immutably
const newState = {
  ...state,
  user: {
    ...state.user,
    profile: {
      ...state.user.profile,
      age: 26
    }
  }
};
```

### Adding to Arrays

```js
const items = [1, 2, 3];
const newItems = [...items, 4]; // Add to end
const newItems2 = [0, ...items]; // Add to beginning
```

### Removing from Arrays

```js
const items = [1, 2, 3, 4];
const newItems = items.filter(item => item !== 3); // Remove 3
```

### Updating Array Items

```js
const items = [{ id: 1, value: 10 }, { id: 2, value: 20 }];
const newItems = items.map(item =>
  item.id === 1 ? { ...item, value: 15 } : item
);
```

---

## Interview Points

- Immutability prevents accidental data mutations
- JavaScript primitives are immutable, but objects/arrays are mutable
- Use spread operator, `map()`, `filter()`, etc. to create new data
- Immutability is crucial for React state management and Redux
- Helps with performance optimization through referential equality checks

---

> ðŸ“– **Related Topics:**
>
> - [04. Pure Functions.md](./04.%20Pure%20Functions.md) - Pure functions work with immutable data
> - [13. FP in React.md](./13.%20FP%20in%20React.md) - Immutability in React
