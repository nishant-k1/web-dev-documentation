# Side Effects

A **side effect** occurs when a function modifies or interacts with anything outside its own local scope.

---

## What is a Side Effect?

A function has a side effect if it:
- Modifies external state (variables, objects, arrays)
- Interacts with the outside world (I/O, network, DOM)
- Depends on external state that can change
- Produces non-deterministic results

---

## Understanding "Outside Its Own Scope"

### âœ… Local Scope (Not a Side Effect)

Variables **created inside** the function:

```js
function calculate() {
  let result = 0; // Created inside function
  result = 10; // Not a side effect
  return result;
}
```

### âŒ Lexical Scope (Side Effect)

Variables the function can access via closure, but **did not create**:

```js
let counter = 0; // Created outside

function increment() {
  counter++; // Side effect: modifies external variable
}
```

### âœ… Clear Definition

A function has a side effect if it modifies **anything not created inside the function**.

---

## Types of Side Effects

### 1. Mutation-Based Side Effects

The function **changes external state**:

```js
let count = 0;
const user = { name: "John" };
const arr = [1, 2, 3];

function mutate() {
  count++;              // Side effect
  user.name = "Jane";   // Side effect
  arr.push(4);          // Side effect
  document.body.innerHTML = "Hi"; // Side effect
}
```

### 2. Interaction-Based Side Effects

The function **touches the outside world**, even without mutating:

```js
function interact() {
  console.log("Hi");        // I/O interaction
  alert("Hello");           // UI interaction
  fetch("/api");            // Network interaction
  Date.now();               // Depends on system time
  Math.random();            // Depends on external entropy
}
```

**Key Point:** Interaction alone is enough to make a function impure. Mutation is NOT required.

---

## Examples of Side Effects

### Modifying External Variables

```js
let globalVar = 10;

function impure() {
  globalVar++; // Side effect
}
```

### Mutating Parameters (Objects/Arrays)

```js
function mutateArray(arr) {
  arr.push(4); // Side effect: modifies external array
}

const myArray = [1, 2, 3];
mutateArray(myArray);
console.log(myArray); // [1, 2, 3, 4] - changed!
```

### I/O Operations

```js
function logData(data) {
  console.log(data); // Side effect: I/O
}

function writeFile(data) {
  fs.writeFileSync("file.txt", data); // Side effect: file I/O
}
```

### DOM Manipulation

```js
function updateDOM() {
  document.getElementById("app").innerHTML = "New content"; // Side effect
}
```

### Network Requests

```js
async function fetchData() {
  const response = await fetch("/api/data"); // Side effect: network
  return response.json();
}
```

### Non-Deterministic Operations

```js
function getRandom() {
  return Math.random(); // Side effect: non-deterministic
}

function getTime() {
  return Date.now(); // Side effect: depends on system time
}
```

---

## Side Effects vs Pure Functions

### Pure Function (No Side Effects)

```js
function add(a, b) {
  return a + b; // No side effects
}
```

### Impure Function (Has Side Effects)

```js
let counter = 0;

function addWithCounter(a, b) {
  counter++; // Side effect
  return a + b;
}
```

---

## Why Side Effects Matter

Side effects make functions:
- **Unpredictable** - Same input may produce different output
- **Hard to test** - Require setup/teardown
- **Hard to debug** - Hidden dependencies
- **Not reusable** - Depend on external context

---

## Managing Side Effects

### Strategy: Isolate Side Effects

**Don't eliminate side effects** (programs need them), but **isolate** them:

```js
// âœ… Good: Side effects isolated
function processData(data) {
  // Pure transformation
  return data.map(item => item * 2);
}

function saveData(data) {
  // Side effect isolated here
  localStorage.setItem("data", JSON.stringify(data));
}

// Usage
const processed = processData(rawData); // Pure
saveData(processed); // Side effect
```

### React: useEffect for Side Effects

```js
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);

  // Side effect isolated in useEffect
  useEffect(() => {
    fetch(`/api/users/${userId}`)
      .then(res => res.json())
      .then(setUser);
  }, [userId]);

  // Rest of component is pure
  return user ? <div>{user.name}</div> : <Loading />;
}
```

---

## Memory Trick

- **Mutation** = Changing the outside world
- **Interaction** = Touching the outside world
- **Both make a function impure**

---

## Interview Points

- Side effects are any interactions with or modifications of external state
- Interaction alone (without mutation) is enough to make a function impure
- Side effects include I/O, DOM manipulation, network requests, and non-deterministic operations
- The goal is to isolate side effects, not eliminate them
- Pure functions have no side effects

---

> ğŸ“– **Related Topics:**
>
> - [04. Pure Functions.md](./04.%20Pure%20Functions.md) - Functions without side effects
> - [06. Immutability.md](./06.%20Immutability.md) - Avoiding mutations
> - [13. FP in React.md](./13.%20FP%20in%20React.md) - Managing side effects in React
