# Default Binding (Global/Window Binding)

Default binding is the **fallback** when none of the other binding rules apply. It occurs when a function is called as a standalone function (not as a method, not with `new`, not with `call`/`apply`/`bind`).

---

## What is Default Binding?

When a function is invoked in the global scope (as a standalone function call), and no other binding rule applies, `this` defaults to the global object.

- **Browser:** `this` = `window`
- **Node.js:** `this` = `global`
- **Strict mode:** `this` = `undefined`

---

## Basic Example

```javascript
function showThis() {
  console.log(this);
}

showThis(); // window (browser) or global (Node.js)
```

### In Browser

```javascript
function test() {
  console.log(this === window); // true
}

test();
```

### In Node.js

```javascript
function test() {
  console.log(this === global); // true
}

test();
```

---

## Strict Mode Effect

In **strict mode**, default binding results in `undefined` instead of the global object.

```javascript
"use strict";

function showThis() {
  console.log(this); // undefined (not window/global)
}

showThis();
```

### Function-Level Strict Mode

```javascript
function strictFunction() {
  "use strict";
  console.log(this); // undefined
}

function normalFunction() {
  console.log(this); // window/global
}

strictFunction();
normalFunction();
```

### Mixed Strict and Non-Strict

```javascript
"use strict";

function outer() {
  function inner() {
    console.log(this); // undefined (inherits strict mode)
  }
  inner();
}

outer();
```

---

## When Default Binding Applies

Default binding applies when:

1. âœ… Function is called standalone (not as method)
2. âœ… Not called with `new`
3. âœ… Not called with `call()`, `apply()`, or `bind()`
4. âœ… Not an arrow function

### Example: Standalone Function Call

```javascript
function greet() {
  console.log(this); // window/global (default binding)
}

greet(); // Default binding
```

### Example: Function Assigned to Variable

```javascript
function greet() {
  console.log(this); // window/global
}

const myGreet = greet;
myGreet(); // Still default binding
```

### Example: Function Passed as Callback

```javascript
function callback() {
  console.log(this); // window/global (default binding)
}

setTimeout(callback, 1000); // Default binding
```

---

## Common Pitfalls

### Pitfall 1: Losing Context in Callbacks

```javascript
const obj = {
  name: "John",
  greet: function () {
    console.log(this.name);
  },
};

// Method invocation - this = obj
obj.greet(); // "John"

// Function invocation - this = window/undefined (default binding)
setTimeout(obj.greet, 1000); // undefined

// Solution: Use bind
setTimeout(obj.greet.bind(obj), 1000); // "John"
```

### Pitfall 2: Detached Methods

```javascript
const obj = {
  name: "John",
  method: function () {
    console.log(this.name);
  },
};

const method = obj.method; // Method is detached
method(); // undefined (default binding, not implicit)
```

### Pitfall 3: Nested Functions

```javascript
const obj = {
  name: "John",
  outer: function () {
    function inner() {
      console.log(this.name); // undefined (default binding)
    }
    inner(); // Standalone call - default binding
  },
};

obj.outer(); // undefined
```

**Solution:**

```javascript
const obj = {
  name: "John",
  outer: function () {
    const self = this; // Store reference
    function inner() {
      console.log(self.name); // "John"
    }
    inner();
  },
};

// Or use arrow function
const obj2 = {
  name: "John",
  outer: function () {
    const inner = () => {
      console.log(this.name); // "John" (lexical binding)
    };
    inner();
  },
};
```

---

## Default Binding vs Other Bindings

### Default vs Implicit

```javascript
const obj = {
  name: "John",
  method: function () {
    console.log(this.name);
  },
};

obj.method(); // "John" - Implicit binding (this = obj)

const method = obj.method;
method(); // undefined - Default binding (this = window/undefined)
```

### Default vs Explicit

```javascript
function greet() {
  console.log(this.name);
}

greet(); // undefined - Default binding

const obj = { name: "John" };
greet.call(obj); // "John" - Explicit binding (overrides default)
```

### Default vs new

```javascript
function Person(name) {
  this.name = name;
}

Person("John"); // Default binding - this = window/global
console.log(window.name); // "John" (non-strict)

const person = new Person("John"); // new binding - this = new instance
console.log(person.name); // "John"
```

---

## Global Object Access

### In Browser

```javascript
// Accessing global object
console.log(window); // Global object
console.log(this); // window (in global scope)

function test() {
  console.log(this === window); // true (default binding)
}
test();
```

### In Node.js

```javascript
// Accessing global object
console.log(global); // Global object
console.log(this); // {} (module scope, not global)

function test() {
  console.log(this === global); // true (default binding)
}
test();
```

### ES Modules

```javascript
// In ES modules, top-level this is undefined
console.log(this); // undefined

function test() {
  console.log(this); // undefined (strict mode by default)
}
test();
```

---

## Preventing Default Binding

### Method 1: Use Strict Mode

```javascript
"use strict";

function test() {
  console.log(this); // undefined (prevents global binding)
}
test();
```

### Method 2: Use Explicit Binding

```javascript
function test() {
  console.log(this);
}

test(); // window/global (default)

const obj = {};
test.call(obj); // {} (explicit, overrides default)
```

### Method 3: Use Arrow Functions (Lexical Binding)

```javascript
const obj = {
  name: "John",
  method: function () {
    const arrow = () => {
      console.log(this); // obj (lexical, not default)
    };
    arrow(); // Called standalone, but uses lexical this
  },
};

obj.method(); // { name: "John", method: [Function] }
```

---

## Real-World Examples

### Example 1: Event Handlers

```javascript
// In HTML: <button onclick="handleClick()">Click</button>
function handleClick() {
  console.log(this); // window (default binding)
}

// Better: Use addEventListener with bind
button.addEventListener("click", handleClick.bind(obj));
```

### Example 2: Array Methods

```javascript
const obj = {
  items: [1, 2, 3],
  process: function () {
    this.items.forEach(function (item) {
      console.log(this); // window/undefined (default binding in callback)
    });
  },
};

// Solution: Use arrow function or bind
obj.process = function () {
  this.items.forEach((item) => {
    console.log(this); // obj (lexical binding)
  });
};
```

### Example 3: setTimeout/setInterval

```javascript
const obj = {
  name: "John",
  delayedGreet: function () {
    setTimeout(function () {
      console.log(this.name); // undefined (default binding)
    }, 1000);
  },
};

// Solution
obj.delayedGreet = function () {
  setTimeout(() => {
    console.log(this.name); // "John" (lexical binding)
  }, 1000);
};
```

---

## Summary

### Key Points

1. **Default binding** is the fallback when no other rule applies
2. **Non-strict mode:** `this` = `window` (browser) or `global` (Node.js)
3. **Strict mode:** `this` = `undefined`
4. **Applies to:** Standalone function calls
5. **Can be overridden:** By explicit binding, `new`, or method invocation

### When to Watch Out

- âœ… Callbacks (setTimeout, forEach, etc.)
- âœ… Detached methods
- âœ… Nested functions
- âœ… Functions passed as arguments

### Solutions

- Use `bind()` to preserve context
- Use arrow functions for lexical binding
- Use strict mode to prevent accidental global binding
- Store `this` in a variable (`self`, `that`)

---

> ðŸ“– **Related Topics:**
>
> - [1. Function Invocation.md](./1.%20Function%20Invocation.md) - Function invocation types
> - [2. Understanding this Binding.md](./2.%20Understanding%20this%20Binding.md) - Overview
> - [9. this in Strict Mode.md](./9.%20this%20in%20Strict%20Mode.md) - Strict mode details
> - [13. this in Callbacks and Async.md](./12.%20this%20in%20Callbacks%20and%20Async.md) - Callbacks and default binding
