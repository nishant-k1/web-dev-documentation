# Common Interview Questions: this Binding and Function Invocation

This document covers common interview questions and tricky scenarios related to `this` binding and function invocation.

> ðŸ“– **For detailed explanations:** See the specific topic files in this folder.

---

## Basic `this` Questions

### Q1: What will this output?

```javascript
const obj = {
  name: "Object",
  method: function () {
    console.log(this.name);
  },
};

obj.method();
const method = obj.method;
method();
```

**Answer:**

- `obj.method()` â†’ `"Object"` (implicit binding)
- `method()` â†’ `undefined` (default binding, lost context)

**Explanation:**

- First call: Method invocation, `this` = `obj`
- Second call: Function invocation, `this` = `window`/`undefined`

---

### Q2: What's the difference?

```javascript
function Person(name) {
  this.name = name;
}

Person("John");
const person = new Person("John");
```

**Answer:**

- `Person("John")` â†’ Creates `window.name = "John"` (non-strict) or error (strict)
- `new Person("John")` â†’ Creates instance with `name: "John"`

**Explanation:**

- Without `new`: Default binding, `this` = `window`/`global`
- With `new`: `new` binding, `this` = new instance

---

### Q3: Arrow vs Regular Function

```javascript
const obj = {
  name: "Object",
  regular: function () {
    console.log(this.name);
  },
  arrow: () => {
    console.log(this.name);
  },
};

obj.regular();
obj.arrow();
```

**Answer:**

- `obj.regular()` â†’ `"Object"` (implicit binding)
- `obj.arrow()` â†’ `undefined` (lexical binding from global scope)

**Explanation:**

- Regular function: `this` depends on how it's called
- Arrow function: `this` depends on where it's defined

---

## Callback Questions

### Q4: What will this output?

```javascript
const obj = {
  items: [1, 2, 3],
  process: function () {
    this.items.forEach(function (item) {
      console.log(this.items);
    });
  },
};

obj.process();
```

**Answer:** `undefined` (three times)

**Explanation:**

- `forEach` callback loses context
- `this` inside callback = `window`/`undefined` (default binding)
- `this.items` is undefined

**Solution:**

```javascript
this.items.forEach((item) => {
  console.log(this.items); // Arrow function preserves this
});
```

---

### Q5: setTimeout and `this`

```javascript
const obj = {
  name: "Object",
  delayed: function () {
    setTimeout(function () {
      console.log(this.name);
    }, 1000);
  },
};

obj.delayed();
```

**Answer:** `undefined` (after 1 second)

**Explanation:**

- Callback loses context
- `this` = `window`/`undefined` in callback

**Solution:**

```javascript
setTimeout(() => {
  console.log(this.name); // Arrow function
}, 1000);
```

---

## Binding Precedence Questions

### Q6: Which binding wins?

```javascript
function Test() {
  console.log(this.name);
}

const obj1 = { name: "Object 1" };
const obj2 = { name: "Object 2" };

const bound = Test.bind(obj1);
new bound();
```

**Answer:** `undefined` (new instance, no `name` property)

**Explanation:**

- `new` binding has highest precedence
- `new` creates new instance, `bind` is ignored
- New instance has no `name` property

---

### Q7: Explicit vs Implicit

```javascript
const obj1 = {
  name: "Object 1",
  method: function () {
    return this.name;
  },
};

const obj2 = { name: "Object 2" };

obj1.method.call(obj2);
```

**Answer:** `"Object 2"`

**Explanation:**

- Explicit binding (`call`) overrides implicit binding
- `this` = `obj2` (first argument to `call`)

---

## Class Questions

### Q8: What's the output?

```javascript
class Button {
  constructor(label) {
    this.label = label;
  }

  handleClick() {
    console.log(this.label);
  }
}

const button = new Button("Submit");
const handler = button.handleClick;
handler();
```

**Answer:** `TypeError: Cannot read property 'label' of undefined`

**Explanation:**

- Method is detached from instance
- `this` = `undefined` (strict mode) or `window` (non-strict)
- Accessing `this.label` fails

**Solution:**

```javascript
// Bind in constructor
constructor(label) {
  this.label = label;
  this.handleClick = this.handleClick.bind(this);
}

// Or use arrow function class field
handleClick = () => {
  console.log(this.label);
};
```

---

### Q9: Static vs Instance Methods

```javascript
class Person {
  constructor(name) {
    this.name = name;
  }

  instanceMethod() {
    console.log(this.name);
  }

  static staticMethod() {
    console.log(this);
  }
}

const person = new Person("John");
person.instanceMethod();
Person.staticMethod();
```

**Answer:**

- `person.instanceMethod()` â†’ `"John"` (`this` = instance)
- `Person.staticMethod()` â†’ `[Function: Person]` (`this` = class)

**Explanation:**

- Instance methods: `this` = instance
- Static methods: `this` = class (if accessed)

---

## Arrow Function Questions

### Q10: Can you change `this` in arrow functions?

```javascript
const obj1 = { name: "Object 1" };
const obj2 = { name: "Object 2" };

const arrow = () => {
  console.log(this.name);
};

arrow.call(obj1);
arrow.call(obj2);
```

**Answer:** Both output `undefined` (or same value)

**Explanation:**

- Arrow functions ignore `call()`, `apply()`, `bind()`
- `this` is lexically bound and cannot be changed
- `this` comes from outer scope

---

### Q11: Nested Arrow Functions

```javascript
const obj = {
  name: "Object",
  outer: function () {
    const middle = () => {
      const inner = () => {
        console.log(this.name);
      };
      inner();
    };
    middle();
  },
};

obj.outer();
```

**Answer:** `"Object"`

**Explanation:**

- All arrow functions inherit `this` from `outer`
- `outer` is regular function, `this` = `obj`
- Nested arrows all get `this` = `obj`

---

## Event Handler Questions

### Q12: React Class Component

```javascript
class Button extends React.Component {
  constructor(props) {
    super(props);
    this.state = { clicked: false };
  }

  handleClick() {
    this.setState({ clicked: true });
  }

  render() {
    return <button onClick={this.handleClick}>Click</button>;
  }
}
```

**Problem:** `this.setState is not a function`

**Explanation:**

- `handleClick` is passed as callback
- Loses context when called by React
- `this` = `undefined` or wrong context

**Solution:**

```javascript
// Bind in constructor
this.handleClick = this.handleClick.bind(this);

// Or arrow function class field
handleClick = () => {
  this.setState({ clicked: true });
};
```

---

## Complex Scenarios

### Q13: Method Chaining

```javascript
const obj = {
  value: 0,
  add: function (num) {
    this.value += num;
    return this;
  },
  multiply: function (num) {
    this.value *= num;
    return this;
  },
};

obj.add(5).multiply(2);
console.log(obj.value);
```

**Answer:** `10`

**Explanation:**

- Each method returns `this`
- Chaining maintains implicit binding
- `this` = `obj` throughout chain

---

### Q14: Destructured Method

```javascript
const obj = {
  name: "Object",
  method: function () {
    return this.name;
  },
};

const { method } = obj;
method();
```

**Answer:** `undefined` (or error in strict mode)

**Explanation:**

- Destructuring extracts method
- Method is detached from object
- `this` = `window`/`undefined` (default binding)

**Solution:**

```javascript
const method = obj.method.bind(obj);
method(); // "Object"
```

---

### Q15: Prototype Method

```javascript
function Person(name) {
  this.name = name;
}

Person.prototype.greet = function () {
  return `Hello, I'm ${this.name}`;
};

const person = new Person("John");
const greet = person.greet;
greet();
```

**Answer:** `undefined` (or error)

**Explanation:**

- Method is detached from instance
- `this` = `window`/`undefined`
- `this.name` is undefined

**Solution:**

```javascript
const greet = person.greet.bind(person);
greet(); // "Hello, I'm John"
```

---

## Real-World Scenarios

### Q16: API Call with Class

```javascript
class ApiClient {
  constructor(apiKey) {
    this.apiKey = apiKey;
  }

  fetch(url) {
    return fetch(url, {
      headers: { Authorization: this.apiKey },
    })
      .then(function (response) {
        return response.json();
      })
      .then(function (data) {
        return this.process(data);
      });
  }

  process(data) {
    return data.map((item) => ({ ...item, processed: true }));
  }
}
```

**Problem:** `this.process is not a function`

**Explanation:**

- `this` is lost in `.then()` callbacks
- Regular functions use default binding

**Solution:**

```javascript
.then((data) => {
  return this.process(data); // Arrow function preserves this
});
```

---

### Q17: Event Delegation

```javascript
class EventManager {
  constructor(container) {
    this.container = container;
    this.container.addEventListener("click", this.handleClick);
  }

  handleClick(event) {
    if (event.target.matches(".button")) {
      this.handleButton(event.target);
    }
  }

  handleButton(button) {
    console.log("Button clicked");
  }
}
```

**Problem:** `this.handleButton is not a function`

**Explanation:**

- `handleClick` loses context when called by browser
- `this` = element or `undefined`

**Solution:**

```javascript
constructor(container) {
  this.container = container;
  this.handleClick = this.handleClick.bind(this);
  this.container.addEventListener("click", this.handleClick);
}
```

---

## Summary

### Key Concepts Tested

1. **Binding types** - Default, Implicit, Explicit, new, Lexical
2. **Precedence** - Which binding wins
3. **Context loss** - When and why `this` is lost
4. **Solutions** - bind, arrow functions, class fields
5. **Real-world patterns** - Callbacks, events, classes

### Common Patterns in Questions

- Method detachment
- Callback context loss
- Arrow vs regular functions
- Class method binding
- Event handlers
- Promise chains

---

> ðŸ“– **Related Topics:**
>
> - [2. Understanding this Binding.md](./2.%20Understanding%20this%20Binding.md) - Overview
> - [8. this Binding Precedence.md](./8.%20this%20Binding%20Precedence.md) - Precedence rules
> - [16. Common Mistakes and Best Practices.md](./16.%20Common%20Mistakes%20and%20Best%20Practices.md) - Best practices
