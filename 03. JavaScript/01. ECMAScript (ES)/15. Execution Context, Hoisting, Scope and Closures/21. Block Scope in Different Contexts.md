# Block Scope in Different Contexts

Block scope is created by `{}` blocks and affects how you can access `let` and `const` declarations. Understanding block scope in different contexts is crucial for writing correct JavaScript code.

---

## What is Block Scope?

Block scope is created whenever code is enclosed in curly braces `{}`. Variables declared with `let` and `const` inside a block are only accessible within that block.

```javascript
{
  let x = 1;
  const y = 2;
  // x and y are accessible here
}

// x and y are NOT accessible here
console.log(x); // ReferenceError
console.log(y); // ReferenceError
```

**Key Points:**

- `var` is **NOT** block-scoped (it's function-scoped)
- `let` and `const` **ARE** block-scoped
- Block scope applies to any `{}`, not just control structures

---

## 1. Block Scope in Control Structures

### if/else Statements

```javascript
if (true) {
  let x = 1;
  const y = 2;
  var z = 3; // Function-scoped, not block-scoped
}

console.log(x); // ReferenceError
console.log(y); // ReferenceError
console.log(z); // 3 (var is function-scoped)
```

### for Loops

```javascript
for (let i = 0; i < 3; i++) {
  // Each iteration has its own block scope
  let value = i * 2;
  console.log(value);
}

console.log(i); // ReferenceError
console.log(value); // ReferenceError
```

**Important:** Each iteration of a `for` loop with `let` creates a new block scope:

```javascript
var funcs = [];

for (let i = 0; i < 3; i++) {
  // Each iteration creates a new block scope with its own 'i'
  funcs.push(function () {
    console.log(i);
  });
}

funcs[0](); // 0
funcs[1](); // 1
funcs[2](); // 2
```

### while/do-while Loops

```javascript
let count = 0;
while (count < 3) {
  let local = count;
  count++;
  // local is block-scoped to this iteration
}

console.log(local); // ReferenceError
```

### switch Statements

```javascript
switch (value) {
  case 1: {
    let x = "one";
    console.log(x); // "one"
    break;
  }
  case 2: {
    let x = "two"; // Different x, different block
    console.log(x); // "two"
    break;
  }
}

console.log(x); // ReferenceError
```

**Note:** Without `{}` in switch cases, all cases share the same scope:

```javascript
switch (value) {
  case 1:
    let x = "one"; // âŒ Problem: x is in switch scope
    break;
  case 2:
    let x = "two"; // âŒ Error: x already declared
    break;
}
```

**Solution:** Use `{}` for each case:

```javascript
switch (value) {
  case 1: {
    let x = "one"; // âœ… Block-scoped
    break;
  }
  case 2: {
    let x = "two"; // âœ… Different block, different x
    break;
  }
}
```

---

## 2. Block Scope in Functions

### Regular Functions

```javascript
function test() {
  if (true) {
    let x = 1;
    const y = 2;
  }

  // x and y are NOT accessible here
  console.log(x); // ReferenceError
  console.log(y); // ReferenceError
}
```

### Arrow Functions

```javascript
const test = () => {
  if (true) {
    let x = 1;
  }
  console.log(x); // ReferenceError
};
```

### Nested Functions

```javascript
function outer() {
  let outerVar = "outer";

  if (true) {
    let blockVar = "block";

    function inner() {
      // Can access outerVar (function scope)
      console.log(outerVar); // "outer"

      // Can access blockVar (lexical scope)
      console.log(blockVar); // "block"

      // Can declare its own block-scoped variable
      if (true) {
        let innerBlock = "inner";
        console.log(innerBlock); // "inner"
      }

      // console.log(innerBlock); // ReferenceError
    }

    inner();
  }

  // console.log(blockVar); // ReferenceError
}
```

---

## 3. Block Scope in Object Methods

```javascript
const obj = {
  method() {
    if (true) {
      let x = 1;
      const y = 2;
    }

    console.log(x); // ReferenceError
    console.log(y); // ReferenceError
  },
};
```

---

## 4. Block Scope in Classes

```javascript
class MyClass {
  constructor() {
    if (true) {
      let x = 1;
      const y = 2;
    }

    console.log(x); // ReferenceError
    console.log(y); // ReferenceError
  }

  method() {
    if (true) {
      let z = 3;
    }

    console.log(z); // ReferenceError
  }
}
```

---

## 5. Block Scope in try-catch-finally

### try-catch Blocks

```javascript
try {
  let x = 1;
  throw new Error("test");
} catch (error) {
  // x is NOT accessible here (different block)
  console.log(x); // ReferenceError

  let errorInfo = error.message;
}

console.log(errorInfo); // ReferenceError
console.log(error); // ReferenceError (catch parameter is block-scoped)
```

### catch Parameter Scope

```javascript
try {
  throw new Error("test");
} catch (error) {
  // error is block-scoped to catch block
  console.log(error.message); // "test"
}

console.log(error); // ReferenceError
```

**Note:** In strict mode, `catch` parameters are block-scoped. In non-strict mode, they're function-scoped (legacy behavior).

### finally Blocks

```javascript
try {
  let x = 1;
} catch (error) {
  let y = 2;
} finally {
  // x and y are NOT accessible here
  console.log(x); // ReferenceError
  console.log(y); // ReferenceError

  let z = 3;
}

console.log(z); // ReferenceError
```

---

## 6. Block Scope in Modules

```javascript
// module.js
if (true) {
  let x = 1;
  const y = 2;
  export const z = 3; // Can export from block
}

// x and y are NOT accessible outside the block
// z is accessible via import in other modules
```

---

## 7. Nested Block Scopes

```javascript
let global = "global";

{
  let level1 = "level1";

  {
    let level2 = "level2";

    {
      let level3 = "level3";

      // Can access all outer scopes
      console.log(global); // "global"
      console.log(level1); // "level1"
      console.log(level2); // "level2"
      console.log(level3); // "level3"
    }

    // Can access level1 and level2, but not level3
    console.log(level1); // "level1"
    console.log(level2); // "level2"
    // console.log(level3); // ReferenceError
  }

  // Can only access level1
  console.log(level1); // "level1"
  // console.log(level2); // ReferenceError
  // console.log(level3); // ReferenceError
}
```

---

## 8. Block Scope with var (Function-Scoped)

**Important:** `var` is **NOT** block-scoped:

```javascript
{
  var x = 1;
  let y = 2;
}

console.log(x); // 1 (var is function-scoped)
console.log(y); // ReferenceError (let is block-scoped)
```

### Common Pitfall: var in Loops

```javascript
for (var i = 0; i < 3; i++) {
  // All iterations share the same 'i'
}

console.log(i); // 3 (var leaks out of block)

// vs

for (let i = 0; i < 3; i++) {
  // Each iteration has its own 'i'
}

console.log(i); // ReferenceError (let is block-scoped)
```

---

## 9. Block Scope in Async Contexts

### async/await

```javascript
async function test() {
  if (true) {
    let x = await Promise.resolve(1);
    const y = await Promise.resolve(2);
  }

  console.log(x); // ReferenceError
  console.log(y); // ReferenceError
}
```

### Promises

```javascript
Promise.resolve(1).then((value) => {
  if (true) {
    let x = value;
    return x;
  }
  // console.log(x); // ReferenceError
});
```

---

## 10. Block Scope in Generators

```javascript
function* generator() {
  if (true) {
    let x = 1;
    yield x;
  }

  // console.log(x); // ReferenceError
}
```

---

## 11. Block Scope with Destructuring

```javascript
const obj = { a: 1, b: 2 };

{
  let { a, b } = obj;
  console.log(a, b); // 1, 2
}

// console.log(a, b); // ReferenceError
```

---

## 12. Block Scope in Immediately Invoked Function Expressions (IIFE)

```javascript
(function () {
  if (true) {
    let x = 1;
  }

  console.log(x); // ReferenceError
})();
```

---

## Common Patterns and Best Practices

### Pattern 1: Isolating Variables in Blocks

```javascript
function processData(data) {
  // Use block to isolate temporary variables
  {
    let temp = data.map((x) => x * 2);
    let filtered = temp.filter((x) => x > 10);
    // temp and filtered are only needed here
  }

  // temp and filtered are not accessible here
  // Prevents accidental reuse or pollution
}
```

### Pattern 2: Switch Cases with Block Scope

```javascript
function getValue(type) {
  switch (type) {
    case "string": {
      let result = "text";
      return result.toUpperCase();
    }
    case "number": {
      let result = 42;
      return result * 2;
    }
    default: {
      let result = null;
      return result;
    }
  }
}
```

### Pattern 3: Loop Variables

```javascript
// âœ… Good: let in for loop
for (let i = 0; i < items.length; i++) {
  // Each iteration has its own i
}

// âŒ Bad: var in for loop
for (var i = 0; i < items.length; i++) {
  // All iterations share the same i
}
```

### Pattern 4: Temporary Calculations

```javascript
function calculateTotal(items) {
  let total = 0;

  for (const item of items) {
    // Use block for temporary calculations
    {
      let discount = item.price * 0.1;
      let finalPrice = item.price - discount;
      total += finalPrice;
    }
    // discount and finalPrice are cleaned up
  }

  return total;
}
```

---

## Block Scope vs Function Scope

| Aspect         | Block Scope (`let`/`const`)        | Function Scope (`var`)                 |
| -------------- | ---------------------------------- | -------------------------------------- |
| Scope          | Within `{}` blocks                 | Within function                        |
| Hoisting       | Hoisted but in TDZ                 | Hoisted and initialized to `undefined` |
| Re-declaration | Error in same block                | Allowed (overwrites)                   |
| Loop behavior  | Each iteration gets own variable   | All iterations share same variable     |
| Use case       | Modern JavaScript, precise control | Legacy code, function-level isolation  |

---

## Summary

### Key Takeaways

1. **Block scope** is created by any `{}` block
2. **`let` and `const`** are block-scoped
3. **`var`** is function-scoped, not block-scoped
4. **Each iteration** of a `for` loop with `let` creates a new block scope
5. **Switch cases** should use `{}` to create proper block scope
6. **Nested blocks** create nested scopes following lexical scoping rules
7. **Block scope** helps prevent variable pollution and accidental access

### When to Use Block Scope

- âœ… When you need temporary variables that shouldn't leak out
- âœ… In loops where each iteration needs its own variable
- âœ… In switch cases to avoid variable conflicts
- âœ… To isolate calculations or temporary data
- âœ… To prevent accidental variable access

### Common Mistakes to Avoid

- âŒ Using `var` in loops (causes closure issues)
- âŒ Forgetting `{}` in switch cases
- âŒ Trying to access block-scoped variables outside the block
- âŒ Assuming `var` is block-scoped
- âŒ Not understanding that each `for` loop iteration with `let` creates a new scope

---

> ðŸ“– **Related Topics:**
>
> - [1. Accessing Declarations](<./1. Accessing Declarations.md>) - Scope overview
> - [4. TDZ](<./4. TDZ.md>) - Temporal Dead Zone and block scope
> - [3. Shadowing](<./3. Shadowing.md>) - How block scope affects shadowing
