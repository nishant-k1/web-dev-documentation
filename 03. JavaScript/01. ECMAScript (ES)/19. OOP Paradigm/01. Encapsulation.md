# OOP Core Principles: Encapsulation

- Before OOP, we had procedural programming and unlike procedural programming where we just have functions modifying data with no real structure. OOP puts things in an object in a container and organizes things into units that model real world applications. This is **encapsulation**.
- We wrap code into boxes that related to one another so that these boxes can just interact with each other using the methods and properties that we make available. This makes code easier to maintain and more reusable.
- We have all these nice little class packages that we can use whenever we want.

---

## Public vs Private

### Private Class Fields and Methods

In JavaScript, you can create private fields and methods using the `#` prefix (introduced in ES2022).

```js
class BankAccount {
  // Private field
  #balance = 0;

  // Public method
  deposit(amount) {
    if (amount > 0) {
      this.#balance += amount;
    }
  }

  // Private method
  #validateAmount(amount) {
    return amount > 0;
  }

  // Public method
  getBalance() {
    return this.#balance;
  }
}

const account = new BankAccount();
account.deposit(100);
console.log(account.getBalance()); // 100
// console.log(account.#balance); // SyntaxError: Private field '#balance' must be declared in an enclosing class
```

---

## Benefits of Encapsulation

1. **Data Protection**: Prevents external code from directly accessing or modifying internal state
2. **Controlled Access**: Provides controlled access through public methods
3. **Code Organization**: Groups related data and behavior together
4. **Maintainability**: Changes to internal implementation don't affect external code
5. **Reusability**: Encapsulated units can be reused across different parts of the application

---

## Encapsulation Patterns in JavaScript

### 1. Using Closures (Factory Functions)

```js
function createCounter() {
  let count = 0; // Private variable

  return {
    increment() {
      count++;
      return count;
    },
    decrement() {
      count--;
      return count;
    },
    getCount() {
      return count;
    },
  };
}

const counter = createCounter();
counter.increment(); // 1
counter.getCount(); // 1
// count is not accessible from outside
```

### 2. Using Private Fields (ES2022)

```js
class User {
  #name;
  #email;

  constructor(name, email) {
    this.#name = name;
    this.#email = email;
  }

  getName() {
    return this.#name;
  }

  getEmail() {
    return this.#email;
  }
}
```

### 3. Using WeakMap (Pre-ES2022 Pattern)

```js
const privateData = new WeakMap();

class User {
  constructor(name) {
    privateData.set(this, { name });
  }

  getName() {
    return privateData.get(this).name;
  }
}
```

---

## Interview Points

- Encapsulation bundles data and methods that operate on that data within a single unit
- It provides data hiding and controlled access through public interfaces
- JavaScript supports encapsulation through closures, private fields (`#`), and WeakMap patterns
- Encapsulation improves code maintainability and reduces coupling between components
