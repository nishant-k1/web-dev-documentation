# Operator Coercion

This document covers **coercion specifically in the context of operators**. For comprehensive type conversion and coercion information, see [12. Type Conversion and Coercion](../11.%20Type%20Conversion%20and%20Coercion/).

---

## Overview

Operators trigger type coercion when operands are of different types. Understanding operator coercion is crucial for predicting operator behavior.

> ðŸ“– **For comprehensive type conversion and coercion:** See [12. Type Conversion and Coercion/01. Type Conversion and Coercion.md](../11.%20Type%20Conversion%20and%20Coercion/01.%20Type%20Conversion%20and%20Coercion.md)

---

## Key Principles

1. **Arithmetic operators** (`-`, `*`, `/`, `%`) coerce operands to **numbers**
2. **`+` operator** has special behavior:
   - If either operand is a string â†’ **string concatenation** (coerces to string)
   - Otherwise â†’ **number addition** (coerces to number)
3. **`==` operator** performs coercion before comparison
4. **`===` operator** does **not** perform coercion (strict equality)
5. **Objects** are converted to primitives via `ToPrimitive` (Symbol.toPrimitive, valueOf(), toString()) before operator coercion
6. **`undefined`, `null`, and `symbol`** have special behaviors

---

## Arithmetic Operators

### Number Coercion

Arithmetic operators (except `+` with strings) coerce operands to numbers:

```javascript
"5" - 2; // 3 (string coerced to number)
"5" * 2; // 10 (string coerced to number)
"5" / 2; // 2.5 (string coerced to number)
"5" % 2; // 1 (string coerced to number)
```

### String Coercion with `+`

The `+` operator prefers string concatenation if either operand is a string:

```javascript
5 + "5"; // "55" (number coerced to string)
"5" + 5; // "55" (number coerced to string)
5 + 5; // 10 (both numbers, addition)
```

---

## Comparison Operators

### Loose Equality (`==`)

Performs coercion before comparison:

```javascript
"123" == 123; // true (string coerced to number)
true == 1; // true (boolean coerced to number)
false == 0; // true (boolean coerced to number)
null == undefined; // true (special case, not coercion)
```

### Strict Equality (`===`)

Does **not** perform coercion:

```javascript
"123" === 123; // false (different types)
true === 1; // false (different types)
false === 0; // false (different types)
```

---

## Unary Operators

### Unary Plus (`+`)

Converts operand to number:

```javascript
+"123"; // 123
+true; // 1
+false; // 0
+null; // 0
+undefined; // NaN
+[]; // 0 (empty array â†’ "" â†’ 0)
+[1, 2]; // NaN
+{}; // NaN
```

### Unary Negation (`-`)

Converts operand to number and negates:

```javascript
-"5"; // -5
-true; // -1
-false; // -0
-null; // -0
-undefined; // NaN
```

### Logical NOT (`!`)

Converts operand to boolean and negates:

```javascript
!true; // false
!false; // true
!0; // true
!1; // false
!""; // true
!"hello"; // false
!null; // true
!undefined; // true
!{}; // false
![]; // false
```

---

## Logical Operators

### AND (`&&`) and OR (`||`)

Return values based on truthiness, not just booleans:

```javascript
0 || "Hello"; // "Hello" (0 is falsy, returns second)
5 && "Hello"; // "Hello" (5 is truthy, returns second)
null || "default"; // "default"
```

### Nullish Coalescing (`??`)

Only checks `null` and `undefined` (not other falsy values):

```javascript
0 ?? "default"; // 0 (0 is not null/undefined)
"" ?? "default"; // "" (empty string is not null/undefined)
null ?? "default"; // "default"
undefined ?? "default"; // "default"
```

---

## Bitwise Operators

Convert operands to **32-bit integers**:

```javascript
"5" | 2; // 7 (both coerced to 32-bit integers)
"5" & 2; // 0
"5" ^ 2; // 7
~"5"; // -6
```

---

## Object to Primitive Coercion

Objects are converted to primitives before operator coercion:

```javascript
let obj = { name: "John" };
obj + ""; // "[object Object]" (toString() called)

let arr = [1, 2, 3];
arr + ""; // "1,2,3" (toString() called)

let custom = {
  valueOf() {
    return 10;
  },
};
custom + 5; // 15 (valueOf() called, then addition)
```

**Conversion order:**

1. `Symbol.toPrimitive` (if exists)
2. `valueOf()` (if exists and returns primitive)
3. `toString()` (fallback)

---

## Special Cases

### `null` and `undefined`

```javascript
null == undefined; // true (special case, not coercion)
null === undefined; // false (different types)
null == 0; // false (null doesn't coerce to 0 in ==)
undefined == 0; // false
```

### `NaN`

```javascript
NaN == NaN; // false (NaN never equals anything, including itself)
NaN === NaN; // false
```

### Order of Operands

Order doesn't affect coercion:

```javascript
5 == "5"; // true
"5" == 5; // true (same result)
```

---

## Key Takeaways

1. **Arithmetic operators** (except `+` for strings) convert to numbers
2. **`+` with a string** converts to string (concatenation)
3. **`==` compares after coercion**, **`===` does not**
4. **Logical operators** return values, not just booleans
5. **Bitwise operators** convert to 32-bit integers
6. **Nullish coalescing (`??`)** only checks `null` and `undefined`

---

## Related Topics

- [12. Type Conversion and Coercion/](../11.%20Type%20Conversion%20and%20Coercion/) - Comprehensive type conversion guide
- [1. Operators.md](./1.%20Operators.md) - All operators overview
- [2. Operators Precedence.md](./2.%20Operators%20Precedence.md) - Operator precedence
