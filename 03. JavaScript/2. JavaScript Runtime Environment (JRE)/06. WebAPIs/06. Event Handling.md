# Event Handling

## DOM Levels Overview

- **DOM Level 0**: Inline HTML attributes and direct assignment (`element.onclick = fn`).
- **DOM Level 1**: Focused on core DOM APIs; did not introduce event handling.
- **DOM Level 2**: Introduced `addEventListener`, `removeEventListener`, and event propagation (bubbling/capturing).
- **DOM Level 3**: Added advanced features like `capture`, `once`, `passive` options, and `CustomEvent`.

**Every event handler like `onclick`, `onchange`, `oninput`, etc., is a property of DOM elements (specifically, properties of the `HTMLElement` or other relevant interfaces like `HTMLInputElement`, etc.).**

## Event Handling: Main Three Ways

| Event Handling           | Type      | Overwrites? | Supports Multiple? | Recommended        |
| ------------------------ | --------- | ----------- | ------------------ | ------------------ |
| Inline (`onclick="..."`) | Attribute | N/A         | ❌ No              | ❌ Not Recommended |
| `element.onclick = fn`   | Property  | ✅ Yes      | ❌ No              | Basic Use          |
| `addEventListener(...)`  | Method    | ❌ No       | ✅ Yes             | ✅ Best Practice   |

### 1. Inline Event Handlers (DOM Level 0)

Inline event handlers are written directly in HTML tags using attributes like `onclick`, `onmouseover`, etc.

```js
<button onclick="alert('Clicked!')">Click me</button>
```

**Drawbacks**:

- Mixing HTML with JavaScript (poor separation of concerns).
- No support for multiple handlers.
- Harder to debug and maintain.

### 2. Traditional Event Handling (DOM Level 0) (Direct Assignment)

Events are assigned directly to DOM elements using properties like `onclick`, `onmouseover`, etc.

const button = document.querySelector('button');
button.onclick = () => alert('Clicked!');

**Drawbacks**:

- Overwrites any existing handler on the same property.
- No support for multiple handlers on the same event.

### 3. Modern Event Handling (DOM Level 2 and 3) (`addEventListener`)

`addEventListener` allows attaching multiple event listeners to a single element without overwriting previous ones.

const button = document.querySelector('button');
button.addEventListener('click', () => alert('Clicked!'));

**Advantages**:

- Supports multiple listeners for the same event.
- Provides options like `capture`, `once`, and `passive`.

---

## Core Event Handling Concepts

### 1. Event Listeners

#### 1.1 Adding Event Listeners (`addEventListener`)

const button = document.querySelector('button');
button.addEventListener('click', () => console.log('Clicked!'));

#### 1.2 Removing Event Listeners (`removeEventListener`)

function handleClick() { console.log('Clicked!'); }
button.addEventListener('click', handleClick);
button.removeEventListener('click', handleClick); // Must use the same function reference

**Note**: Anonymous functions cannot be removed easily.

### 2. Event Object

#### 2.1 Properties of the Event Object

button.addEventListener('click', (event) => {
console.log(event.target); // The element that triggered the event
console.log(event.type); // "click"
console.log(event.currentTarget); // The element the listener is attached to
});

#### 2.2 Common Event Types

- `click`, `mouseover`, `keydown`, `submit`, `change`, etc.

### 3. Event Phases

#### 3.1 Capture Phase

From the root (`window`) to the target element.

#### 3.2 Target Phase

At the target element itself.

#### 3.3 Bubble Phase

From the target element back to the root.

### 4. Event Propagation (Bubbling, Capturing, Stopping Propagation)

Events propagate in three phases (as above). You can control the phase using the `capture` option.

#### 4.1 Capturing Phase

const button = document.querySelector('button');
const parent = button.parentElement;
parent.addEventListener('click', () => console.log('Parent (capturing)'), { capture: true });
button.addEventListener('click', () => console.log('Button'));

#### 4.2 Bubbling Phase (Default)

parent.addEventListener('click', () => console.log('Parent (bubbling)'), { capture: false });

#### 4.3 Stopping Propagation

button.addEventListener('click', (event) => {
event.stopPropagation(); // Prevents the event from reaching the parent
console.log('Stopped propagation');
});

### 5. Default Actions

#### 5.1 Preventing Default Behavior (`event.preventDefault`)

const form = document.querySelector('form');
form.addEventListener('submit', (event) => {
event.preventDefault();
console.log('Form submission prevented');
});

#### 5.2 Examples

- Prevent form submission (above).
- Prevent link navigation:
  const link = document.querySelector('a');
  link.addEventListener('click', (event) => {
  event.preventDefault();
  console.log('Link navigation prevented');
  });

---

## Advanced Event Handling Features

### 1. Event Handler Attributes (DOM Level 0)

Similar to inline handlers but set using JavaScript.

button.onclick = function() { alert('Clicked!'); };

**Note**: Same drawbacks as direct assignment (overwrites, no multiple handlers).

### 2. Anonymous Functions as Event Handlers

Used for simple, one-time events.

button.addEventListener('click', () => console.log('Anonymous handler'));

**Drawback**: Cannot remove anonymous handlers using `removeEventListener`.

### 3. Event Handling Using `capture` Option

Executes the handler during the capturing phase.

button.addEventListener('click', () => console.log('Capturing phase'), { capture: true });

### 4. Event Handling Using `once` Option

Ensures the event handler is executed only once.

button.addEventListener('click', () => console.log('Runs once'), { once: true });

### 5. Custom Events (Using `CustomEvent`)

Create and dispatch custom events.

const myEvent = new CustomEvent('myCustomEvent', { detail: { message: 'Hello!' } });
document.dispatchEvent(myEvent);
document.addEventListener('myCustomEvent', (e) => console.log(e.detail.message));

### 6. `this` Inside Event Handlers

#### 6.1 Using Direct Assignment

button.onclick = function() { console.log(this); }; // `this` refers to the element (button)

#### 6.2 Using `addEventListener`

button.addEventListener('click', function() { console.log(this); }); // `this` refers to the element
button.addEventListener('click', () => console.log(this)); // `this` refers to lexical scope (e.g., `undefined` in strict mode)

### 7. Pointer vs Mouse vs Touch Events

#### 7.1 Modern Event Types

- **Pointer Events**: Unified for mouse, touch, and stylus (`pointerdown`, `pointermove`, `pointerup`).
  button.addEventListener('pointerdown', () => console.log('Pointer down'));
- **Touch Events**: For mobile (`touchstart`, `touchmove`, `touchend`).
  button.addEventListener('touchstart', () => console.log('Touch start'));
- **Mouse Events**: Mouse-specific (`mousedown`, `mousemove`, `mouseup`).
  button.addEventListener('mousedown', () => console.log('Mouse down'));

---

## Practical Considerations

### 1. Cross-Browser Compatibility

Handle older browsers (e.g., IE8) with fallbacks.

function addEvent(element, event, handler) {
if (element.addEventListener) {
element.addEventListener(event, handler, false);
} else if (element.attachEvent) {
element.attachEvent('on' + event, handler);
}
}

### 2. Error Handling in Event Listeners

Handle errors to prevent breaking the application.

button.addEventListener('click', () => {
try {
throw new Error('Oops!');
} catch (e) {
console.error('Error in event handler:', e);
}
});

### 3. Memory Leaks and Cleanup

#### 3.1 Memory Leaks

- Add event listeners during `mount`.
- Always remove them during `unmount` (especially in SPA frameworks like React).
- Watch for closures capturing large contexts.

const button = document.querySelector('button');
const handler = () => console.log('Click');
button.addEventListener('click', handler);
// Cleanup on unmount
button.removeEventListener('click', handler);

---

## Framework-Specific Event Handling

### 1. Synthetic Events in Frameworks (React)

#### 1.1 Synthetic Events in React

React wraps native events in a synthetic event system for performance and compatibility.

- React automatically manages event pooling and cleanup.
- Use `onClick={handleClick}` instead of `addEventListener`.

function MyComponent() {
const handleClick = () => console.log('Clicked in React');
return <button onClick={handleClick}>Click me</button>;
}

---

# Moved to Performance Optimization

The following topics have been moved to the "Performance Optimization" section in the JavaScript folder structure, as they focus on optimizing event handling rather than core mechanics:

## 1. Event Delegation

Event delegation leverages event bubbling to handle events for multiple child elements through a single parent.

const list = document.querySelector('ul');
list.addEventListener('click', (event) => {
if (event.target.tagName === 'LI') {
console.log('List item clicked:', event.target.textContent);
}
});

## 2. Event Handling Using `passive` Option

Improves performance by indicating the event listener will not call `preventDefault`.

window.addEventListener('scroll', () => console.log('Scrolling'), { passive: true });

## 3. Debouncing and Throttling

Use `debounce` or `throttle` for events like `scroll`, `resize`, `input`, and `mousemove` to avoid performance issues.

Example using a simple throttle function:
function throttle(fn, delay) {
let lastCall = 0;
return (...args) => {
const now = Date.now();
if (now - lastCall >= delay) {
lastCall = now;
return fn(...args);
}
};
}
window.addEventListener('resize', throttle(() => console.log('Resized'), 200));

Alternatively, using Lodash:
window.addEventListener('resize', \_.throttle(() => console.log('Resized'), 200));

