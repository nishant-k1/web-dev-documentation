# JavaScript Runtime Environment (JRE)

## What is a JavaScript Runtime Environment?

A **JavaScript Runtime Environment** is the complete environment in which JavaScript code executes. It consists of the JavaScript engine and additional components that enable JavaScript to interact with its host environment (browser or Node.js).

JavaScript is a single-threaded programming language with only one call stack and one heap. This means only one piece of code can execute at a time. However, the runtime environment enables JavaScript to handle asynchronous operations without blocking the main thread, solving the problem of long-running tasks.

### Quick execution order (browser / Node)

- Call Stack (sync) runs first.
- When the stack is empty, run **all** microtasks (Promises, queueMicrotask, Mutation/Intersection/ResizeObservers; plus process.nextTick in Node).
- Then run **one** macrotask (timers, I/O, user events, setImmediate in Node).
- Repeat: stack → all microtasks → one macrotask.

## Browser Runtime Environment (BRE)

The Browser Runtime Environment allows JavaScript to run in web browsers and interact with web pages.

### Components:

1. **JavaScript Engine**

   - Call Stack (holds Execution Contexts)
   - Memory Heap
   - Parser
   - Interpreter
   - Just-In-Time Compiler (JIT)
   - Garbage Collector

2. **Web APIs** (Browser-specific APIs)

   - DOM manipulation
   - Fetch API
   - Timers (setTimeout, setInterval)
   - Event Listeners
   - LocalStorage, SessionStorage
   - Console API

3. **Task Queues**

   - Microtask Queue (high priority)
   - Macrotask Queue (low priority)

4. **Event Loop**

   - Coordinates execution between the call stack and task queues

5. **Rendering Engine**

   - Handles page rendering and painting

6. **Additional Components**
   - User Interface (UI) Thread
   - Networking Layer
   - Storage Layer
   - Browser Plugins and Extensions

## Node.js Runtime Environment (NRE)

Node.js is a JavaScript runtime built on the V8 engine using C++.

### Key Characteristics:

- Built as a C++ executable program (node.exe)
- Uses **libuv** library for asynchronous I/O operations
- Server-side platform with non-blocking asynchronous I/O
- Can access the file system and perform operations not available in browsers
- Uses **global** object instead of **window** object
- Has Node.js-specific APIs instead of Web APIs

### Similar to Browser Runtime:

- JavaScript Engine (V8)
- Event Loop
- Microtask Queue
- Macrotask Queue
- Single-threaded execution model with asynchronous capabilities

### Differences from Browser:

- No DOM or window object
- File system access
- Process management
- Operating system interactions
- Different set of APIs (Node.js APIs vs Web APIs)

## How the Runtime Works

### Single-Threaded Execution

- JavaScript has **one call stack** and executes code synchronously
- Only one operation can execute at a time on the call stack
- The call stack operates on **LIFO** (Last In, First Out) principle

### Asynchronous Operation Handling

1. **Synchronous code** executes directly on the call stack
2. **Asynchronous operations** (setTimeout, fetch, etc.) are handed off to:
   - **Web APIs** (in browsers)
   - **libuv** (in Node.js)
3. When the async operation completes, its callback is placed in the appropriate queue:
   - **Microtask Queue** for Promises, queueMicrotask
   - **Macrotask Queue** for setTimeout, setInterval, I/O operations
4. The **Event Loop** monitors the call stack and queues:
   - When the call stack is empty, it first processes all microtasks
   - Then it processes one macrotask
   - Then it checks for microtasks again
   - This cycle continues

### Priority Order

1. **Call Stack** (currently executing code)
2. **Microtask Queue** (Promises, queueMicrotask)
3. **Macrotask Queue** (setTimeout, setInterval, I/O)

## Web APIs vs language

- Web APIs (or Node/libuv APIs) are **not** part of the ECMAScript language; they are host-provided capabilities.
- Examples: DOM/BOM, fetch/XMLHttpRequest, timers, storage, workers, canvas, audio/video, File/Blob, streams, IndexedDB.
- JavaScript calls into these APIs; when work completes, callbacks return via the queues and the event loop schedules them on the call stack.

## Visual Representation

![JavaScript Runtime Environment](js-event-loop-explained.png)

## Key Concepts

- **Single-threaded**: JavaScript can only execute one piece of code at a time
- **Non-blocking**: Asynchronous operations don't block the main thread
- **Event-driven**: The runtime responds to events and executes callbacks
- **Concurrent but not parallel**: Multiple tasks are managed concurrently, but not executed simultaneously

## Related Topics

- [JavaScript Engine](04.%20Javascript%20Engine.md)
- [Call Stack](09.%20Call%20Stack.md)
- [Event Loop + queues](12.%20Event%20Loop.md)
- [Web APIs overview (BOM/DOM/events/storage)](<06.%20WebAPIs/01.%20BOM%20(window)%20-%20Browser%20Object%20Model.md>)
