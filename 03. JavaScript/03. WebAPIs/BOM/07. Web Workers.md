# ‚úÖ Must-Know `Web Workers` ‚≠ê‚≠ê‚≠ê‚≠ê

**Web Workers** allow JavaScript to run scripts in background threads, enabling concurrent execution without blocking the main UI thread. **Critical for performance optimization!**

---

## What Are Web Workers?

Web Workers run JavaScript code **in a separate thread** from the main thread, allowing:

- CPU-intensive tasks without blocking the UI
- Parallel processing
- Background computations

**Key Point:** Workers run in a **completely separate JavaScript environment** with no access to the DOM or many Web APIs.

---

## Creating a Web Worker

### Basic Setup

**main.js (Main Thread):**

```js
// Create a worker
const worker = new Worker("worker.js");

// Send message to worker
worker.postMessage({ type: "CALCULATE", data: [1, 2, 3, 4, 5] });

// Receive message from worker
worker.onmessage = (event) => {
  console.log("Result:", event.data);
};

// Handle errors
worker.onerror = (error) => {
  console.error("Worker error:", error);
};
```

**worker.js (Worker Thread):**

```js
// Listen for messages from main thread
self.onmessage = (event) => {
  const { type, data } = event.data;

  if (type === "CALCULATE") {
    // Heavy computation
    const result = data.reduce((sum, num) => sum + num * 2, 0);

    // Send result back to main thread
    self.postMessage({ result });
  }
};
```

---

## Worker Communication

### Main Thread ‚Üí Worker

```js
const worker = new Worker("worker.js");

// Send data
worker.postMessage({ message: "Hello Worker" });
worker.postMessage([1, 2, 3, 4, 5]);
worker.postMessage("Simple string");

// Data is cloned (structured clone algorithm)
// Can send: Objects, Arrays, Strings, Numbers, etc.
// Cannot send: Functions, DOM nodes, some objects
```

### Worker ‚Üí Main Thread

```js
// In worker.js
self.postMessage({ result: 42 });
self.postMessage("Done processing");
```

### Receiving Messages

**Main Thread:**

```js
worker.onmessage = (event) => {
  console.log("Received:", event.data);
};

// Or using addEventListener
worker.addEventListener("message", (event) => {
  console.log("Received:", event.data);
});
```

**Worker Thread:**

```js
self.onmessage = (event) => {
  console.log("Worker received:", event.data);
};
```

---

## Terminating Workers

### Terminate from Main Thread

```js
const worker = new Worker("worker.js");

// Terminate worker
worker.terminate();

// Worker stops immediately
// Cannot restart - need to create new worker
```

### Self-Terminate from Worker

```js
// In worker.js
self.close(); // Worker terminates itself
```

---

## Worker Types

### 1. Dedicated Workers

Standard Web Worker (one-to-one relationship with main thread).

```js
const worker = new Worker("worker.js");
```

### 2. Shared Workers

Can be accessed by multiple scripts/windows (same origin).

```js
const worker = new SharedWorker("shared-worker.js");

// Access via port
worker.port.onmessage = (event) => {
  console.log(event.data);
};

worker.port.postMessage("Hello");
```

### 3. Service Workers

For background tasks, push notifications, offline functionality (separate topic).

---

## What Workers CAN Access

‚úÖ **Available in Workers:**

- `self` (global scope)
- `postMessage()`, `onmessage`, `onerror`
- `importScripts()` - Load additional scripts
- `setTimeout()`, `setInterval()`, `clearTimeout()`, `clearInterval()`
- `XMLHttpRequest` / `fetch()` - Network requests
- `WebSockets`
- `IndexedDB` (with limitations)
- `WebAssembly`

---

## What Workers CANNOT Access

‚ùå **Not Available in Workers:**

- **DOM** - Cannot access `document`, `window`, `element`
- **Parent objects** - No access to parent page's objects
- **Some Web APIs** - No `localStorage`, `sessionStorage`
- **Direct UI manipulation** - Cannot update DOM directly

**Workaround:** Send messages to main thread, main thread updates DOM.

---

## Common Patterns

### 1. CPU-Intensive Calculations

**main.js:**

```js
const worker = new Worker("calculator.js");

function calculateLargeSum(numbers) {
  worker.postMessage({ numbers });
}

worker.onmessage = (event) => {
  document.getElementById("result").textContent = event.data.sum;
};

calculateLargeSum([...Array(1000000).keys()]);
```

**calculator.js:**

```js
self.onmessage = (event) => {
  const { numbers } = event.data;
  const sum = numbers.reduce((acc, num) => acc + num, 0);
  self.postMessage({ sum });
};
```

### 2. Image Processing

**main.js:**

```js
const worker = new Worker("image-processor.js");
const canvas = document.querySelector("canvas");
const ctx = canvas.getContext("2d");

// Send image data
const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
worker.postMessage({ imageData });

// Receive processed data
worker.onmessage = (event) => {
  ctx.putImageData(event.data.processedImageData, 0, 0);
};
```

**image-processor.js:**

```js
self.onmessage = (event) => {
  const { imageData } = event.data;
  // Process pixels (blur, filter, etc.)
  const processed = processImage(imageData);
  self.postMessage({ processedImageData: processed });
};
```

### 3. Data Fetching and Processing

```js
// In worker
self.onmessage = async (event) => {
  const { url } = event.data;

  // Fetch data
  const response = await fetch(url);
  const data = await response.json();

  // Process large dataset
  const processed = processLargeDataset(data);

  // Send result
  self.postMessage({ result: processed });
};
```

### 4. Periodic Background Tasks

```js
// In worker
let intervalId;

self.onmessage = (event) => {
  if (event.data === "start") {
    intervalId = setInterval(() => {
      // Do background work
      self.postMessage({ status: "working" });
    }, 1000);
  } else if (event.data === "stop") {
    clearInterval(intervalId);
  }
};
```

---

## Error Handling

### Main Thread

```js
const worker = new Worker("worker.js");

worker.onerror = (error) => {
  console.error("Worker error:", error.message);
  console.error("Filename:", error.filename);
  console.error("Line:", error.lineno);
};

// Or with addEventListener
worker.addEventListener("error", (error) => {
  console.error("Worker error:", error);
});
```

### Worker Thread

```js
// In worker.js
self.onerror = (error) => {
  console.error("Error in worker:", error);
  return true; // Prevents default error handling
};

// Try-catch in worker
try {
  // Code that might throw
} catch (error) {
  self.postMessage({ error: error.message });
}
```

---

## Importing Scripts in Workers

Use `importScripts()` to load additional scripts in a worker.

```js
// In worker.js
importScripts("helper.js", "utils.js");

// Now helper.js and utils.js are available
someHelperFunction();
```

**Note:** `importScripts()` is **synchronous** - blocks until scripts load.

---

## Interview Common Questions

### Q: What are Web Workers and why use them?

Web Workers run JavaScript in background threads, allowing CPU-intensive tasks without blocking the main UI thread. Use them for:

- Heavy calculations
- Image/video processing
- Large data processing
- Background tasks

### Q: Can Web Workers access the DOM?

**No!** Workers cannot access:

- DOM (document, window, elements)
- Parent page's JavaScript objects
- Some Web APIs (localStorage, etc.)

To update DOM: send message from worker ‚Üí main thread ‚Üí update DOM.

### Q: How do Web Workers communicate?

Using `postMessage()` and `onmessage`:

```js
// Main ‚Üí Worker
worker.postMessage(data);

// Worker ‚Üí Main
worker.onmessage = (event) => {
  console.log(event.data);
};
```

Data is cloned using the **structured clone algorithm**.

### Q: What can you send to/from a Worker?

**Can send:**

- Objects, Arrays, Strings, Numbers, Dates, etc.
- Typed Arrays (ArrayBuffer, etc.)

**Cannot send:**

- Functions
- DOM nodes
- Some special objects

### Q: How to terminate a Web Worker?

```js
// From main thread
worker.terminate();

// From worker itself
self.close();
```

### Q: What's the difference between Worker and Service Worker?

**Worker:**

- General background processing
- One-to-one with main thread (dedicated)
- For CPU-intensive tasks

**Service Worker:**

- Background service for web apps
- Can intercept network requests
- Used for offline functionality, push notifications

### Q: Are Web Workers shared across browser tabs?

**Dedicated Workers:** No, each tab has its own worker instance.

**Shared Workers:** Yes, can be shared across multiple tabs/windows (same origin).

---

## Performance Considerations

### ‚úÖ When to Use Workers

- CPU-intensive calculations
- Large data processing
- Image/video manipulation
- Tasks that would freeze the UI

### ‚ùå When NOT to Use Workers

- Simple operations (overhead not worth it)
- Tasks that need DOM access (use main thread)
- Small data processing (message passing overhead)

### Overhead

- Creating workers has overhead
- Message passing has overhead (data cloning)
- Use workers only when benefits outweigh costs

---

## Limitations

1. **No DOM Access** - Must communicate with main thread
2. **Message Passing Overhead** - Data is cloned, not shared
3. **Limited API Access** - Many Web APIs unavailable
4. **Browser Support** - Check compatibility for older browsers
5. **Memory Usage** - Each worker uses separate memory space

---

## Best Practices

1. **Use for heavy tasks** - Don't use for simple operations
2. **Handle errors** - Always implement error handlers
3. **Terminate properly** - Clean up workers when done
4. **Batch messages** - Reduce message passing overhead
5. **Reuse workers** - Don't create/destroy frequently

---

üìñ **See Also:**

- [14. Async Operations.md](<../02.%20JavaScript%20Runtime%20Environment%20(JRE)/14.%20Async%20Operations.md>) for async patterns
- [00. WebAPIs Overview.md](./00.%20WebAPIs%20Overview.md) for other Web APIs
- Service Workers (separate topic for PWA)
