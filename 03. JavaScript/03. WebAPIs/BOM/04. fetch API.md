# ‚úÖ Must-Know `fetch` API ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

The `fetch` API is a modern Web API for making HTTP requests. It returns Promises and is the standard way to handle network requests in modern JavaScript.

---

## Basic Syntax

```js
fetch(url, options)
  .then((response) => response.json())
  .then((data) => console.log(data))
  .catch((error) => console.error(error));
```

**Returns:** Promise that resolves to a `Response` object

---

## GET Request

### Basic GET

```js
fetch("https://api.example.com/users")
  .then((response) => response.json())
  .then((data) => console.log(data));
```

### GET with Async/Await

```js
async function getUsers() {
  try {
    const response = await fetch("https://api.example.com/users");
    const data = await response.json();
    return data;
  } catch (error) {
    console.error("Error:", error);
  }
}
```

---

## POST Request

```js
fetch("https://api.example.com/users", {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
  },
  body: JSON.stringify({
    name: "John",
    age: 30,
  }),
})
  .then((response) => response.json())
  .then((data) => console.log(data));
```

---

## Request Options

### Method

```js
fetch(url, {
  method: "GET", // GET, POST, PUT, DELETE, PATCH, etc.
});
```

### Headers

```js
fetch(url, {
  headers: {
    "Content-Type": "application/json",
    Authorization: "Bearer token123",
  },
});
```

### Body

```js
// JSON
fetch(url, {
  method: "POST",
  body: JSON.stringify({ key: "value" }),
});

// FormData
const formData = new FormData();
formData.append("name", "John");
fetch(url, {
  method: "POST",
  body: formData,
});

// URLSearchParams
const params = new URLSearchParams();
params.append("key", "value");
fetch(url, {
  method: "POST",
  body: params,
});
```

---

## Response Object

### Response Properties

```js
const response = await fetch(url);

response.status; // HTTP status code (200, 404, etc.)
response.statusText; // Status text ("OK", "Not Found")
response.ok; // Boolean (true if status 200-299)
response.headers; // Headers object
response.url; // Final URL after redirects
```

### Response Methods

```js
const response = await fetch(url);

// Parse as JSON
const data = await response.json();

// Parse as text
const text = await response.text();

// Parse as blob
const blob = await response.blob();

// Parse as array buffer
const buffer = await response.arrayBuffer();

// Clone response (read multiple times)
const clone = response.clone();
```

---

## Error Handling

### Basic Error Handling

```js
fetch(url)
  .then((response) => {
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    return response.json();
  })
  .then((data) => console.log(data))
  .catch((error) => console.error("Error:", error));
```

### Async/Await Error Handling

```js
async function fetchData(url) {
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    return await response.json();
  } catch (error) {
    console.error("Fetch failed:", error);
    throw error;
  }
}
```

### Network vs HTTP Errors

```js
fetch(url)
  .then((response) => {
    // Network request succeeded
    if (!response.ok) {
      // HTTP error (404, 500, etc.)
      throw new Error(`HTTP ${response.status}`);
    }
    return response.json();
  })
  .catch((error) => {
    // Network error OR HTTP error
    if (error.name === "TypeError") {
      console.error("Network error - no response received");
    } else {
      console.error("HTTP error:", error);
    }
  });
```

---

## Common Patterns

### Multiple Requests (Parallel)

```js
const [users, posts, comments] = await Promise.all([
  fetch("/api/users").then((r) => r.json()),
  fetch("/api/posts").then((r) => r.json()),
  fetch("/api/comments").then((r) => r.json()),
]);
```

### Request with Timeout

```js
function fetchWithTimeout(url, timeout = 5000) {
  return Promise.race([
    fetch(url),
    new Promise((_, reject) =>
      setTimeout(() => reject(new Error("Timeout")), timeout)
    ),
  ]);
}
```

### Retry Logic

```js
async function fetchWithRetry(url, retries = 3) {
  for (let i = 0; i < retries; i++) {
    try {
      const response = await fetch(url);
      if (response.ok) return response.json();
      throw new Error(`HTTP ${response.status}`);
    } catch (error) {
      if (i === retries - 1) throw error;
      await new Promise((resolve) => setTimeout(resolve, 1000 * (i + 1)));
    }
  }
}
```

---

## Interview Common Questions

### Q: What does fetch return?

A Promise that resolves to a `Response` object. The Promise **does not reject on HTTP error status** (404, 500, etc.) - it only rejects on network failures.

### Q: How to handle errors with fetch?

```js
fetch(url)
  .then((response) => {
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }
    return response.json();
  })
  .catch((error) => {
    // Handles both network and HTTP errors
  });
```

### Q: Difference between fetch and XMLHttpRequest?

**fetch:**

- Promise-based
- Modern, cleaner API
- Doesn't reject on HTTP errors
- Better for modern async/await

**XMLHttpRequest:**

- Callback-based
- Older API
- More control over request lifecycle
- Better for legacy browsers

### Q: How to cancel a fetch request?

Use `AbortController`:

```js
const controller = new AbortController();

fetch(url, { signal: controller.signal })
  .then((response) => response.json())
  .catch((error) => {
    if (error.name === "AbortError") {
      console.log("Request cancelled");
    }
  });

// Cancel the request
controller.abort();
```

### Q: How to send cookies with fetch?

```js
fetch(url, {
  credentials: "include", // Send cookies
});
```

Options: `"same-origin"` (default), `"include"`, `"omit"`

---

## Important Notes

### ‚ö†Ô∏è fetch Doesn't Reject on HTTP Errors

```js
// This Promise RESOLVES even if status is 404 or 500!
fetch("https://api.example.com/not-found").then((response) => {
  console.log(response.status); // 404
  console.log(response.ok); // false
  // Still need to check response.ok!
});
```

### ‚úÖ Always Check response.ok

```js
fetch(url).then((response) => {
  if (!response.ok) {
    throw new Error(`HTTP ${response.status}`);
  }
  return response.json();
});
```

### ‚ö†Ô∏è Response Can Only Be Read Once

```js
const response = await fetch(url);
const text = await response.text(); // ‚úÖ First read
const json = await response.json(); // ‚ùå Error! Already read

// Solution: Clone the response
const clone = response.clone();
const text = await response.text();
const json = await clone.json();
```

---

üìñ **See Also:**

- [14. Async Operations.md](<../02.%20JavaScript%20Runtime%20Environment%20(JRE)/14.%20Async%20Operations.md>) for async patterns
- [07. Event Loop.md](<../02.%20JavaScript%20Runtime%20Environment%20(JRE)/07.%20Event%20Loop.md>) for how fetch callbacks execute
- [00. WebAPIs Overview.md](./00.%20WebAPIs%20Overview.md) for other Web APIs
