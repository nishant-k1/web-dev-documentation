# Browser Rendering Pipeline

Understanding how browsers transform HTML, CSS, and JavaScript into pixels on your screen.

---

## Core Concept

When you visit a webpage, the browser doesn't just display it instantly. It goes through a **multi-stage pipeline** to convert raw HTML/CSS/JS into a visual page.

**The Critical Rendering Path:**

```
HTML → DOM → CSSOM → Render Tree → Layout → Paint → Composite
```

---

## The Complete Pipeline

### Stage 1: HTML Parsing → DOM Construction

**What happens:**

- Browser receives HTML bytes from the server
- HTML parser tokenizes the HTML (breaks it into tokens)
- Parser builds the **DOM (Document Object Model)** tree

**Example:**

```html
<html>
  <head>
    <title>My Page</title>
  </head>
  <body>
    <h1>Hello</h1>
    <p>World</p>
  </body>
</html>
```

**DOM Tree Structure:**

```
document
└── html
    ├── head
    │   └── title ("My Page")
    └── body
        ├── h1 ("Hello")
        └── p ("World")
```

**Key Points:**

- DOM is built **incrementally** (as HTML arrives)
- Parser can be **blocked** by synchronous `<script>` tags
- External resources (images, CSS) don't block DOM construction

---

### Stage 2: CSS Parsing → CSSOM Construction

**What happens:**

- Browser receives CSS bytes
- CSS parser parses stylesheets
- Builds **CSSOM (CSS Object Model)** tree

**Example:**

```css
body {
  font-size: 16px;
  color: black;
}
h1 {
  font-size: 24px;
  color: blue;
}
```

**CSSOM Tree Structure:**

```
stylesheets
└── body
    ├── font-size: 16px
    └── color: black
└── h1
    ├── font-size: 24px
    └── color: blue
```

**Key Points:**

- CSS is **render-blocking** (browser won't paint until CSS is loaded)
- CSSOM is built **before** rendering can start
- Multiple stylesheets are combined into one CSSOM

---

### Stage 3: Render Tree Construction

**What happens:**

- Browser combines DOM + CSSOM
- Creates **Render Tree** (only visible elements)
- Excludes: `<head>`, `<script>`, hidden elements (`display: none`)

**Example:**

**DOM:**

```
body
├── h1 (visible)
├── script (excluded from render tree)
└── p (visible)
```

**Render Tree:**

```
body
├── h1 (with styles: font-size: 24px, color: blue)
└── p (with styles: font-size: 16px, color: black)
```

**Key Points:**

- Render tree only contains **visible elements**
- Each node has **computed styles** (DOM + CSSOM combined)
- Hidden elements (`display: none`) are excluded

---

### Stage 4: Layout (Reflow)

**What happens:**

- Browser calculates **exact position and size** of each element
- Determines where each element should be placed on the page
- Creates a **layout tree** with coordinates

**Example:**

```
body (0, 0, 800px width, 600px height)
└── h1 (10px, 10px, 780px width, 30px height)
└── p (10px, 50px, 780px width, 20px height)
```

**Key Points:**

- Layout calculates **geometric properties** (x, y, width, height)
- Layout is **expensive** (CPU-intensive)
- Layout can be **triggered** by:
  - Window resize
  - Reading layout properties (`offsetWidth`, `offsetHeight`)
  - Adding/removing DOM elements
  - Changing CSS that affects layout

---

### Stage 5: Paint

**What happens:**

- Browser fills in the **pixels** for each element
- Draws text, colors, borders, backgrounds
- Creates **paint records** (list of drawing operations)

**Example:**

```
Paint operations:
1. Fill body background (white)
2. Draw h1 text "Hello" (blue, 24px)
3. Draw p text "World" (black, 16px)
```

**Key Points:**

- Paint fills in **visual appearance** (colors, images, text)
- Paint is **less expensive** than layout
- Paint can be **triggered** by:
  - Color changes
  - Background changes
  - Border changes
  - Text changes

---

### Stage 6: Composite

**What happens:**

- Browser combines painted layers into **final image**
- Uses **GPU** for hardware acceleration
- Sends final pixels to screen

**Key Points:**

- Composite is the **fastest** stage (uses GPU)
- Elements with `transform` or `opacity` get their own **composite layer**
- Composite layers are **cached** and reused

---

## Visual Timeline

```
Time →
│
├─ HTML arrives
│  └─ DOM construction starts
│
├─ CSS arrives
│  └─ CSSOM construction starts
│
├─ DOM + CSSOM ready
│  └─ Render tree construction
│
├─ Render tree ready
│  └─ Layout calculation (reflow)
│
├─ Layout complete
│  └─ Paint operations
│
├─ Paint complete
│  └─ Composite layers
│
└─ Pixels on screen ✨
```

---

## What Blocks Rendering?

### Render-Blocking Resources

**CSS:**

- `<link rel="stylesheet">` **blocks rendering**
- Browser waits for CSS before painting
- **Solution:** Use `media` attribute or inline critical CSS

**JavaScript:**

- `<script>` without `async`/`defer` **blocks HTML parsing**
- Blocks DOM construction
- **Solution:** Use `async` or `defer`

**Example:**

```html
<!-- ❌ Blocks rendering -->
<link rel="stylesheet" href="styles.css" />

<!-- ✅ Non-blocking (loads async) -->
<link rel="preload" href="styles.css" as="style" />
```

---

## Optimizing the Critical Rendering Path

### 1. Minimize Render-Blocking CSS

```html
<!-- ❌ Blocks rendering -->
<link rel="stylesheet" href="all-styles.css" />

<!-- ✅ Only blocks for print -->
<link rel="stylesheet" href="print.css" media="print" />

<!-- ✅ Inline critical CSS -->
<style>
  /* Critical above-the-fold styles */
</style>
```

### 2. Defer Non-Critical JavaScript

```html
<!-- ❌ Blocks HTML parsing -->
<script src="app.js"></script>

<!-- ✅ Doesn't block parsing -->
<script src="app.js" defer></script>
<script src="app.js" async></script>
```

### 3. Minimize Layout Shifts

```css
/* ❌ Causes layout shift */
img {
  /* No dimensions */
}

/* ✅ Prevents layout shift */
img {
  width: 100%;
  height: auto;
  aspect-ratio: 16/9;
}
```

---

## Key Metrics

### First Contentful Paint (FCP)

- When first text or image appears
- Measures **paint** stage

### Largest Contentful Paint (LCP)

- When largest content element appears
- Measures **paint** stage

### Cumulative Layout Shift (CLS)

- Measures unexpected layout shifts
- Measures **layout** stage

---

## Common Questions

### Q: Why does CSS block rendering?

**A:** CSS affects how elements look. Browser needs CSSOM before it can paint anything. Without CSS, browser would paint unstyled content, then repaint when CSS loads (causing flash of unstyled content).

### Q: What's the difference between DOM and Render Tree?

**A:**

- **DOM:** Complete tree of all HTML elements (including `<head>`, `<script>`, hidden elements)
- **Render Tree:** Only visible elements with computed styles (excludes hidden elements)

### Q: Why is layout expensive?

**A:** Layout recalculates positions and sizes of all elements. If one element changes, browser may need to recalculate positions of many other elements (cascade effect).

### Q: What triggers a reflow?

**A:**

- Reading layout properties (`offsetWidth`, `offsetHeight`, `getBoundingClientRect()`)
- Changing CSS that affects layout (width, height, position, display)
- Adding/removing DOM elements
- Window resize

---

## Related Topics

- [Resource Loading Behavior](./4.%20Resource%20Loading%20Behavior.md) - How resources load and block rendering
- [Browser Layout and Rendering](./12.%20Browser%20Layout%20and%20Rendering.md) - Reflow, repaint, composite details
- [Browser Caching Mechanisms](./17.%20Browser%20Caching%20Mechanisms.md) - How caching affects rendering
- [Browser Request Lifecycle](./1.%20Browser%20Request%20Lifecycle.md) - How browsers initiate requests

---

## Summary

**The Critical Rendering Path:**

1. **HTML → DOM** (parsing)
2. **CSS → CSSOM** (parsing)
3. **DOM + CSSOM → Render Tree** (combining)
4. **Layout** (calculating positions)
5. **Paint** (filling pixels)
6. **Composite** (combining layers)

**Key Takeaways:**

- CSS blocks rendering (browser waits for CSSOM)
- JavaScript blocks HTML parsing (unless async/defer)
- Layout is expensive (minimize reflows)
- Composite is fast (use GPU-accelerated properties)
