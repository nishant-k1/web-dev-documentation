# Browser Caching Mechanisms

Understanding how browsers cache resources to improve performance and enable offline functionality.

---

## Core Concept

Browsers cache resources (HTML, CSS, JS, images) to avoid re-downloading them on subsequent visits. This speeds up page loads and reduces server load.

**Two Main Caching Systems:**

1. **HTTP Cache** (browser's built-in cache)
2. **Service Worker Cache** (programmable cache)

---

## HTTP Cache

### How HTTP Cache Works

**Basic Flow:**

```
1. Browser requests resource
   ↓
2. Check cache?
   ├─ Cache hit → Use cached version
   └─ Cache miss → Request from server
       ↓
3. Server responds with cache headers
   ↓
4. Browser stores in cache (if cacheable)
```

---

### Cache-Control Header

**Most important cache header.** Controls how long browser caches resources.

**Common Directives:**

| Directive         | Meaning                                  | Example                               |
| ----------------- | ---------------------------------------- | ------------------------------------- |
| `max-age=3600`    | Cache for 3600 seconds (1 hour)          | `Cache-Control: max-age=3600`         |
| `no-cache`        | Must revalidate with server before using | `Cache-Control: no-cache`             |
| `no-store`        | Don't cache at all                       | `Cache-Control: no-store`             |
| `private`         | Cache only in browser (not in CDN)       | `Cache-Control: private`              |
| `public`          | Cache in browser and CDN                 | `Cache-Control: public, max-age=3600` |
| `must-revalidate` | Must check with server if expired        | `Cache-Control: must-revalidate`      |

**Examples:**

```http
# Cache for 1 hour
Cache-Control: max-age=3600

# Don't cache
Cache-Control: no-store

# Cache but must revalidate
Cache-Control: no-cache, must-revalidate

# Cache for 1 day, public (CDN can cache)
Cache-Control: public, max-age=86400
```

---

### ETag and Last-Modified

**Validation Headers:** Used to check if cached resource is still fresh.

**ETag (Entity Tag):**

- Unique identifier for resource version
- Server sends: `ETag: "abc123"`
- Browser sends: `If-None-Match: "abc123"` on next request
- If unchanged, server responds: `304 Not Modified` (no body)

**Last-Modified:**

- Timestamp of when resource was last modified
- Server sends: `Last-Modified: Wed, 21 Oct 2024 07:28:00 GMT`
- Browser sends: `If-Modified-Since: Wed, 21 Oct 2024 07:28:00 GMT`
- If unchanged, server responds: `304 Not Modified`

**Example Flow:**

```
Request 1:
GET /app.js
→ Server: 200 OK
   ETag: "abc123"
   Cache-Control: max-age=3600
   [JavaScript content]

Request 2 (within 1 hour):
GET /app.js
If-None-Match: "abc123"
→ Server: 304 Not Modified
   ETag: "abc123"
   [No body - browser uses cached version]

Request 3 (after 1 hour):
GET /app.js
If-None-Match: "abc123"
→ Server: 200 OK
   ETag: "xyz789"  (changed!)
   [New JavaScript content]
```

---

### Cache Strategies

#### 1. Cache-First (Stale-While-Revalidate)

**Strategy:** Use cache immediately, update in background.

```
Request → Check cache
├─ Cache hit → Return cached (even if stale)
│              → Update cache in background
└─ Cache miss → Fetch from network
```

**Use Case:** Static assets (images, fonts, CSS)

**Implementation:**

```http
Cache-Control: public, max-age=31536000, stale-while-revalidate=86400
```

---

#### 2. Network-First

**Strategy:** Try network first, fall back to cache.

```
Request → Try network
├─ Network success → Return network, update cache
└─ Network fail → Return cache (if available)
```

**Use Case:** API responses that need fresh data

**Implementation:** Service Worker (see below)

---

#### 3. Cache-Only

**Strategy:** Only use cache, never network.

```
Request → Check cache
├─ Cache hit → Return cached
└─ Cache miss → Error
```

**Use Case:** Offline-first apps

**Implementation:** Service Worker

---

#### 4. Network-Only

**Strategy:** Always fetch from network, never cache.

```
Request → Fetch from network
→ Return network response
```

**Use Case:** Sensitive data, real-time data

**Implementation:**

```http
Cache-Control: no-store
```

---

## Service Worker Cache

### What is Service Worker?

**Service Worker** is a JavaScript file that runs in the background, intercepting network requests. It can cache responses programmatically.

**Key Features:**

- Runs in background (even when page is closed)
- Can intercept network requests
- Can cache responses
- Enables offline functionality

---

### Service Worker Lifecycle

```
1. Registration
   ↓
2. Installation
   ↓
3. Activation
   ↓
4. Active (intercepts requests)
```

**Example:**

```javascript
// Register Service Worker
if ("serviceWorker" in navigator) {
  navigator.serviceWorker.register("/sw.js");
}
```

---

### Cache API

**Service Workers use Cache API to store responses.**

**Basic Usage:**

```javascript
// Open cache
const cache = await caches.open("my-cache-v1");

// Store response
await cache.put("/api/data", response);

// Retrieve from cache
const cachedResponse = await cache.match("/api/data");
```

---

### Service Worker Cache Strategies

#### 1. Cache-First

```javascript
self.addEventListener("fetch", (event) => {
  event.respondWith(
    caches.match(event.request).then((cached) => {
      if (cached) {
        return cached; // Return from cache
      }
      return fetch(event.request).then((response) => {
        // Cache for next time
        caches.open("v1").then((cache) => {
          cache.put(event.request, response.clone());
        });
        return response;
      });
    })
  );
});
```

#### 2. Network-First

```javascript
self.addEventListener("fetch", (event) => {
  event.respondWith(
    fetch(event.request)
      .then((response) => {
        // Cache successful responses
        caches.open("v1").then((cache) => {
          cache.put(event.request, response.clone());
        });
        return response;
      })
      .catch(() => {
        // Network failed, try cache
        return caches.match(event.request);
      })
  );
});
```

#### 3. Stale-While-Revalidate

```javascript
self.addEventListener("fetch", (event) => {
  event.respondWith(
    caches.match(event.request).then((cached) => {
      // Start fetch in background
      const fetchPromise = fetch(event.request).then((response) => {
        caches.open("v1").then((cache) => {
          cache.put(event.request, response.clone());
        });
        return response;
      });

      // Return cached immediately, update in background
      return cached || fetchPromise;
    })
  );
});
```

---

## HTTP Cache vs Service Worker Cache

| Feature         | HTTP Cache                           | Service Worker Cache          |
| --------------- | ------------------------------------ | ----------------------------- |
| **Control**     | Server-controlled (headers)          | Programmable (JavaScript)     |
| **Offline**     | No (requires network for validation) | Yes (can work offline)        |
| **Flexibility** | Limited (header-based)               | High (custom logic)           |
| **Performance** | Fast (native)                        | Slightly slower (JS overhead) |
| **Use Case**    | Static assets                        | Dynamic content, offline apps |

---

## Cache Invalidation

### Problem

When you update a file, browsers may still use cached version.

### Solutions

#### 1. Versioned URLs

```html
<!-- Old version cached -->
<script src="/app.js"></script>

<!-- New version (different URL) -->
<script src="/app.v2.js"></script>
```

#### 2. Query Parameters

```html
<!-- Cache busting -->
<script src="/app.js?v=2"></script>
```

#### 3. Content-Based Hashing

```html
<!-- Hash changes when content changes -->
<script src="/app.abc123.js"></script>
```

**Build tools (Webpack, Vite) do this automatically:**

```javascript
// webpack.config.js
output: {
  filename: "[name].[contenthash].js";
}
```

---

## Common Cache Headers Examples

### Static Assets (Images, Fonts)

```http
Cache-Control: public, max-age=31536000, immutable
```

- Cache for 1 year
- `immutable` = never changes (content-hashed)

### HTML

```http
Cache-Control: no-cache, must-revalidate
```

- Always check with server
- HTML changes frequently

### API Responses

```http
Cache-Control: private, max-age=60
```

- Cache for 1 minute
- `private` = only in browser (not CDN)

### Sensitive Data

```http
Cache-Control: no-store
```

- Never cache
- For sensitive information

---

## Debugging Cache

### Chrome DevTools

**Network Tab:**

- **Size column:** Shows `(disk cache)` or `(memory cache)` for cached resources
- **Status:** `304 Not Modified` = cache validation successful

**Application Tab:**

- **Cache Storage:** View Service Worker caches
- **Clear Storage:** Clear all caches

---

## Best Practices

### 1. Cache Static Assets Aggressively

```http
Cache-Control: public, max-age=31536000, immutable
```

### 2. Use Content Hashing for Cache Busting

```html
<!-- Hash changes when content changes -->
<link rel="stylesheet" href="styles.abc123.css" />
```

### 3. Revalidate HTML

```http
Cache-Control: no-cache, must-revalidate
```

### 4. Use Service Workers for Offline Support

```javascript
// Cache critical resources
self.addEventListener("install", (event) => {
  event.waitUntil(
    caches.open("v1").then((cache) => {
      return cache.addAll(["/", "/styles.css", "/app.js"]);
    })
  );
});
```

---

## Common Questions

### Q: What's the difference between `no-cache` and `no-store`?

**A:**

- `no-cache`: Browser can cache, but must revalidate with server before using
- `no-store`: Browser cannot cache at all

### Q: How long does browser cache resources?

**A:** Depends on `Cache-Control` header. If no header, browser uses **heuristic caching** (usually short duration).

### Q: Can I clear browser cache programmatically?

**A:** No. Browsers don't allow JavaScript to clear HTTP cache (security). You can clear Service Worker cache via Cache API.

### Q: What happens when cache is full?

**A:** Browser uses **LRU (Least Recently Used)** eviction - removes oldest/unused cached resources.

---

## Related Topics

- [Browser Request Lifecycle](./1.%20Browser%20Request%20Lifecycle.md) - How requests work
- [Resource Loading Behavior](./4.%20Resource%20Loading%20Behavior.md) - How resources load
- [Static File Serving](./9.%20Static%20File%20Serving.md) - How static files are served
- [Browser Rendering Pipeline](./11.%20Browser%20Rendering%20Pipeline.md) - How caching affects rendering

---

## Summary

**HTTP Cache:**

- Controlled by server headers (`Cache-Control`, `ETag`)
- Fast, native browser feature
- Good for static assets

**Service Worker Cache:**

- Programmable via JavaScript
- Enables offline functionality
- Good for dynamic content

**Cache Strategies:**

- **Cache-First:** Fast, may be stale
- **Network-First:** Fresh, may be slow
- **Stale-While-Revalidate:** Fast + fresh

**Key Takeaways:**

- Use `Cache-Control` headers to control caching
- Use content hashing for cache busting
- Use Service Workers for offline support
- Cache static assets aggressively, revalidate HTML
